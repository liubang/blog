<!doctype html><html class=position-relative itemscope itemtype=http://schema.org/WebPage lang=zh-cn data-bs-theme=auto data-palette=blue-gray><head><script src=https://iliubang.cn/assets/init/bundle.min.3da12751111ad56e89821692250760caebec6175ec50d3935a16cc4acc140276.js integrity="sha256-PaEnUREa1W6JghaSJQdgyuvsYXXsUNOTWhbMSswUAnY=" crossorigin=anonymous></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>PHP7虚拟机 - liubang's blog</title><link rel=icon href=https://iliubang.cn/favicon_huc1d2ba7c7d6d5aa3e01f2f328b911c53_11507_16x16_resize_box_3.png sizes=16x16 type=image/png><link rel=icon href=https://iliubang.cn/favicon_huc1d2ba7c7d6d5aa3e01f2f328b911c53_11507_32x32_resize_box_3.png sizes=32x32 type=image/png><link rel=apple-touch-icon href=https://iliubang.cn/favicon_huc1d2ba7c7d6d5aa3e01f2f328b911c53_11507_180x180_resize_box_3.png sizes=180x180 type=image/png><link rel=icon href=https://iliubang.cn/favicon_huc1d2ba7c7d6d5aa3e01f2f328b911c53_11507_150x150_resize_box_3.png sizes=150x150 type=image/png><link rel=icon href="https://iliubang.cn/images/icons/icon-192x192.png?version=5675e36f11a529bcbecb4e1fae90c416" sizes=192x192><link rel=mask-icon href=https://iliubang.cn/safari-pinned-tab.svg color=#6f42c1><link rel=icon href="https://iliubang.cn/images/icons/favicon.ico?version=93c96d13551a46e5742ae6da86026661"><meta name=keywords content><meta name=description content="原文地址http://nikic.github.io/2017/04/14/PHP-7-Virtual-machine.html 写这篇文章的"><meta name=robots content="index, follow"><meta name=twitter:card content="summary"><meta name=twitter:title content="PHP7虚拟机"><meta name=twitter:description content="原文地址http://nikic.github.io/2017/04/14/PHP-7-Virtual-machine.html 写这篇文章的"><meta property="og:title" content="PHP7虚拟机"><meta property="og:description" content="原文地址http://nikic.github.io/2017/04/14/PHP-7-Virtual-machine.html 写这篇文章的"><meta property="og:type" content="article"><meta property="og:url" content="https://iliubang.cn/posts/php/2017-11-29-php7%E8%99%9A%E6%8B%9F%E6%9C%BA/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-11-29T00:00:00+00:00"><meta property="article:modified_time" content="2017-11-29T00:00:00+00:00"><meta itemprop=name content="PHP7虚拟机"><meta itemprop=description content="原文地址http://nikic.github.io/2017/04/14/PHP-7-Virtual-machine.html 写这篇文章的"><meta itemprop=datePublished content="2017-11-29T00:00:00+00:00"><meta itemprop=dateModified content="2017-11-29T00:00:00+00:00"><meta itemprop=wordCount content="17487"><meta itemprop=keywords content="c,php,compiler,"><meta property="og:image" content="https://iliubang.cn/images/apple-touch-icon.png"><meta name=twitter:image content="https://iliubang.cn/images/apple-touch-icon.png"><link rel=manifest href=https://iliubang.cn/manifest.json><link data-precache rel=stylesheet href="https://iliubang.cn/assets/main/bundle.min.aaa76da54b55f6aa4b733d08ac514fb862dca78a5d0f4c9d647fcf4c6a5bc9e9.css" integrity="sha256-qqdtpUtV9qpLcz0IrFFPuGLcp4pdD0ydZH/PTGpbyek=" crossorigin=anonymous><link data-precache rel=stylesheet href=https://iliubang.cn/assets/katex/bundle.min.c7738aed5534d96f5c4eb1790af05b44a2ca1cc7d0cb6d5de1dcf95595d3f91a.css integrity="sha256-x3OK7VU02W9cTrF5CvBbRKLKHMfQy21d4dz5VZXT+Ro=" crossorigin=anonymous><link data-precache rel=stylesheet href=https://iliubang.cn/assets/viewer/bundle.min.6d0fc65b8b058ac563091dc5c36f61afba5dd705058680aa24f1d5a3bcf0064d.css integrity="sha256-bQ/GW4sFisVjCR3Fw29hr7pd1wUFhoCqJPHVo7zwBk0=" crossorigin=anonymous></head><body><header><nav class="top-app-bar shadow navbar navbar-expand-lg fixed-top"><div class=container><a class="navbar-brand d-flex align-items-center flex-grow-1 flex-lg-grow-0 text-lg-start ms-2 ms-lg-0 mx-auto me-lg-2" href=https://iliubang.cn><picture><img class=logo alt=Logo src=https://iliubang.cn/images/apple-touch-icon.png loading=lazy width=180 height=180>
</picture>HIGHKYCK</a>
<button class="navbar-toggler order-5" type=button data-bs-toggle=offcanvas data-bs-target=#navbarMenus aria-controls=navbarMenus aria-expanded=false aria-label="Toggle navigation">
<i class="fas fa-ellipsis-h"></i></button><div class="offcanvas-lg offcanvas-end flex-grow-1" data-bs-scroll=true tabindex=-1 id=navbarMenus aria-labelledby=navbarMenusLabel><div class="offcanvas-header px-4 pb-0"><h5 class=offcanvas-title id=navbarMenusLabel>liubang's blog</h5><button type=button class="btn-close btn-close-white" data-bs-dismiss=offcanvas data-bs-target=#navbarMenus aria-label=Close></button></div><div class="offcanvas-body p-4 pt-0 p-lg-0"><hr class=d-lg-none><ul class="navbar-nav flex-row flex-wrap align-items-center me-auto"><li class="nav-item col-6 col-lg-auto"><a class="nav-link py-2 px-0 px-lg-2" href=https://iliubang.cn/series/><i class="fas fa-fw fa-columns"></i>专栏</a></li><li class="nav-item col-6 col-lg-auto"><a class="nav-link py-2 px-0 px-lg-2" href=https://iliubang.cn/archives/><i class="fas fa-fw fa-file-archive"></i>归档</a></li><li class="nav-item col-6 col-lg-auto dropdown px-0"><a href=# class="nav-link dropdown-toggle" id=navbarDropdownCategories role=button data-bs-toggle=dropdown aria-expanded=false><i class="fas fa-fw fa-folder"></i>分类</a><ul class="dropdown-menu dropdown-menu-end" aria-labelledby=navbarDropdownCategories data-bs-popper=none><li><a class="dropdown-item text-wrap text-lg-nowrap" href=https://iliubang.cn/categories/programming><i class="fas fa-fw fa-code me-1"></i>Programing</a></li><li><a class="dropdown-item text-wrap text-lg-nowrap" href=https://iliubang.cn/categories/reading><i class="fas fa-fw fa-book-reader me-1"></i>Reading</a></li><li><a class="dropdown-item text-wrap text-lg-nowrap" href=https://iliubang.cn/categories/linux><i class="fab fa-fw fa-linux me-1"></i>Linux</a></li><li><a class="dropdown-item text-wrap text-lg-nowrap" href=https://iliubang.cn/categories><i class="fas fa-fw fa-folder me-1"></i>所有分类</a></li></ul></li><li class="nav-item col-6 col-lg-auto dropdown px-0"><a href=# class="nav-link dropdown-toggle" id=navbarDropdownTags role=button data-bs-toggle=dropdown aria-expanded=false><i class="fas fa-fw fa-tags me-1"></i>标签</a><ul class="dropdown-menu dropdown-menu-end" aria-labelledby=navbarDropdownTags data-bs-popper=none><li><a class="dropdown-item text-wrap text-lg-nowrap" href=https://iliubang.cn/tags/algorithm><i class="fas fa-fw fa-square-root-alt me-1"></i>Algorithm</a></li><li><a class="dropdown-item text-wrap text-lg-nowrap" href=https://iliubang.cn/tags/c++><i class="fab fa-fw fa-google me-1"></i>C++</a></li><li><a class="dropdown-item text-wrap text-lg-nowrap" href=https://iliubang.cn/tags/go><i class="fab fa-fw fa-google me-1"></i>Go</a></li><li><a class="dropdown-item text-wrap text-lg-nowrap" href=https://iliubang.cn/tags/java><i class="fab fa-fw fa-java me-1"></i>Java</a></li><li><a class="dropdown-item text-wrap text-lg-nowrap" href=https://iliubang.cn/tags/storage><i class="fas fa-fw fa-database me-1"></i>Storage</a></li><li><a class="dropdown-item text-wrap text-lg-nowrap" href=https://iliubang.cn/tags><i class="fas fa-fw fa-tags me-1"></i>所有标签</a></li></ul></li></ul><hr class=d-lg-none><form class="search-bar ms-auto my-1" action=https://iliubang.cn/search/ novalidate><div class="input-group input-group-sm align-items-center"><span class="btn btn-search disabled position-absolute left-0 border-0"><i class="fas fa-fw fa-search fa-lg"></i></span>
<input class="py-2 form-control rounded search-input" name=q type=search aria-label=Search required></div></form><hr class=d-lg-none><ul class="navbar-nav flex-row flex-wrap align-items-center ms-md-auto"><li class="nav-item py-2 py-lg-1 col-12 col-lg-auto"><nav class="social-links nav justify-content-center flex-row"><a class="nav-link social-link col-6 col-lg-auto p-1" target=_blank href=https://github.com/liubang title=GitHub rel="noopener noreferrer"><i class="fa-fw fab fa-github"></i>
<span class="ms-1 d-lg-none">Github</span></a>
<a class="nav-link social-link col-6 col-lg-auto p-1" target=_blank href=https://iliubang.cn/index.xml title=RSS rel="noopener noreferrer"><i class="fas fa-fw fa-rss"></i>
<span class="ms-1 d-lg-none">RSS</span></a></nav></li><li class="nav-item py-2 py-lg-1 col-12 col-lg-auto"><div class="vr d-none d-lg-flex h-100 mx-lg-2 text-white"></div><hr class="d-lg-none my-2"></li><li class="nav-item dropdown py-1 py-lg-1 col-6 col-lg-auto"><a class="nav-link px-0 px-lg-1" href=# id=languageDropdown role=button data-bs-toggle=dropdown aria-expanded=false><i class="fas fa-fw fa-globe"></i>
<span class=d-lg-none>语言</span></a><ul class="dropdown-menu dropdown-menu-end" aria-labelledby=languageDropdown><li><a class=dropdown-item href=https://iliubang.cn/en/>English</a></li><li><a class="dropdown-item active" href=https://iliubang.cn/>简体中文</a></li></ul></li><li class="nav-item py-1 col-12 col-lg-auto"><div class="vr d-none d-lg-flex h-100 mx-lg-2 text-white"></div><hr class="d-lg-none my-2"></li><li class="nav-item dropdown col-6 col-lg-auto"><a class="nav-link px-0 py-2 px-lg-1" href=# id=paletteDropdown role=button data-bs-toggle=dropdown aria-expanded=false><i class="fas fa-fw fa-palette"></i>
<span class=d-lg-none>配色</span></a><ul class="dropdown-menu dropdown-menu-end px-2" aria-labelledby=paletteDropdown><div class=row><li class="col-4 my-1"><a role=button id=palette-blue aria-label=蓝色 class="btn btn-sm w-100 palette text-bg-blue" data-palette=blue></a></li><li class="col-4 my-1"><a role=button id=palette-blue-gray aria-label=蓝灰色 class="btn btn-sm w-100 palette text-bg-blue-gray" data-palette=blue-gray></a></li><li class="col-4 my-1"><a role=button id=palette-brown aria-label=棕色 class="btn btn-sm w-100 palette text-bg-brown" data-palette=brown></a></li><li class="col-4 my-1"><a role=button id=palette-cyan aria-label=青色 class="btn btn-sm w-100 palette text-bg-cyan" data-palette=cyan></a></li><li class="col-4 my-1"><a role=button id=palette-green aria-label=绿色 class="btn btn-sm w-100 palette text-bg-green" data-palette=green></a></li><li class="col-4 my-1"><a role=button id=palette-indigo aria-label=靛青色 class="btn btn-sm w-100 palette text-bg-indigo" data-palette=indigo></a></li><li class="col-4 my-1"><a role=button id=palette-orange aria-label=橙色 class="btn btn-sm w-100 palette text-bg-orange" data-palette=orange></a></li><li class="col-4 my-1"><a role=button id=palette-pink aria-label=粉色 class="btn btn-sm w-100 palette text-bg-pink" data-palette=pink></a></li><li class="col-4 my-1"><a role=button id=palette-purple aria-label=紫色 class="btn btn-sm w-100 palette text-bg-purple" data-palette=purple></a></li><li class="col-4 my-1"><a role=button id=palette-red aria-label=红色 class="btn btn-sm w-100 palette text-bg-red" data-palette=red></a></li><li class="col-4 my-1"><a role=button id=palette-teal aria-label=蓝绿色 class="btn btn-sm w-100 palette text-bg-teal" data-palette=teal></a></li><li class="col-4 my-1"><a role=button id=palette-yellow aria-label=黄色 class="btn btn-sm w-100 palette text-bg-yellow" data-palette=yellow></a></li></div></ul></li><li class="nav-item dropdown col-6 col-lg-auto"><a class="nav-link px-0 py-2 px-lg-1" href=# id=modeDropdown role=button data-bs-toggle=dropdown aria-expanded=false><i class="mode-icon fas fa-fw fa-adjust" id=modeIcon></i>
<span class=d-lg-none>模式</span></a><ul class="dropdown-menu dropdown-menu-end" aria-labelledby=modeDropdown><li class=mode-item data-color-mode=light data-icon=sun><button class=dropdown-item>
<i class="mode-icon fas fa-fw fa-sun"></i> Light</button></li><li class=mode-item data-color-mode=dark data-icon=moon><button class=dropdown-item>
<i class="mode-icon fas fa-fw fa-moon"></i> Dark</button></li><li class="mode-item active" data-color-mode=auto data-icon=adjust><button class=dropdown-item>
<i class="mode-icon fas fa-fw fa-adjust"></i> Auto</button></li></ul></li></ul></div></div></div></nav></header><main class=container><div class="row content"><noscript><div class="alert alert-danger" role=alert>你的浏览器不支持 JavaScript。</div></noscript><div class=col-lg-8><div class=container><nav class="row card component" aria-label=breadcrumb><div class="card-body pb-0"><ol class=breadcrumb><li class="breadcrumb-item text-surface"><a href=https://iliubang.cn/>主页</a></li><li class="breadcrumb-item text-surface"><a href=https://iliubang.cn/posts/>文章</a></li><li class="breadcrumb-item active">PHP7虚拟机</li></ol></div></nav><div class="post-panel-wrapper position-sticky"><div class="d-flex flex-column component rounded post-panel position-absolute border"><a class="action action-panel-toggler" role=button title="Panel toggler"><i class="fas fa-fw fa-chevron-circle-down"></i></a>
<a id=sidebarToggler class="action d-none d-lg-block" role=button title="Sidebar toggler"><i class="fas fa-fw fa-expand-alt" data-fa-transform=rotate-45></i></a>
<a class="action btn-reward" role=button data-bs-toggle=modal data-bs-target=#rewardModal title=打赏><i class="fas fa-fw fa-coffee"></i></a>
<a class=action href=#post-copyright role=button aria-label=Copyright title=Copyright><i class="fas fa-fw fa-copyright"></i></a>
<a class=action href=#post-comments role=button aria-label=Comments title=Comments><i class="fas fa-fw fa-comments"></i></a>
<a class=action href=#postTOC aria-controls="Table of contents" role=button title="Table of contents"><i class="fas fa-fw fa-list-alt"></i></a></div></div><article class="row card component mb-4 post"><div class=card-header><h1 class="card-title post-title my-2">PHP7虚拟机</h1></div><div class=card-body><div class="post-meta mb-3"><span class="post-date me-1 mb-1" title="创建于 2017-11-29 00:00:00 +0000 UTC。">2017-11-29</span><span class="post-reading-time me-1 mb-1">35 分钟阅读</span><a href=https://iliubang.cn/categories/programming/ class="btn btn-sm btn-secondary mb-1 me-2 py-0 pe-1 post-taxonomy post-category">
<i class="fas fa-fw fa-folder me-1"></i>Programming</a><a href=https://iliubang.cn/tags/c/ class="btn btn-sm btn-secondary mb-1 me-2 py-0 pe-1 post-taxonomy post-tag">C</a><a href=https://iliubang.cn/tags/compiler/ class="btn btn-sm btn-secondary mb-1 me-2 py-0 pe-1 post-taxonomy post-tag">Compiler</a><a href=https://iliubang.cn/tags/php/ class="btn btn-sm btn-secondary mb-1 me-2 py-0 pe-1 post-taxonomy post-tag">Php</a></div><div id=postTOC class="mt-2 mb-4 d-block d-lg-none"><h2 class="text-surface mb-3">目录</h2><div id=post-toc-container></div></div><div class="post-share mb-3"><div class=addthis_inline_share_toolbox></div></div><div class="post-content mb-3" data-bs-spy=scroll data-bs-target=#TableOfContents tabindex=0><div id=post-content-body><p>原文地址<a href=http://nikic.github.io/2017/04/14/PHP-7-Virtual-machine.html target=_blank rel="noopener noreferrer">http://nikic.github.io/2017/04/14/PHP-7-Virtual-machine.html<i class="fas fa-external-link-square-alt ms-1"></i></a></p><p>写这篇文章的目的是基于 php7，阐述 Zend Virtual Machine 的内部实现。这不是一篇综合描述，我将尽可能地覆盖到所有重要的部分和细节。</p><p>本文的描述对象是 php7.2 版本，但是几乎所有的特性都已经应用在了 php7.0/7.1 中了。然而，它们同 php5.x 系列 VM 的不同之处同样也很重要，我会很有耐心的同步描述。</p><p>这篇文章主要是从指令的角度来阐述，只有在末尾花了少量篇幅描述了 C 语言实现 VM 的细节。但是在文章开始之前，我想先提供一些实现 VM 的主要代码文件：</p><ul><li><a href=https://github.com/php/php-src/blob/master/Zend/zend_vm_def.h target=_blank rel="noopener noreferrer">zend_vm_def.h<i class="fas fa-external-link-square-alt ms-1"></i></a>: VM 定义文件</li><li><a href=https://github.com/php/php-src/blob/master/Zend/zend_vm_execute.h target=_blank rel="noopener noreferrer">zend_vm_execute.h<i class="fas fa-external-link-square-alt ms-1"></i></a>: 生成的 VM</li><li><a href=https://github.com/php/php-src/blob/master/Zend/zend_vm_gen.php target=_blank rel="noopener noreferrer">zend_vm_gen.php<i class="fas fa-external-link-square-alt ms-1"></i></a>: VM 生成脚本</li><li><a href=https://github.com/php/php-src/blob/master/Zend/zend_execute.c target=_blank rel="noopener noreferrer">zend_execute.c<i class="fas fa-external-link-square-alt ms-1"></i></a>: 大多数直接支持的代码</li></ul><h2 id=opcodes data-numberify>Opcodes<a class="anchor ms-1 d-none" href=#opcodes>#</a></h2><p>首先我们来聊聊 opcode。&ldquo;Opcode"是用来表示整个 VM 指令集（包括操作数）的，但是也可能仅仅就是指“真实的”操作码，这些操作码是一个很小的整数用来区分不同的指令类型。其具体的含义需要结合代码的上下文才能清楚。在程式码中，指令通常被称作"oplines&rdquo;。</p><p>下面是<code>zend_op</code>的结构</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>_zend_op</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>handler</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>znode_op</span> <span class=n>op1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>znode_op</span> <span class=n>op2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>znode_op</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>extended_value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>lineno</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>zend_uchar</span> <span class=n>opcode</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>zend_uchar</span> <span class=n>op1_type</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>zend_uchar</span> <span class=n>op2_type</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>zend_uchar</span> <span class=n>result_type</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>由此看来，opcodes 本质上就是一个“三地址码”格式的指令。有一个<code>opcode</code>代表指令的类型，有两个输入操作数<code>op1</code>和<code>op2</code>和一个输出操作数<code>result</code>。</p><p>并不是所有的指令都一定会使用全部的操作数。<code>ADD</code>指令（表示<code>+</code>操作符）会使用全部的操作数，<code>BOOL_NOT</code>指令（表示<code>!</code>操作符）只会用到<code>op1</code>和<code>result</code>。而<code>ECHO</code>
指令只会用到<code>op1</code>。还有一些指令既可能用到也可能用不到操作数，例如<code>DO_FCALL</code>有没有结果操作数都是有可能的，这取决于调用的函数是否有返回值。还有一些指令
可能会需要使用超过２个输入操作数，在这种情况下，它们将使用一个虚设的指令(<code>OP_DATA</code>)来传递额外的操作数。</p><p>紧跟着三个标准操作数后面的是一个额外的数值字段<code>extended_value</code>，它可以用来存放一些额外的指令标识，例如<code>CAST</code>指令，它需要保存将要转换的目标类型。</p><p>每一个操作数都有一个类型，分别存放在<code>op1_type</code>，<code>op2_type</code>，<code>result_type</code>当中。所有可能的类型有<code>IS_UNUSED</code>，<code>IS_CONST</code>，<code>IS_TMPVAR</code>，<code>IS_VAR</code>，<code>IS_CV</code>。
后三种类型用来指明变量操作数类型（有三种不同类型的 VM 变量），<code>IS_COUNT</code>表示一个常量操作数，而<code>IS_UNUSED</code>表示一个操作数是否被使用，或者操作数被用作一个 32 位数字类型（一个立即数，汇编中的术语）。例如 Jump 指令会将跳转的目标存放在一个<code>UNUSED</code>操作数中。</p><h2 id=输出-opcode data-numberify>输出 Opcode<a class="anchor ms-1 d-none" href=#输出-opcode>#</a></h2><p>接下来，我将会频繁展示一些 php 示例代码生成的 opcode 序列。目前有三种方式来打印出 opcode.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># Opcache, since PHP 7.1</span>
</span></span><span class=line><span class=cl>php -d opcache.opt_debug_level<span class=o>=</span>0x10000 test.php
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># phpdbg, since PHP 5.6</span>
</span></span><span class=line><span class=cl>phpdbg -p* test.php
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># vld, third-party extension</span>
</span></span><span class=line><span class=cl>php -d vld.active<span class=o>=</span><span class=m>1</span> test.php
</span></span></code></pre></div><p>上述方法中，opcache 输出的 opcode 质量更高。本文使用的 opcode 就是基于 opcache 输出的，其中一些 opcode 做了少量的语法的调整。魔法数字<code>0x10000</code>表示“优化前”，使用这个级别输出的是 php 编译器直接生成的 opcodes，而<code>0x20000</code>会输出优化过的 opcodes。Opcache 还能生成更多的信息，例如使用<code>0x40000</code>将会生成<code>CFG</code>(Control flow graph)，使用<code>0x200000</code>将会生成类型和范围推断的 SSA form(Static single assignment form，静态单赋值形式，常见于编译器原理)，但是这些已经超出了本文的探讨范围，所以最原始的 opcodes 才最符合我们的需求。</p><h2 id=变量类型 data-numberify>变量类型<a class="anchor ms-1 d-none" href=#变量类型>#</a></h2><p>可能在处理 PHP 虚拟机时要理解的最重要的一点就是 VM 使用了三种不同的变量类型。在 PHP5 中，<code>TMPVAR</code>，<code>VAR</code>和<code>CV</code>在虚拟机栈中不仅含义上有着明显的区别，连访问方式都不一样。但是到了 PHP7，公用一套存储机制使得它们变得非常相似。而然，它们所包含的数值和它们的语义上却存在重要的差异。</p><p><code>CV</code>是<code>compiled variable</code>的简写，代表的是真正的 PHP 变量。如果一个函数使用变量<code>$a</code>，就会使用<code>CV</code>类型的操作数表示<code>$a</code>。CVs 也可以有<code>UNDEF</code>类型，用以表示没有定义的变量。如果一个指令使用了 UNDEF CV，（在大多数情况下）会抛出一个熟悉的“undefined variable”警告。在 function entry 中，所有非参数 CVs 都会被初始化为 UNDEF。</p><p>CVs 不是被指令消费的，例如一个指令<code>ADD $a, $b</code>不会销毁存放在 CVs<code>$a</code>，<code>$b</code>中的数据，取而代之的是 CVs 在作用域结束的时候一起被销毁。也就是说，所有 CVs“存活”于
整个函数期间，这里的“存活”指的是其包含一个合法的数值（并非存活于数据流层面）。</p><p><code>TMPVARs</code>和<code>VARs</code>从某种意义上说其实就是虚拟机的临时变量。他们通常产生于作为一些操作的结果操作数。例如<code>$a = $b + $c + $d</code>将会生成一个如下所示的 opcode 的序列</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=nx>T0</span> <span class=o>=</span> <span class=nx>ADD</span> <span class=nv>$b</span><span class=p>,</span> <span class=nv>$c</span>
</span></span><span class=line><span class=cl><span class=nx>T1</span> <span class=o>=</span> <span class=nx>ADD</span> <span class=nx>t0</span><span class=p>,</span> <span class=nv>$d</span>
</span></span><span class=line><span class=cl><span class=nx>ASSIGN</span> <span class=nv>$a</span><span class=p>,</span> <span class=nx>T1</span>
</span></span></code></pre></div><p><code>TMP/VARs</code>总是在使用前被定义，所以不能持有<code>UNDEF</code>类型。不同于<code>CVs</code>，它们的值是被指令直接消费的。在上面的例子中，第二个 ADD 会销毁 T0 操作数中的值，至此以后
T0 将不能再被使用。同样的，ASSIGN 将会消费 T1 中的数值，然后并释放掉。</p><p>上述表明<code>TMP/VARs</code>通常都很短命。在多数情况下，临时变量仅仅存活于单个指令空间。在这个短暂的存活间隔之外，临时变量的值就是垃圾数据。
那么 TMP 和 VAR 的区别到底是什么呢？其实区别并不多，其差异继承自 PHP5，在 PHP5 中，TMPs 是存放在虚拟机栈中的，VMRs 是存放在堆中的。而 PHP7 中的所有变量都是存放在栈
当中的。因此，至今 TMPs 和 VARs 的主要区别是只有后者允许包含<code>REFERENCEs</code>。此外，VARSs 也能够存放两种特殊类型的数据，一个是 namely class entries，另一个是 INDIRECT values。后者也通常被用来处理非普通的赋值操作。</p><p>下表总结了三种数据类型的主要区别:</p><pre tabindex=0><code>       | UNDEF | REF | INDIRECT | Consumed? | Named? |
-------|-------|-----|----------|-----------|--------|
CV     |  yes  | yes |    no    |     no    |  yes   |
TMPVAR |   no  |  no |    no    |    yes    |   no   |
VAR    |   no  | yes |   yes    |    yes    |   no   |
</code></pre><h2 id=op-arrays data-numberify>Op arrays<a class="anchor ms-1 d-none" href=#op-arrays>#</a></h2><p>所有的 PHP 函数都代表了一个拥有相同<code>zend_function</code>header 的结构体。&ldquo;Function"在这里被理解的很宽泛，包括了真实函数的所有一切，从方法到独立的伪代码，到 evel
代码。
用户层的函数使用<code>zend_op_array</code>结构体。它有超过 30 个成员，所以这里从一个简化版开始研究：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>_zend_op_array</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Common zend_function header here */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* ... */</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>last</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>zend_op</span> <span class=o>*</span><span class=n>opcodes</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>last_var</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>T</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>zend_string</span> <span class=o>**</span><span class=n>vars</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* ... */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>last_literal</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>zval</span> <span class=o>*</span><span class=n>literals</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* ... */</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>这里边最重要的部分当然是<code>opcodes</code>了，它是一个 opcodes（指令）的数组。<code>last</code>表示 opcode 数组中元素的个数。说到这里你也许会感到非常的疑惑，<code>last</code>看起来像是
最后一个 opcode 的索引，然而它真的是 opcodes 的个数（比最后一个 opcode 的索引值大１）。同样的规则适用于其他以<code>last_</code>开头的字段。</p><p><code>last_var</code>是 CVs 的数量，<code>T</code>表示 TMPs 和 VARs 的数量（在大多数情况下，我们并没有对它们做明显的区分）。<code>vars</code>是一个 CVs 的名字数组。<code>literals</code>是用于存放代码中字面量的值的数组，这个数组会被<code>CONST</code>操作数引用。根据 ABI(application binary interface)，每一个<code>CONST</code>操作数要么存储一个字面量表的指针，要么存储一个相对于字面量表的起始位置的偏移量。</p><p>关于 op array 结构还有很多内容，将会在后边描述。</p><h2 id=栈帧布局 data-numberify>栈帧布局<a class="anchor ms-1 d-none" href=#栈帧布局>#</a></h2><p>不考虑一些 executor globals(EG)，所有的执行状态都是存储在虚拟机栈中的。VM 栈每页 256KB，页与页通过链表连接起来。在每个函数调用中，会在 VM 栈中分配一个新的栈帧，它们的布局如下：</p><pre tabindex=0><code>+----------------------------------------+
| zend_execute_data                      |
+----------------------------------------+
| VAR[0]                =         ARG[1] | arguments
| ...                                    |
| VAR[num_args-1]       =         ARG[N] |
| VAR[num_args]         =   CV[num_args] | remaining CVs
| ...                                    |
| VAR[last_var-1]       = CV[last_var-1] |
| VAR[last_var]         =         TMP[0] | TMP/VARs
| ...                                    |
| VAR[last_var+T-1]     =         TMP[T] |
| ARG[N+1] (extra_args)                  | extra arguments
| ...                                    |
+----------------------------------------+
</code></pre><p>栈帧以一个<code>zend_execute_data</code>结构开始，后边跟着一个存放变量的数组。数组中的每个位置存放的数据都是一样的（简单的 zval 数值），但是它们却有着不同的用途。第一个<code>last_var</code>之前存放的都是 CVs，第一个<code>num_args</code>之前存放的是函数参数。紧挨着 CV 后边的是<code>T</code>槽，用以存放 TMP/VARs。最后，如果有一些“额外的”参数的话会存放在栈帧的末尾，它们通常用来处理<code>func_get_args()</code>。</p><p>CV 和 TMP/VAR 操作数在指令中会被编码成相对于栈帧起始位置的偏移量，因此访问一个确定的变量将变得非常容易，仅仅访问<code>execute_data</code>中的偏移位置。下面是<code>zend_execute_data</code>的结构：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>_zend_execute_data</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>zend_op</span>       <span class=o>*</span><span class=n>opline</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>zend_execute_data</span>   <span class=o>*</span><span class=n>call</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>zval</span>                <span class=o>*</span><span class=n>return_value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>zend_function</span>       <span class=o>*</span><span class=n>func</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>zval</span>                 <span class=n>This</span><span class=p>;</span>             <span class=cm>/* this + call_info + num_args    */</span>
</span></span><span class=line><span class=cl>    <span class=n>zend_class_entry</span>    <span class=o>*</span><span class=n>called_scope</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>zend_execute_data</span>   <span class=o>*</span><span class=n>prev_execute_data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>zend_array</span>          <span class=o>*</span><span class=n>symbol_table</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span>               <span class=o>**</span><span class=n>run_time_cache</span><span class=p>;</span>   <span class=cm>/* cache op_array-&gt;run_time_cache */</span>
</span></span><span class=line><span class=cl>    <span class=n>zval</span>                <span class=o>*</span><span class=n>literals</span><span class=p>;</span>         <span class=cm>/* cache op_array-&gt;literals       */</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>其中最重要的是，这个结构体中包含了一个<code>opline</code>字段，它代表当前执行的指令，<code>func</code>是当前执行的函数。此外：</p><ul><li><code>return_value</code>是一个指向存放返回值变量的指针</li><li><code>This</code>就是<code>$this</code>对象，但是同时也编码了函数参数个数和一些调用的元数据标记存放在此 zval 中没有使用的空间里</li><li><code>called_scope</code>是<code>static::</code>指向的 PHP 代码作用域</li><li><code>prev_execute_data</code>指向前一个栈帧，以便当前函数执行完毕后返回到外层调用</li><li><code>symbol_table</code>是一个典型的没有使用的符号表，用于某些疯狂的人实际使用中会用到变量或相关特性</li><li><code>run_time_cache</code>缓存 op array 运行时缓存，用来防止指针通过间接寻址的方式来访问当前结构</li><li><code>literals</code>缓存 op array 字面量表，目的同上</li></ul><h2 id=函数调用function-call data-numberify>函数调用(Function call)<a class="anchor ms-1 d-none" href=#函数调用function-call>#</a></h2><p>在介绍 execute_data 结构的时候，我跳过了<code>call</code>字段，因为在介绍它之前还需要先了解函数调用是如何工作的。</p><p>所有调用都使用同一指令序列上的变量。一个<code>var_dump($1, $b)</code>在全局作用域中会被编译成下面的指令序列：</p><pre tabindex=0><code>INIT_FCALL (2 args) &#34;var_dump&#34;
SEND_VAR $a
SEND_VAR $b
V0 = DO_ICALL   # or just DO_ICALL if retval unused
</code></pre><p>根据不同的调用类型，总共有８种不同类型的 INIT 指令。<code>INIT_FCALL</code>用于调用后立即释放的函数调用。同理根据不同的参数类型和函数类型，共有 10 种不同的 SEND 指令。DO_CALL 指令只有区区 4 种，ICALL 用于调用内部函数。</p><p>尽管特定的指令不同，但是整个流程却一直如此：INIT,SEND,DO。现在调用序列需要解决的主要问题是嵌套调用，它们编译后的指令形如以下：</p><pre tabindex=0><code># var_dump(foo($a), bar($b))
INIT_FCALL (2 args) &#34;var_dump&#34;
    INIT_FCALL (1 arg) &#34;foo&#34;
    SEND_VAR $a
    V0 = DO_UCALL
SEND_VAR V0
    INIT_FCALL (1 arg) &#34;bar&#34;
    SEND_VAR $b
    V1 = DO_UCALL
SEND_VAR V1
V2 = DO_ICALL
</code></pre><p>我使用缩进来区分哪个指令代表哪个调用。</p><p>INIT opcode 将一个调用栈帧 push 到栈中，栈帧中包含了充足的空间来存放函数中的所有变量和已知数量的参数(如果涉及到参数解包，我们可能会得到更多参数)。这个调用栈帧伴随着函数调用被初始化，<code>$this</code>和<code>called_scope</code>（在上面情况下都是 NULL，因为它们是调用后就释放的函数）。</p><p>一个新的栈帧的指针被存放在<code>execute_data->call</code>中，其中<code>execute_data</code>是调用函数的栈帧。下面我们将分析一个形如<code>EX(call)</code>的访问形式。特别地，新栈帧的<code>prev_execute_data</code>会被设置成旧的<code>EX(call)</code>。例如，对于<code>foo</code>的<code>INIT_FCALL</code>会把其<code>prev_execute_data</code>设置成<code>var_dump</code>的栈帧，如此以来，prev_execute_data 在这种形式下构成了一个未完成调用的链表，从而形成了一个回溯链。</p><p>SEND opcode 接下来将参数 push 到<code>EX(call)</code>的变量槽中。在这种情况下，参数都是连续的，而且也可能超出参数预设的存放区域到达 CVs 或 TMPs 区域，但是它们会在后边被修复。</p><p>接着 DO_FCALL 才是进行真正的调用。此时<code>EX(call)</code>变成当前执行的函数而<code>prev_execute_data</code>则重新指向外层调用函数。除此之外，调用过程也取决于被调用函数的类型。内部函数只需要执行一个 handler 函数，而用户层函数需要先初始化栈帧。初始化过程包含了对参数栈的修复。PHP 允许向一个函数传递的参数超过预期参数个数。然而，只有被声明过的参数才会对应到 CVs，超出的参数将会被写到记忆体中其他 CVs 和 TMPs 的位置，但是像这样的参数随后会被移动到 TMPs 后面的位置，最终的结果就是函数参数位于两个不连续的记忆体区块中。</p><p>这里需要清楚的是，用户端的函数调用不涉及到虚拟机级别的递归。它们只是从一个 execute_data 切换到另一个，但虚拟机在线性循环中继续运行。虚拟机级别的递归仅仅出现在内部函数中包含用户端回调的时候（例如：通过<code>array_map</code>）。这就是为什么在 PHP 中无限递归通常会导致内存限制或 OOM 错误，但是通过回调函数或魔术方法可能会引发栈溢出。</p><h2 id=传送参数argument-sending data-numberify>传送参数(Argument sending)<a class="anchor ms-1 d-none" href=#传送参数argument-sending>#</a></h2><p>PHP 使用大量不同的参数传递 opcode，多亏了那些不幸的名字，让我们对它们的区别感到困惑。</p><p>SEND_VAL 和 SEND_VAR 是最简单的两个，它们用来传递按值传递的参数。SEND_VAL 用于 CONST 和 TMP 操作数，而 SEND_VAR 用于 VARs 和 CVs 的传递。</p><p>相反地，SEND_REF 用来处理按引用传递的参数。因为只有变量才能按引用传递，所以此 opcode 只能接收 VARs 和 CVs。</p><p>SEND_VAL_EX 和 SEND_VAR_EX 是 SEND_VAL 和 SEND_VAR 的变种，用于不能确定参数到底是按值传递还是按引用传递的情况。这两个 opcode 会根据 arginfo 来检查参数的类型然后进行相应操作。大多数情况下，arginfo 结构并没有使用，取而代之的是函数结构中的一个压缩的位向量。</p><p>接着是 SEND_VAR_NO_REF_EX。不要视图从它的名字里去获取什么信息，因为它完全是一个谎言。这个 opcode 用于当传递一个不是真实变量，但是会返回一个不确定参数类型的 VAR 的时候。两个典型的例子就是将一个函数调用的结果作为参数传递，或者将赋值的结果作为参数传递。这些情况下需要一个单独的 opcode 主要有两个原因：其一，如果你试图将类似于赋值操作的表达式按引用传递，它会生成熟悉的"Only variables should be passed by reference"警告（如果使用 SEND_VAR_EX 的话，就会悄悄的允许）。其二，这个 opcode 可以处理我们想把一个返回引用类型数据类型函数的返回值传递给按引用传递的参数的情况(它不会抛出任何信息)。这个 opcode 的一个变种 SEND_VAR_NO_REF 是一个特殊的用来处理我们明确知道参数是一个引用类型的情况。</p><p>SEND_UNPACK 和 SEND_ARRAY 这两个 opcodes 分别用来处理参数解包和内敛<code>call_user_func_array</code>调用。它们都能够将数组中的元素 push 到参数栈中，但是在处理细节上有一些不同（例如：unpacking 支持遍历，而 call_user_func_array 不支持）。如果 unpacking/cufa 被使用，就有可能适当地去扩展栈帧的大小。通常，可以通过移动栈帧顶部指针来扩展。然而，如果达到了栈 page 的边界，就需要分配一个新的 page，然后将整个调用栈帧拷贝到新的 page 当中（我们不能处理跨 page 的栈帧）</p><p>最后一个 opcode 是 SEND_USER，它是用于内敛函数<code>call_user_func</code>调用。</p><p>至此我们还没有讨论过不同的变量查询模式，这里是一个不错的地方来介绍 FUNC_ARG 查询模式。思考形如<code>func($a[0][1][2])</code>的调用，我们不知道在编译时期传入的参数是按值传递还是按引用传递。这两个情况下的行为是不同的。如果是按值传递，而且<code>$a</code>之前为空，那么会产生一些"undefined index"警告。如果按引用传递，那么会悄悄的初始化嵌套数组。FUNC_ARG 访问模式通过检查当前的<code>EX(call)</code>函数的 arginfo 来动态选择两种行为(R 或 W)中的一种，对于上面的例子，opcode 序列如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=nx>INIT_FCALL_BY_NAME</span> <span class=s2>&#34;func&#34;</span>
</span></span><span class=line><span class=cl><span class=nx>V0</span> <span class=o>=</span> <span class=nx>FETCH_DIM_FUNC_ARG</span> <span class=p>(</span><span class=nx>arg</span> <span class=mi>1</span><span class=p>)</span> <span class=nv>$a</span><span class=p>,</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=nx>V1</span> <span class=o>=</span> <span class=nx>FETCH_DIM_FUNC_ARG</span> <span class=p>(</span><span class=nx>arg</span> <span class=mi>1</span><span class=p>)</span> <span class=nx>V0</span><span class=p>,</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=nx>V2</span> <span class=o>=</span> <span class=nx>FETCH_DIM_FUNC_ARG</span> <span class=p>(</span><span class=nx>arg</span> <span class=mi>1</span><span class=p>)</span> <span class=nx>V1</span><span class=p>,</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=nx>SEND_VAR_EX</span> <span class=nx>V2</span>
</span></span><span class=line><span class=cl><span class=nx>DO_FCALL</span>
</span></span></code></pre></div><h2 id=查询模式fetch-modes data-numberify>查询模式(Fetch modes)<a class="anchor ms-1 d-none" href=#查询模式fetch-modes>#</a></h2><p>PHP 虚拟机有四类用于查询的 opcodes:</p><pre tabindex=0><code>FETCH_*             // $_GET, $$var
FETCH_DIM_*         // $arr[0]
FETCH_OBJ_*         // $obj-&gt;prop
FETCH_STATIC_PROP_* // A::$prop
</code></pre><p>如注释中说明的，基础的<code>FETCH_*</code>用来访问变量变量和超全局变量。这些 fetch opcodes 每一类又分 6 种：</p><pre tabindex=0><code>_R
_RW
_W
_IS
_UNSET
_FUNC_ARG
</code></pre><p>我们已经知道<code>_FUNC_ARG</code>会根据函数是按值传递还是按引用传递来选择<code>_R</code>和<code>_W</code>模式。下面我们来举一些出现不同查询模式的例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=c1>// $arr[0];
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>V2</span> <span class=o>=</span> <span class=nx>FETCH_DIM_R</span> <span class=nv>$arr</span> <span class=nx>int</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>FREE</span> <span class=nx>V2</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// $arr[0] = $val;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>ASSIGN_DIM</span> <span class=nv>$arr</span> <span class=nx>int</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>OP_DATA</span> <span class=nv>$val</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// $arr[0] += 1;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>ASSIGN_ADD</span> <span class=p>(</span><span class=nx>dim</span><span class=p>)</span> <span class=nv>$arr</span> <span class=nx>int</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>OP_DATA</span> <span class=nx>int</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// isset($arr[0]);
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>T5</span> <span class=o>=</span> <span class=nx>ISSET_ISEMPTY_DIM_OBJ</span> <span class=p>(</span><span class=nx>isset</span><span class=p>)</span> <span class=nv>$arr</span> <span class=nx>int</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>FREE</span> <span class=nx>T5</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// unset($arr[0]);
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>UNSET_DIM</span> <span class=nv>$arr</span> <span class=nx>int</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span></code></pre></div><p>不幸的是，实际上产生的唯一查询就是<code>FETCH_DIM_R</code>：其他的操作都是通过特定的 opcodes 处理的。注意到<code>ASSIGN_DIM</code>和<code>ASSIGN_ADD</code>都使用一个额外的<code>OP_DATA</code>，因为它们都需要超过 2 个操作数。之所以用到像<code>ASSIGN_DIM</code>这样的特殊 opcodes 而没有用到<code>FETCH_DIM_W</code>+<code>ASSIGN</code>的原因是这些操作可能会被覆盖，例如，通过一个对象实现<code>ArrayAccess::offsetSet()</code>的方式构成<code>ASSIGN_DIM</code>的情形。为了真正产生不同的 fetch types，我们需要增加嵌套层级：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=c1>// $arr[0][1];
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>V2</span> <span class=o>=</span> <span class=nx>FETCH_DIM_R</span> <span class=nv>$arr</span> <span class=nx>int</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>V3</span> <span class=o>=</span> <span class=nx>FETCH_DIM_R</span> <span class=nx>V2</span> <span class=nx>int</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>FREE</span> <span class=nx>V3</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// $arr[0][1] = $val;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>V4</span> <span class=o>=</span> <span class=nx>FETCH_DIM_W</span> <span class=nv>$arr</span> <span class=nx>int</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>ASSIGN_DIM</span> <span class=nx>V4</span> <span class=nx>int</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>OP_DATA</span> <span class=nv>$val</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// $arr[0][1] += 1;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>V6</span> <span class=o>=</span> <span class=nx>FETCH_DIM_RW</span> <span class=nv>$arr</span> <span class=nx>int</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>ASSIGN_ADD</span> <span class=p>(</span><span class=nx>dim</span><span class=p>)</span> <span class=nx>V6</span> <span class=nx>int</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>OP_DATA</span> <span class=nx>int</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// isset($arr[0][1]);
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>V8</span> <span class=o>=</span> <span class=nx>FETCH_DIM_IS</span> <span class=nv>$arr</span> <span class=nx>int</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>T9</span> <span class=o>=</span> <span class=nx>ISSET_ISEMPTY_DIM_OBJ</span> <span class=p>(</span><span class=nx>isset</span><span class=p>)</span> <span class=nx>V8</span> <span class=nx>int</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>FREE</span> <span class=nx>T9</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// unset($arr[0][1]);
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>V10</span> <span class=o>=</span> <span class=nx>FETCH_DIM_UNSET</span> <span class=nv>$arr</span> <span class=nx>int</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>UNSET_DIM</span> <span class=nx>V10</span> <span class=nx>int</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span></code></pre></div><p>这里我们看到，最外层的访问通过特定的 opcodes，而嵌套的索引则使用特定模式的 FETCHes。访问不存在的索引是否产生"undefined offset"警告和是否会对查询的数据执行写操作，对于不同的 fetch modes 来说也是不同的：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl>      <span class=o>|</span> <span class=nx>Notice</span><span class=o>?</span> <span class=o>|</span> <span class=nx>Write</span><span class=o>?</span>
</span></span><span class=line><span class=cl><span class=nx>R</span>     <span class=o>|</span>  <span class=nx>yes</span>    <span class=o>|</span>  <span class=nx>no</span>
</span></span><span class=line><span class=cl><span class=nx>W</span>     <span class=o>|</span>  <span class=nx>no</span>     <span class=o>|</span>  <span class=nx>yes</span>
</span></span><span class=line><span class=cl><span class=nx>RW</span>    <span class=o>|</span>  <span class=nx>yes</span>    <span class=o>|</span>  <span class=nx>yes</span>
</span></span><span class=line><span class=cl><span class=nx>IS</span>    <span class=o>|</span>  <span class=nx>no</span>     <span class=o>|</span>  <span class=nx>no</span>
</span></span><span class=line><span class=cl><span class=nx>UNSET</span> <span class=o>|</span>  <span class=nx>no</span>     <span class=o>|</span>  <span class=nx>yes</span><span class=o>-</span><span class=nx>ish</span>
</span></span></code></pre></div><p>UNSET 的情况有点特殊，它只会对存在的索引值进行写操作，而跳过没有定义的部分。而一个普通的 write-fetch 操作会先初始化没有定义的变量。</p><h3 id=writes-and-memory-safety data-numberify>Writes and memory safety<a class="anchor ms-1 d-none" href=#writes-and-memory-safety>#</a></h3><p>写查询模式会返回包含一个普通 zval 或者一个指向另一个 zval 的 INDIRECT 指针的 VARs。当然，前面任何对该 zval 的改变都是不可见的，因为这个值只能通过虚拟机临时变量访问。尽管 PHP 禁止形如<code>[][0] = 42</code>这样的表达式，但是我们仍然需要处理类似于<code>call()[0] = 42</code>这种操作。这取决于<code>call()</code>是否返回一个数值还是一个数值的引用。</p><p>另个一个更加特殊的情形是查询返回一个 INDIRECT，其中包含的指向一个记忆体的指针被修改了，例如 hashtable 数组中一个确定的位置，不行的是，这样的指针是很脆弱的，很容易被失效：任何对于该数组并发写操作都可能触发 reallocation，留下一个迷途(dangling)指针，因此在创建 INDIRECT 值的地方和它被消费之间阻止用户代码执行是至关重要的。</p><p>考虑如下例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=nv>$arr</span><span class=p>[</span><span class=nx>a</span><span class=p>()][</span><span class=nx>b</span><span class=p>()]</span> <span class=o>=</span> <span class=nx>c</span><span class=p>();</span>
</span></span></code></pre></div><p>将会产生如下 opcode 序列：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=nx>INIT_FCALL_BY_NAME</span> <span class=p>(</span><span class=mi>0</span> <span class=nx>args</span><span class=p>)</span> <span class=s2>&#34;a&#34;</span>
</span></span><span class=line><span class=cl><span class=nx>V1</span> <span class=o>=</span> <span class=nx>DO_FCALL_BY_NAME</span>
</span></span><span class=line><span class=cl><span class=nx>INIT_FCALL_BY_NAME</span> <span class=p>(</span><span class=mi>0</span> <span class=nx>args</span><span class=p>)</span> <span class=s2>&#34;b&#34;</span>
</span></span><span class=line><span class=cl><span class=nx>V3</span> <span class=o>=</span> <span class=nx>DO_FCALL_BY_NAME</span>
</span></span><span class=line><span class=cl><span class=nx>INIT_FCALL_BY_NAME</span> <span class=p>(</span><span class=mi>0</span> <span class=nx>args</span><span class=p>)</span> <span class=s2>&#34;c&#34;</span>
</span></span><span class=line><span class=cl><span class=nx>V5</span> <span class=o>=</span> <span class=nx>DO_FCALL_BY_NAME</span>
</span></span><span class=line><span class=cl><span class=nx>V2</span> <span class=o>=</span> <span class=nx>FETCH_DIM_W</span> <span class=nv>$arr</span> <span class=nx>V1</span>
</span></span><span class=line><span class=cl><span class=nx>ASSIGN_DIM</span> <span class=nx>V2</span> <span class=nx>V3</span>
</span></span><span class=line><span class=cl><span class=nx>OP_DATA</span> <span class=nx>V5</span>
</span></span></code></pre></div><p>显然，上述 opcode 序列先是从左到右执行函数调用，然后才执行一些必要的写查询操作（我们称这里的 FETCH_DIM_W 操作是“延迟操作”）。这样能确保写查询操作和消费指令能够直接相邻。</p><p>再来思考另一个例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=nv>$arr</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=o>&amp;</span><span class=nv>$arr</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
</span></span></code></pre></div><p>这里有一个小问题：赋值语句两边都必须使用写查询操作。然而，如果我们先查询<code>$arr[0]</code>进行写操作，然后再对<code>$arr[1]</code>进行写操作，后者将会使前者失效。这个问题的解决如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=nx>v2</span> <span class=o>=</span> <span class=nx>FETCH_DIM_W</span> <span class=nv>$arr</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=nx>v3</span> <span class=o>=</span> <span class=nx>MAKE_REF</span> <span class=nx>V2</span>
</span></span><span class=line><span class=cl><span class=nx>V1</span> <span class=o>=</span> <span class=nx>FETCH_DIM_W</span> <span class=nv>$arr</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=nx>ASSIGN_REF</span> <span class=nx>V1</span> <span class=nx>V3</span>
</span></span></code></pre></div><p>这里首先对<code>$arr[1]</code>进行写查询操作，然后通过使用<code>MAKE_REF</code>转换成一个引用，转换的结果不再是一个 INDIRECT，也不会遵循失效的规则，这样的话，查询<code>$arr[0]</code>就变得很安全。</p><h2 id=异常处理exception-handling data-numberify>异常处理(Exception handling)<a class="anchor ms-1 d-none" href=#异常处理exception-handling>#</a></h2><p>异常是万恶之源。</p><p>异常是通过向<code>EG(exception)</code>中写入异常而产生的，这里<code>EG</code>代表的是执行全局变量(executor globals)。在 C 语言中抛出异常并不会导致堆栈展开，相反，错误信息会通过返回失败值或检查<code>EG(exception)</code>向上传播。异常只有当控制权重新进入到虚拟机代码中的时候才会被处理。几乎所有的 VM 指令都能够在某些情形下直接或间接产生异常。例如一些"undefined variable"警告可能会产生异常，如果使用了自定义的错误处理的话。我们想避免在每一个 VM 指令执行后都去检查<code>EG(exception)</code>是否被设置，这里用到了一个小技巧：</p><p>当异常被抛出的时候，当前的执行数据中的 opline 会被替换成一个虚设的<code>HANDLE_EXCEPTION</code>opline（这显然不会改变 op array，它仅仅是一个直接的指针）。搜集 exception 处的 opline 会回到<code>EG(opline_before_exception)</code>。也就是说，当控制权返回到虚拟机调度循环中的时候，<code>HANDLE_EXCEPTION</code>opline 会被执行。这种模式下有一个小问题：存放在 execute data 中的 opline 必须是当前执行的 opline（否则的话 opline_before_exception 就是错的），其次虚拟机使用 execute data 中的 opline 来继续执行（否则 HANDLE_EXCEPTION 将不会被执行）。</p><p>尽管这些条件看起来不那么重要，其实不然。原因就是虚拟机可能因为存储在 execute data 中的变量跟 opline 不同步而工作在不同的 opline。在 PHP7 之前，只有少数 GOTO 和 SWITCH 可能导致上述情况，而在 PHP7 中，这是操作的默认模式：如果编译器支持的话，opline 被存放在全局寄存器中。</p><p>在执行一些操作之前可能会抛出异常，本地 opline 必须被写回到 execute data（SAVE_OPLINE 操作）。类似的，潜在的异常抛出之后，本地 opline 必须从 execute data 中移出（通常是一个 CHECK_EXCEPTION 操作）。</p><p>现在我们知道了当一个异常抛出后，通过执行 HANDLE_EXCEPTION opcode 的机制来处理，但是它到底做了些什么呢？首先，它会确定异常是否在一个 try 代码块中抛出。为此，op array 包含了一个数组来跟踪 opline 相对于 try,catche,和 finally 代码块的偏移。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>_zend_try_catch_element</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>uint32_t</span> <span class=n>try_op</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>uint32_t</span> <span class=n>catch_op</span><span class=p>;</span>  <span class=cm>/* ketchup! */</span>
</span></span><span class=line><span class=cl>	<span class=kt>uint32_t</span> <span class=n>finally_op</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>uint32_t</span> <span class=n>finally_end</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>zend_try_catch_element</span><span class=p>;</span>
</span></span></code></pre></div><p>我们假设 finally 代码块不存在，因为它是一个完全不同的兔子洞(rabbit hole)。假如我们确实在一个 try 代码块中，VM 需要清理从开始抛出异常之后 try 代码块结束之前的所有的未完成的操作。这个操作会释放栈帧和相关正在执使用的数据，同时也会释放活跃状态的临时变量。大多数临时变量都是短命的，因为消费指令通常紧跟产生临时变量指令之后。然而可能会有临时变量生存期跨越多个指令的时候，潜在的异常被抛出：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=c1># (array)[] + throwing()
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>L0</span><span class=o>:</span>   <span class=nx>T0</span> <span class=o>=</span> <span class=nx>CAST</span> <span class=p>(</span><span class=k>array</span><span class=p>)</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl><span class=nx>L1</span><span class=o>:</span>   <span class=nx>INIT_FCALL</span> <span class=p>(</span><span class=mi>0</span> <span class=nx>args</span><span class=p>)</span> <span class=s2>&#34;throwing&#34;</span>
</span></span><span class=line><span class=cl><span class=nx>L2</span><span class=o>:</span>   <span class=nx>V1</span> <span class=o>=</span> <span class=nx>DO_FCALL</span>
</span></span><span class=line><span class=cl><span class=nx>L3</span><span class=o>:</span>   <span class=nx>T2</span> <span class=o>=</span> <span class=nx>ADD</span> <span class=nx>T0</span><span class=p>,</span> <span class=nx>V1</span>
</span></span></code></pre></div><p>在上面的例子中，变量<code>T0</code>存活于指令<code>L1</code>和<code>L2</code>，在这种情况下，如果抛出异常，就需要将其释放。有一种典型的情况会产生长命的临时变量，那就是迭代中的变量，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=c1># foreach ($array as $value) throw $ex;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>L0</span><span class=o>:</span>   <span class=nx>V0</span> <span class=o>=</span> <span class=nx>FE_RESET_R</span> <span class=nv>$array</span><span class=p>,</span> <span class=o>-&gt;</span><span class=na>L4</span>
</span></span><span class=line><span class=cl><span class=nx>L1</span><span class=o>:</span>   <span class=nx>FE_FETCH_R</span> <span class=nx>V0</span><span class=p>,</span> <span class=nv>$value</span><span class=p>,</span> <span class=o>-&gt;</span><span class=na>L4</span>
</span></span><span class=line><span class=cl><span class=nx>L2</span><span class=o>:</span>   <span class=k>THROW</span> <span class=nv>$ex</span>
</span></span><span class=line><span class=cl><span class=nx>L3</span><span class=o>:</span>   <span class=nx>JMP</span> <span class=o>-&gt;</span><span class=na>L1</span>
</span></span><span class=line><span class=cl><span class=nx>L4</span><span class=o>:</span>   <span class=nx>FE_FREE</span> <span class=nx>V0</span>
</span></span></code></pre></div><p>这里有一个"loop variable&rdquo; <code>V0</code>，从<code>L1</code>一直到<code>L3</code>（通常会延续整个迭代体内）。临时变量的生命周期使用如下的结构存放在 op array 中：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>_zend_live_range</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>var</span><span class=p>;</span> <span class=cm>/* low bits are used for variable type (ZEND_LIVE_* macros) */</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>start</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>end</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>zend_live_range</span><span class=p>;</span>
</span></span></code></pre></div><p>这里<code>var</code>是这个周期描述的（operand encoded）变量，<code>start</code>是起始 opline 偏移量（不包括自动生成的指令），<code>end</code>是终止 opline 的偏移（包括消费指令）。当然只有当临时变量没有被立即消费的时候才会有声明周期存在。</p><p><code>var</code>的低位被用来存放变量类型，它们可能是下面类型中的一种：</p><ul><li>ZEND_LIVE_TEMVAR：这是一个普通的变量。它里边包含了一个原始的 zval 值。释放这种变量的行为类似于<code>FREE</code>opcode</li><li>ZEND_LIVE_LOOP：这是一个 foreach 迭代变量，它包含的不仅仅是一个简单的 zval。它的释放对应的是<code>FE_FREE</code>opcode</li><li>ZEND_LIVE_SILENCE：这种类型的变量用于实现错误抑制操作。将一个旧的错误备份到一个临时变量中，如果后边有异常抛出，显然我们希望能够还原它。这种临时变量的释放对应的是<code>END_SILENCE</code></li><li>ZEND_LIVE_ROPE：这中类型的变量是用来连接一串字符串的，在这种情况下临时变量是一个位于栈中的存放<code>zend_string*</code>指针的固定大小的数组，从中移出的 strings 必须被释放。对应的释放操作大约是<code>END_ROPE</code>。</li></ul><p>有一个很滑稽的问题需要考虑，就是当临时变量的产生和消费操作之一抛出异常了，那么这个临时变量还需要被释放吗。例如下面的简单代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=nx>T2</span> <span class=o>=</span> <span class=nx>ADD</span> <span class=nx>T0</span><span class=p>,</span> <span class=nx>T1</span>
</span></span><span class=line><span class=cl><span class=nx>ASSIGN</span> <span class=nv>$v</span><span class=p>,</span> <span class=nx>T2</span>
</span></span></code></pre></div><p>如果<code>ADD</code>中抛出异常，临时变量<code>T2</code>会被自动释放吗，或者说<code>ADD</code>指令对它负责吗？同理如果<code>ASSIGN</code>抛出异常，<code>T2</code>会自动释放吗，或者<code>ASSIGN</code>必须考虑做这件事？后面的情况中，答案是很显然的：指令总是负责释放它的操作数，即使有异常抛出。而对于产生操作数的情况，就不那么寻常，因为在 PHP7.1 和 PHP7.2 中，答案是不一样的：在 PHP7.1 中指令负责在产生异常的时候释放临时变量，而在 PHP7.2 中，它们会被自动释放（而指令总是负责确保临时变量总是被移出栈）。这种改变的原因是这种方式能够实现许多基本指令（例如 ADD），它们通常的结构如下：</p><pre tabindex=0><code>1. 读取输入操作数
2. 执行操作，将结果写入result操作数中
3. 释放输入操作数（如果有必要的话）
</code></pre><p>这里是有问题的，因为 PHP 有一个很不幸的地方就是它不仅支持异常处理和析构，还支持在析构中抛出异常（这也正式令编译器工程师们感到恐惧的地方）。如此以来，在第三步中可以抛出异常，此时的结果已经移出栈，为了避免这种临界情况下造成内存泄露，释放结果操作数的责任就从指令转移给了异常处理机制。</p><p>一旦我们执行了那些清理操作，我们就能继续执行 catch 代码块。如果没有 catch（也没有 finally）的话，就会展开堆栈，也就是说销毁当前栈帧，并且在异常处理时给父栈帧一个快照（原文： i.e. destroy the current stack frame and give the parent frame a shot at handling the exception.）。</p><p>你已经欣赏到了异常处理的整个丑态，我将介绍另一个跟析构函数异常处理相关的部分，虽然这跟实践无关，但是我们仍然需要保证它处理的正确性。看下面代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=k>foreach</span> <span class=p>(</span><span class=k>new</span> <span class=nx>Dtor</span> <span class=k>as</span> <span class=nv>$value</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>echo</span> <span class=s2>&#34;Return&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=nx>Exception</span> <span class=nv>$e</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>echo</span> <span class=s2>&#34;Catch&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>想象一下，<code>Dtor</code>是一个可遍历的类，并且有一个可能抛出异常的析构函数。上面的代码将会得到下面的 opcode 序列：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=nx>L0</span><span class=o>:</span>   <span class=nx>V0</span> <span class=o>=</span> <span class=k>NEW</span> <span class=s1>&#39;Dtor&#39;</span><span class=p>,</span> <span class=o>-&gt;</span><span class=na>L2</span>
</span></span><span class=line><span class=cl><span class=nx>L1</span><span class=o>:</span>   <span class=nx>DO_FCALL</span>
</span></span><span class=line><span class=cl><span class=nx>L2</span><span class=o>:</span>   <span class=nx>V2</span> <span class=o>=</span> <span class=nx>FE_RESET_R</span> <span class=nx>V0</span><span class=p>,</span> <span class=o>-&gt;</span><span class=na>L11</span>
</span></span><span class=line><span class=cl><span class=nx>L3</span><span class=o>:</span>   <span class=nx>FE_FETCH_R</span> <span class=nx>V2</span><span class=p>,</span> <span class=nv>$value</span>
</span></span><span class=line><span class=cl><span class=nx>L4</span><span class=o>:</span>       <span class=k>ECHO</span> <span class=s1>&#39;Return&#39;</span>
</span></span><span class=line><span class=cl><span class=nx>L5</span><span class=o>:</span>       <span class=nx>FE_FREE</span> <span class=p>(</span><span class=nx>free</span> <span class=nx>on</span> <span class=k>return</span><span class=p>)</span> <span class=nx>V2</span>   <span class=c1># &lt;- return
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>L6</span><span class=o>:</span>       <span class=k>RETURN</span> <span class=k>null</span>                   <span class=c1># &lt;- return
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>L7</span><span class=o>:</span>       <span class=nx>JMP</span> <span class=o>-&gt;</span><span class=na>L10</span>
</span></span><span class=line><span class=cl><span class=nx>L8</span><span class=o>:</span>       <span class=k>CATCH</span> <span class=s1>&#39;Exception&#39;</span> <span class=nv>$e</span>
</span></span><span class=line><span class=cl><span class=nx>L9</span><span class=o>:</span>       <span class=k>ECHO</span> <span class=s1>&#39;Catch&#39;</span>
</span></span><span class=line><span class=cl><span class=nx>L10</span><span class=o>:</span>  <span class=nx>JMP</span> <span class=o>-&gt;</span><span class=na>L3</span>
</span></span><span class=line><span class=cl><span class=nx>L11</span><span class=o>:</span>  <span class=nx>FE_FREE</span> <span class=nx>V2</span>                        <span class=c1># &lt;- the duplicated instr
</span></span></span></code></pre></div><p>特别注意的是，&ldquo;return"被编译成了一个<code>FE_FREE</code>和一个<code>RETURN</code>。由于<code>Dtor</code>有一个能够抛出异常的析构函数，如果<code>FE_FREE</code>抛出异常会发生什么呢？通常情况下，我们可能会说这个指令在 try 代码块内部，所以会执行 catch。然而，这种情况下，循环变量已经被销毁了。catch 丢弃了异常然后尝试继续遍历一个已经破坏掉的循环变量。造成这种情况的原因是因为当抛出的<code>FE_FREE</code>在 try 代码块内部的时候，它其实是 L11 中<code>FE_RETURN</code>的一个拷贝，逻辑上来说，那才是异常真正发生的地方。这就是为什么中断产生的<code>FE_FREE</code>被注释为<code>FREE_ON_RETURN</code>，这样能指示异常处理机制将异常代码移动到最初的释放指令。因此上书代码不会执行 catch 代码块，而是会生成一个未捕获的异常。</p><h2 id=finally-handling data-numberify>Finally handling<a class="anchor ms-1 d-none" href=#finally-handling>#</a></h2><p>PHP 中 finally 的历史可谓是历经坎坷。在 PHP5.5 中首次实现 finally 特性，然而那实在是一个 bug 很多的实现。随后在 PHP5.6，7.0，7.1 每一次版本变更的时候，对 finally 的核心代码都进行了重构，每一次都修复了一些 bug，但是却没有达到完全正确的 finally 实现。看起来 PHP7.1 终于成功了。</p><p>当我在写这一节的时候，我惊奇的发现，透过当前 PHP 的实现和我的理解，finally 处理并不是那么复杂。而且，通过不同的迭代来实现从某种成都上使得问题变得更加简单而不是更复杂。下面我来告诉大家对问题的不充分理解是如何导致一个既复杂又 bug 居多的结果的（虽然，公平的说，PHP5 中实现的一部分复杂性是由于缺乏 AST（abstract syntax tree，抽象语法树）直接造成的）。</p><p>无论是正常的（例如：使用 return）还是不正常的（例如抛出异常）运行流程下，Finally 代码块总是运行在 try 代码块之后。有一些临界情况需要考虑，在描述实现原理之前我会做一些简单说明：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>throw</span> <span class=k>new</span> <span class=nx>Exception</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>finally</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>42</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>上面的代码会有怎样的执行结果呢？Finally 赢了，最后会返回 42。那么再思考下面的代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>24</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>finally</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>42</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>同样的还是 Finally 赢了，结果依然是 42，Finally 总是会赢。</p><p>PHP 会禁止跳出 finally 代码块。例如下面的代码是不允许的：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=k>foreach</span> <span class=p>(</span><span class=nv>$array</span> <span class=k>as</span> <span class=nv>$value</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=mi>42</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span> <span class=k>finally</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>上面代码中的"continue"会产生一个编译错误。但是需要理解的是，这种限制其实就是一种装饰，因为我们很容易使用一种众所周知的 catch 控制代理模式来绕过它：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=k>foreach</span> <span class=p>(</span><span class=nv>$array</span> <span class=k>as</span> <span class=nv>$value</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=mi>42</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span> <span class=k>finally</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>throw</span> <span class=k>new</span> <span class=nx>JumpException</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=nx>JumpException</span> <span class=nv>$e</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>唯一真正存在的限制就是我们不能跳到一个 finally 代码块中，例如使用一个 goto 语句从 finally 外部跳到一个 finally 内部的标签是不允许的。</p><p>通过一些简单的方式，我们可以看到 finally 是如何工作的。它的实现上是使用了两个 opcodes，<code>FAST_CALL</code>和<code>FAST_RET</code>。大体上，<code>FAST_CALL</code>是用来跳到 finally 代码块中，而<code>FAST_RET</code>是用来跳出的。我们来分析下面的例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>echo</span> <span class=s2>&#34;try&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>finally</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>echo</span> <span class=s2>&#34;finally&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>echo</span> <span class=s2>&#34;finished&#34;</span><span class=p>;</span>
</span></span></code></pre></div><p>上述代码会生成下面的 opcode 序列：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=nx>L0</span><span class=o>:</span>   <span class=k>ECHO</span> <span class=nx>string</span><span class=p>(</span><span class=s2>&#34;try&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>L1</span><span class=o>:</span>   <span class=nx>T0</span> <span class=o>=</span> <span class=nx>FAST_CALL</span> <span class=o>-&gt;</span><span class=na>L3</span>
</span></span><span class=line><span class=cl><span class=nx>L2</span><span class=o>:</span>   <span class=nx>JMP</span> <span class=o>-&gt;</span><span class=na>L5</span>
</span></span><span class=line><span class=cl><span class=nx>L3</span><span class=o>:</span>   <span class=k>ECHO</span> <span class=nx>string</span><span class=p>(</span><span class=s2>&#34;finally&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>L4</span><span class=o>:</span>   <span class=nx>FAST_RET</span> <span class=nx>T0</span>
</span></span><span class=line><span class=cl><span class=nx>L5</span><span class=o>:</span>   <span class=k>ECHO</span> <span class=nx>string</span><span class=p>(</span><span class=s2>&#34;finished&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>L6</span><span class=o>:</span>   <span class=k>RETURN</span> <span class=nx>int</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span></code></pre></div><p><code>FAST_CALL</code>将它自己的位置保存在<code>T0</code>中，然后跳到 finally 代码块<code>L3</code>处。当执行到<code>FAST_RET</code>的时候，它会跳到之前保存在<code>T0</code>的位置之后一个位置，也就是上述代码中的<code>L2</code>处。这就是一个最基本的情况，没有 return 和 exception 发生。下面我们来分析下异常发生的情况：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=k>new</span> <span class=nx>Exception</span><span class=p>(</span><span class=s2>&#34;try&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=nx>Exception</span> <span class=nv>$e</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=k>new</span> <span class=nx>Exception</span><span class=p>(</span><span class=s2>&#34;catch&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>finally</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=k>new</span> <span class=nx>Exception</span><span class=p>(</span><span class=s2>&#34;finally&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>当处理异常的时候，我们需要考虑抛出异常的位置相对于 try/catch/finally 代码块的偏移：</p><ol><li>如果在 try 中抛出异常：移出<code>$e</code>然后跳到 catch.</li><li>如果在 catch 中或者在 try 中抛出但是没有匹配到合适的 catch，如果有 finally 代码块：跳到 finally 代码块，然后将 exception 备份到<code>FAST_CALL</code>临时变量中</li><li>如果在 finally 中抛出异常：如果有一个备份的异常存在于<code>FAST_CALL</code>临时变量中，将其关联到成当前异常的上一个异常。继续向外抛出异常到下一个 try/catch/finally。</li><li>否则：继续向外抛出异常到下一个 try/catch/finally。</li></ol><p>前面的小例子能够覆盖到前三步：先 try，抛出异常，触发一个 jump 到 catch，catch 中继续抛出异常，触发一个 jump 到 finally，并且将 catch 中的异常备份到 FAST_CALL 中。finally 中续集抛出，&ldquo;finally"异常会将"catch"链接成自己前一个异常继续向外抛出。</p><p>我们对上面的代码做一些小的改动：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>throw</span> <span class=k>new</span> <span class=nx>Exception</span><span class=p>(</span><span class=s2>&#34;try&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>finally</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=nx>Exception</span> <span class=nv>$e</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>throw</span> <span class=k>new</span> <span class=nx>Exception</span><span class=p>(</span><span class=s2>&#34;catch&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>finally</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>finally</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>throw</span> <span class=k>new</span> <span class=nx>Exception</span><span class=p>(</span><span class=s2>&#34;finally&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>finally</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>上面代码中，所有的内层 finally 都有异常进入，但是都正常退出了（通过 FAST_RET）。在这种情况下，前面描述的异常处理过程从外层 try/catch/finally 处恢复执行。外层的 try/catch 被存放在 FAST_RET opcode 中。</p><p>了解到了 finally 和异常互动的本质，那么 return 和 finally 又会是什么样的呢？</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=k>new</span> <span class=nx>Exception</span><span class=p>(</span><span class=s2>&#34;try&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>finally</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>42</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>上面的代码会生成下面的 opcode 序列：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=nx>L4</span><span class=o>:</span>   <span class=nx>T0</span> <span class=o>=</span> <span class=nx>FAST_CALL</span> <span class=o>-&gt;</span><span class=na>L6</span>
</span></span><span class=line><span class=cl><span class=nx>L5</span><span class=o>:</span>   <span class=nx>JMP</span> <span class=o>-&gt;</span><span class=na>L9</span>
</span></span><span class=line><span class=cl><span class=nx>L6</span><span class=o>:</span>   <span class=nx>DISCARD_EXCEPTION</span> <span class=nx>T0</span>
</span></span><span class=line><span class=cl><span class=nx>L7</span><span class=o>:</span>   <span class=k>RETURN</span> <span class=mi>42</span>
</span></span><span class=line><span class=cl><span class=nx>L8</span><span class=o>:</span>   <span class=nx>FAST_RET</span> <span class=nx>T0</span>
</span></span></code></pre></div><p>这里的<code>DISCARD_EXCEPTION</code> opcode 是用来忽略 try 代码块中的异常的（记住：最终 finally 中的 return 赢了）。那么如果 return 在 try 里边呢？</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>$a</span> <span class=o>=</span> <span class=mi>42</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nv>$a</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>finally</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>++</span><span class=nv>$a</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这里返回的值是 42 而不是 43。返回值发生在<code>return $a</code>这行，任何后续对<code>$a</code>的修改都不用考虑。生成的 opcode 序列如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=nx>L0</span><span class=o>:</span>   <span class=nx>ASSIGN</span> <span class=nv>$a</span><span class=p>,</span> <span class=mi>42</span>
</span></span><span class=line><span class=cl><span class=nx>L1</span><span class=o>:</span>   <span class=nx>T3</span> <span class=o>=</span> <span class=nx>QM_ASSIGN</span> <span class=nv>$a</span>
</span></span><span class=line><span class=cl><span class=nx>L2</span><span class=o>:</span>   <span class=nx>T1</span> <span class=o>=</span> <span class=nx>FAST_CALL</span> <span class=o>-&gt;</span><span class=na>L6</span><span class=p>,</span> <span class=nx>T3</span>
</span></span><span class=line><span class=cl><span class=nx>L3</span><span class=o>:</span>   <span class=k>RETURN</span> <span class=nx>T3</span>
</span></span><span class=line><span class=cl><span class=nx>L4</span><span class=o>:</span>   <span class=nx>T1</span> <span class=o>=</span> <span class=nx>FAST_CALL</span> <span class=o>-&gt;</span><span class=na>L6</span>      <span class=c1># unreachable
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>L5</span><span class=o>:</span>   <span class=nx>JMP</span> <span class=o>-&gt;</span><span class=na>L8</span>                 <span class=c1># unreachable
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>L6</span><span class=o>:</span>   <span class=nx>PRE_INC</span> <span class=nv>$a</span>
</span></span><span class=line><span class=cl><span class=nx>L7</span><span class=o>:</span>   <span class=nx>FAST_RET</span> <span class=nx>T1</span>
</span></span><span class=line><span class=cl><span class=nx>L8</span><span class=o>:</span>   <span class=k>RETURN</span> <span class=k>null</span>
</span></span></code></pre></div><p>有两个 opcodes 是不可达的，因为它们发生在 return 之后，通过优化将会移除它们，但是这里展示的是没有优化过的代码。这里有两个很有意思的地方：首先<code>$a</code>通过<code>QM_ASSIGN</code>（这是一个基本的拷贝到临时变量的指令）拷贝到<code>T3</code>中，这就是为什么能防止后续对<code>$a</code>的操作影响到返回值，其次就是<code>T3</code>也被传递给了<code>FAST_CALL</code>，它的值会在<code>T1</code>中备份，如果 try 中的 return 在后面的操作中被忽略了（例如 finally 中抛出异常或出现 return），这种机制将会用来释放没有使用的返回值。</p><p>所有的这些案例机制都很简单，但是当他们组合到一起的时候就需要注意了。考虑下面的例子，如果<code>Dtor</code>又是一个可遍历的类，而且有一个会抛出异常的析构函数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>foreach</span> <span class=p>(</span><span class=k>new</span> <span class=nx>Dtor</span> <span class=k>as</span> <span class=nv>$v</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>finally</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>finally</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>echo</span> <span class=s2>&#34;finally&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>生成的 opcode 序列为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=nx>L0</span><span class=o>:</span>   <span class=nx>V2</span> <span class=o>=</span> <span class=k>NEW</span> <span class=p>(</span><span class=mi>0</span> <span class=nx>args</span><span class=p>)</span> <span class=s2>&#34;Dtor&#34;</span>
</span></span><span class=line><span class=cl><span class=nx>L1</span><span class=o>:</span>   <span class=nx>DO_FCALL</span>
</span></span><span class=line><span class=cl><span class=nx>L2</span><span class=o>:</span>   <span class=nx>V4</span> <span class=o>=</span> <span class=nx>FE_RESET_R</span> <span class=nx>V2</span> <span class=o>-&gt;</span><span class=na>L16</span>
</span></span><span class=line><span class=cl><span class=nx>L3</span><span class=o>:</span>   <span class=nx>FE_FETCH_R</span> <span class=nx>V4</span> <span class=nv>$v</span> <span class=o>-&gt;</span><span class=na>L16</span>
</span></span><span class=line><span class=cl><span class=nx>L4</span><span class=o>:</span>       <span class=nx>T5</span> <span class=o>=</span> <span class=nx>FAST_CALL</span> <span class=o>-&gt;</span><span class=na>L10</span>         <span class=c1># inner try
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>L5</span><span class=o>:</span>       <span class=nx>FE_FREE</span> <span class=p>(</span><span class=nx>free</span> <span class=nx>on</span> <span class=k>return</span><span class=p>)</span> <span class=nx>V4</span>
</span></span><span class=line><span class=cl><span class=nx>L6</span><span class=o>:</span>       <span class=nx>T1</span> <span class=o>=</span> <span class=nx>FAST_CALL</span> <span class=o>-&gt;</span><span class=na>L19</span>
</span></span><span class=line><span class=cl><span class=nx>L7</span><span class=o>:</span>       <span class=k>RETURN</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=nx>L8</span><span class=o>:</span>       <span class=nx>T5</span> <span class=o>=</span> <span class=nx>FAST_CALL</span> <span class=o>-&gt;</span><span class=na>L10</span>         <span class=c1># unreachable
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>L9</span><span class=o>:</span>       <span class=nx>JMP</span> <span class=o>-&gt;</span><span class=na>L15</span>
</span></span><span class=line><span class=cl><span class=nx>L10</span><span class=o>:</span>      <span class=nx>DISCARD_EXCEPTION</span> <span class=nx>T5</span>         <span class=c1># inner finally
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>L11</span><span class=o>:</span>      <span class=nx>FE_FREE</span> <span class=p>(</span><span class=nx>free</span> <span class=nx>on</span> <span class=k>return</span><span class=p>)</span> <span class=nx>V4</span>
</span></span><span class=line><span class=cl><span class=nx>L12</span><span class=o>:</span>      <span class=nx>T1</span> <span class=o>=</span> <span class=nx>FAST_CALL</span> <span class=o>-&gt;</span><span class=na>L19</span>
</span></span><span class=line><span class=cl><span class=nx>L13</span><span class=o>:</span>      <span class=k>RETURN</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=nx>L14</span><span class=o>:</span>      <span class=nx>FAST_RET</span> <span class=nx>T5</span> <span class=k>try</span><span class=o>-</span><span class=k>catch</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>L15</span><span class=o>:</span>  <span class=nx>JMP</span> <span class=o>-&gt;</span><span class=na>L3</span>
</span></span><span class=line><span class=cl><span class=nx>L16</span><span class=o>:</span>  <span class=nx>FE_FREE</span> <span class=nx>V4</span>
</span></span><span class=line><span class=cl><span class=nx>L17</span><span class=o>:</span>  <span class=nx>T1</span> <span class=o>=</span> <span class=nx>FAST_CALL</span> <span class=o>-&gt;</span><span class=na>L19</span>
</span></span><span class=line><span class=cl><span class=nx>L18</span><span class=o>:</span>  <span class=nx>JMP</span> <span class=o>-&gt;</span><span class=na>L21</span>
</span></span><span class=line><span class=cl><span class=nx>L19</span><span class=o>:</span>  <span class=k>ECHO</span> <span class=s2>&#34;finally&#34;</span>                   <span class=c1># outer finally
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>L20</span><span class=o>:</span>  <span class=nx>FAST_RET</span> <span class=nx>T1</span>
</span></span></code></pre></div><p>执行第一个 return 的序列是<code>FAST_CALL</code>，<code>L10</code>，<code>FE_FREE V4</code>，<code>FAST_CALL L19</code>，<code>RETURN</code>，然后就会执行到内部的 finally 中，接着释放 foreach loop variable，然后进入到外层的 finally，然后再 return。执行第二次 return 的序列是<code>DISCARD_EXCEPTION T5</code>，<code>FE_FREE V4</code>，<code>FAST_CALL L19</code>。这里先忽略了内部 try 代码块中的 exception（或者这里是 return value），然后释放了 foreach loop variable 最后执行外部的 finally 代码块。要注意的是到所有情况中这些指令的顺序相对于实际的代码块是如何颠倒的。</p><h2 id=生成器-generators data-numberify>生成器 (Generators)<a class="anchor ms-1 d-none" href=#生成器-generators>#</a></h2><p>生成器函数可以暂停和恢复执行，而且需要特殊的 VM 栈来管理。下面是一个简单的生成器：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=k>function</span> <span class=nf>gen</span><span class=p>(</span><span class=nv>$x</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>foo</span><span class=p>(</span><span class=k>yield</span> <span class=nv>$x</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>生成如下 opcode 序列：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=nv>$x</span> <span class=o>=</span> <span class=nx>RECV</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=nx>GENERATOR_CREATE</span>
</span></span><span class=line><span class=cl><span class=nx>INIT_FCALL_BY_NAME</span> <span class=p>(</span><span class=mi>1</span> <span class=nx>args</span><span class=p>)</span> <span class=nx>string</span><span class=p>(</span><span class=s2>&#34;foo&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>V1</span> <span class=o>=</span> <span class=k>YIELD</span> <span class=nv>$x</span>
</span></span><span class=line><span class=cl><span class=nx>SEND_VAR_NO_REF_EX</span> <span class=nx>V1</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=nx>DO_FCALL_BY_NAME</span>
</span></span><span class=line><span class=cl><span class=nx>GENERATOR_RETURN</span> <span class=k>null</span>
</span></span></code></pre></div><p>在<code>GENERATOR_CREATE</code>到达之前，代码在普通的函数中执行在普通的 VM 栈里。接着<code>GENERATOR_CREATE</code>创建一个<code>Generator</code>对象，同时创建一个堆分配的 execute_data 结构，里边拷贝了 VM 栈中 execute_data。当生成器再次恢复的时候，执行器会使用堆分配的 execute_data，否则的话就继续将调用栈帧压入主 VM 栈中。一个明显的问题就是当一个调用正在进行的时候，可能会中断生成器，正如前面的例子中展示的那样，<code>YIELD</code>执行的时候调用<code>foo()</code>的栈帧已经被压入到 VM 栈中。这些相关的不常见的情形都是通过在控制权让出的时候将当前活跃的调用栈帧拷贝到生成器结构中，在生成器恢复的时候再恢复它们来处理的。</p><p>这种设计直到 PHP7.1 才被使用，之前的版本中每个生成器都有它自己的 4KB 大小的虚拟机 page，它们会在生成器恢复的时候交换到执行器里。这样避免了对调用栈帧的拷贝，否则就需要使用更多的记忆体。</p><h2 id=smart-branches data-numberify>Smart branches<a class="anchor ms-1 d-none" href=#smart-branches>#</a></h2><p>一个比较指令后面跟一个跳转指令的情况很常见，就想下面这样：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=nx>L0</span><span class=o>:</span>   <span class=nx>T2</span> <span class=o>=</span> <span class=nx>IS_EQUAL</span> <span class=nv>$a</span><span class=p>,</span> <span class=nv>$b</span>
</span></span><span class=line><span class=cl><span class=nx>L1</span><span class=o>:</span>   <span class=nx>JMPZ</span> <span class=nx>T2</span> <span class=o>-&gt;</span><span class=na>L3</span>
</span></span><span class=line><span class=cl><span class=nx>L2</span><span class=o>:</span>   <span class=k>ECHO</span> <span class=s2>&#34;equal&#34;</span>
</span></span></code></pre></div><p>由于这种模式太常见了，所有的比较指令（例如 IS_EQUAL）实现了一个只能分支机制：它们会检查它们后面的指令是否是 JMPZ 或 JMPNZ 指令，如果是的话，自动执行后续的相应的跳转指令。</p><p>智能分支机制只会校验跟在它后面的指令是否为 JMPZ/JMPNZ，而不会校验它们的操作数是否是比较指令的结果。需要特别注意的是比较操作和跳转操作并不是直接相邻的情况，例如：<code>($a == $b) + ($d ? $e : $f)</code>会生成下面的执行序列：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=nx>L0</span><span class=o>:</span>   <span class=nx>T5</span> <span class=o>=</span> <span class=nx>IS_EQUAL</span> <span class=nv>$a</span><span class=p>,</span> <span class=nv>$b</span>
</span></span><span class=line><span class=cl><span class=nx>L1</span><span class=o>:</span>   <span class=nx>NOP</span>
</span></span><span class=line><span class=cl><span class=nx>L2</span><span class=o>:</span>   <span class=nx>JMPZ</span> <span class=nv>$d</span> <span class=o>-&gt;</span><span class=na>L5</span>
</span></span><span class=line><span class=cl><span class=nx>L3</span><span class=o>:</span>   <span class=nx>T6</span> <span class=o>=</span> <span class=nx>QM_ASSIGN</span> <span class=nv>$e</span>
</span></span><span class=line><span class=cl><span class=nx>L4</span><span class=o>:</span>   <span class=nx>JMP</span> <span class=o>-&gt;</span><span class=na>L6</span>
</span></span><span class=line><span class=cl><span class=nx>L5</span><span class=o>:</span>   <span class=nx>T6</span> <span class=o>=</span> <span class=nx>QM_ASSIGN</span> <span class=nv>$f</span>
</span></span><span class=line><span class=cl><span class=nx>L6</span><span class=o>:</span>   <span class=nx>T7</span> <span class=o>=</span> <span class=nx>ADD</span> <span class=nx>T5</span> <span class=nx>T6</span>
</span></span><span class=line><span class=cl><span class=nx>L7</span><span class=o>:</span>   <span class=nx>FREE</span> <span class=nx>T7</span>
</span></span></code></pre></div><p>注意到<code>NOP</code>被插入到了<code>IS_EQUAL</code>和<code>JMPZ</code>之间。如果没有这里的<code>NOP</code>的话，分支最终就会使用<code>IS_EQUAL</code>的结果，而不是 JMPZ 操作数。</p><h2 id=runtime-cache data-numberify>Runtime cache<a class="anchor ms-1 d-none" href=#runtime-cache>#</a></h2><p>由于 opcode array 在多进程中是共享的（没有锁），它们是绝度不可变的。但是，运行时的数值可能会被缓存在独立的“runtime cache”中，它们基本上就是一个指针数组。字面量通常有一个相关的 runtime cache 的入口（也可能是多个），被存放在它们的 u2 槽中。</p><p>runtime cache entries 有两种类型：一个是原始的 cache entries，例如 INIT_FCALL 使用的那种，当 INIT_FCALL 查找到调用的函数后，函数指针就会被缓存在一个相关的 runtime cache 里。另一个是 polymorphic cache entries，它有两个连续的缓存槽，第一个存放 class entry，第二个用来存放资料。像 FETCH_OBJ_R 这样的操作会使用这种 cache entry。当一个确定类的属性相对于属性表的偏移被缓存后，如果接下来有对这个类有同样的访问时，就会使用缓存，否则就会再次执行昂贵的查找操作，然后将新的结果缓存起来。</p><h2 id=vm-interrupts data-numberify>VM interrupts<a class="anchor ms-1 d-none" href=#vm-interrupts>#</a></h2><p>在 PHP7.0 以前，执行超时通常的处理是使用一个<code>longjump</code>直接从信号处理跳转到 shutdown 执行序。你也许能够想象到，这样造成了各种不愉快的行为。直到 PHP7.0，超时会延迟直到控制权重新还给虚拟机。如果它不在一定宽限的时期返回，进程就会终止。到了 PHP7.1，pcntl 信号处理使用同样的机制来处理执行超时。</p><p>当收到一个等待信号，VM 中断标记就会被设置，而且此标记会在一个确定的地方被虚拟机校验。校验只会在 jumps 和 calls 指令中进行，而不会在所有指令中发生。因此，中断并不会立刻被处理并返回控制权给 VM，而是在线性控制流的当前段结束的时候处理。</p><h2 id=specialization data-numberify>Specialization<a class="anchor ms-1 d-none" href=#specialization>#</a></h2><p>如果你看过 VM 的定义文件，你就会发现 opcode handler 的定义长得是这个样子的：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>ZEND_VM_HANDLER</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>ZEND_ADD</span><span class=p>,</span> <span class=n>CONST</span><span class=o>|</span><span class=n>TMPVAR</span><span class=o>|</span><span class=n>CV</span><span class=p>,</span> <span class=n>CONST</span><span class=o>|</span><span class=n>TMPVAR</span><span class=o>|</span><span class=n>CV</span><span class=p>)</span>
</span></span></code></pre></div><p>这里的<code>1</code>是 opcode number，<code>ZEND_ADD</code>是名字，其他两个参数是可接受的操作数类型。自动生成的虚拟机代码会包含所有可能的操作数类型的 handler，它们会被大致命名为形如<code>ZEND_ADD_SPEC_CONST_CONST_HANDLER</code>的格式。</p><p>特定的 handlers 在自动生成的时候，handler body 里会被替换成一些特殊的宏，一个很明显的例子就是<code>OP1_TYPE</code>和<code>OP2_TYPE</code>，而像<code>GET_OP1_ZVAL_PTR()</code>和<code>FREE_OP1()</code>这样的操作同样是特定的。</p><p>ADD handler 接收<code>CONST|TMPVAR|CV</code>类型的操作数。<code>TMPVAR</code>在这里表示 opcode 既能接收<code>TMPs</code>也能接收<code>VARs</code>，只是没有将他们特别的区分开。再强调一遍，大多数情况下，<code>TMP</code>和<code>VAR</code>的唯一区别在于后者能够包含引用类型的数据。对于像<code>ADD</code>这样的操作，将它们区分开是没有意义的。其他一些确实需要将它们区分对待的操作会在它们的操作数列表中使用<code>TMP|VAR</code>。</p><p>不仅可以特定操作数类型，handlers 也可以特定其他的元素，例如它是否有返回值。例如<code>ASSIGN_DIM</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>ZEND_VM_HANDLER</span><span class=p>(</span><span class=mi>147</span><span class=p>,</span> <span class=n>ZEND_ASSIGN_DIM</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>VAR</span><span class=o>|</span><span class=n>CV</span><span class=p>,</span> <span class=n>CONST</span><span class=o>|</span><span class=n>TMPVAR</span><span class=o>|</span><span class=n>UNUSED</span><span class=o>|</span><span class=n>NEXT</span><span class=o>|</span><span class=n>CV</span><span class=p>,</span> <span class=n>SPEC</span><span class=p>(</span><span class=n>OP_DATA</span><span class=o>=</span><span class=n>CONST</span><span class=o>|</span><span class=n>TMP</span><span class=o>|</span><span class=n>VAR</span><span class=o>|</span><span class=n>CV</span><span class=p>))</span>
</span></span></code></pre></div><p>在这样的签名下，$ 2 * 4 * 4 $种不同的<code>ASSIGN_DIM</code>会被自动生成。在上面的定义中，第二个操作数包含了一个<code>NEXT</code>，它跟限定因素无关，而是表明一个<code>UNUSED</code>操作数存在于它的上下文中：也就是说这是一个 append 操作（<code>$arr[]</code>）。另一个例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>ZEND_VM_HANDLER</span><span class=p>(</span><span class=mi>23</span><span class=p>,</span> <span class=n>ZEND_ASSIGN_ADD</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>VAR</span><span class=o>|</span><span class=n>UNUSED</span><span class=o>|</span><span class=n>THIS</span><span class=o>|</span><span class=n>CV</span><span class=p>,</span> <span class=n>CONST</span><span class=o>|</span><span class=n>TMPVAR</span><span class=o>|</span><span class=n>UNUSED</span><span class=o>|</span><span class=n>NEXT</span><span class=o>|</span><span class=n>CV</span><span class=p>,</span> <span class=n>DIM_OBJ</span><span class=p>,</span> <span class=n>SPEC</span><span class=p>(</span><span class=n>DIM_OBJ</span><span class=p>))</span>
</span></span></code></pre></div><p>这里我们的第一个操作数有一个<code>UNUSED</code>标识通常表示访问一个<code>$this</code>。这是对象相关 opcode 的惯例，例如<code>FETCH_OBJ_R_UNUSED, 'prop'</code>表示的是<code>$this->prop</code>。而第二个<code>UNUSED</code>操作数表示一个 append 操作。这里的第三个参数是扩展操作数：它包含了用以区分<code>$a += 1</code>，<code>$a[$b] += 1</code>，<code>$a->b +=1</code>的标记。最后的<code>SPEC(DIM_OBJ)</code>表明应该为它们每一个都生成一个专门的 handler。（这种情况下生成的 handler 的数量是未知的，因为 VM 不可能知道确定的组合，例如一个<code>UNUSED</code> op1 只能和 OBJ 相关）</p><p>最后虚拟机生成器还会做一些额外的支持和更加复杂的特定机制。在 VM 定义文件的最后，你可以发现一些类似于下面的 handlers:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>ZEND_VM_TYPE_SPEC_HANDLER</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>ZEND_ADD</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>res_info</span> <span class=o>==</span> <span class=n>MAY_BE_LONG</span> <span class=o>&amp;&amp;</span> <span class=n>op1_info</span> <span class=o>==</span> <span class=n>MAY_BE_LONG</span> <span class=o>&amp;&amp;</span> <span class=n>op2_info</span> <span class=o>==</span> <span class=n>MAY_BE_LONG</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=n>ZEND_ADD_LONG_NO_OVERFLOW</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>CONST</span><span class=o>|</span><span class=n>TMPVARCV</span><span class=p>,</span> <span class=n>CONST</span><span class=o>|</span><span class=n>TMPVARCV</span><span class=p>,</span> <span class=n>SPEC</span><span class=p>(</span><span class=n>NO_CONST_CONST</span><span class=p>,</span><span class=n>COMMUTATIVE</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></div><p>这些特定的 handler 不仅根据 VM 操作数类型，还会根据操作数在运行时可能存在的类型。这种可能的操作数类型机制属于 opcache 优化设施的一部分而且已经超出了本文的范围。但是，假设这个信息可以被获取到，那么我们就能清楚明白这是一个形如<code>int + int -> int</code>的额外 handler。此外，<code>SPEC</code>声明说明两种 CONST 操作数类型的 handler 不被生成，而且两个操作数可以交换（加法交换律），因此，如果我们已经有一个<code>CONST+TEMPVARCV</code>的设定，就不必再生成一个<code>TMPVARCV+CONST</code>了。</p><h2 id=fast-path--slow-path-split data-numberify>Fast-path / slow-path split<a class="anchor ms-1 d-none" href=#fast-path--slow-path-split>#</a></h2><p>一些 opcode handlers 的实现都做了 fast-path 和 slow-path 的区分，首先会处理一些常见案例，其次才会进入到泛型实现中。是时候看看真实的代码是如何实现的了，下面是我粘贴的关于 SL(shift-left)的实现：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>ZEND_VM_HANDLER</span><span class=p>(</span><span class=mi>6</span><span class=p>,</span> <span class=n>ZEND_SL</span><span class=p>,</span> <span class=n>CONST</span><span class=o>|</span><span class=n>TMPVAR</span><span class=o>|</span><span class=n>CV</span><span class=p>,</span> <span class=n>CONST</span><span class=o>|</span><span class=n>TMPVAR</span><span class=o>|</span><span class=n>CV</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>USE_OPLINE</span>
</span></span><span class=line><span class=cl>	<span class=n>zend_free_op</span> <span class=n>free_op1</span><span class=p>,</span> <span class=n>free_op2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>zval</span> <span class=o>*</span><span class=n>op1</span><span class=p>,</span> <span class=o>*</span><span class=n>op2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>op1</span> <span class=o>=</span> <span class=n>GET_OP1_ZVAL_PTR_UNDEF</span><span class=p>(</span><span class=n>BP_VAR_R</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>op2</span> <span class=o>=</span> <span class=n>GET_OP2_ZVAL_PTR_UNDEF</span><span class=p>(</span><span class=n>BP_VAR_R</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>EXPECTED</span><span class=p>(</span><span class=n>Z_TYPE_INFO_P</span><span class=p>(</span><span class=n>op1</span><span class=p>)</span> <span class=o>==</span> <span class=n>IS_LONG</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=o>&amp;&amp;</span> <span class=n>EXPECTED</span><span class=p>(</span><span class=n>Z_TYPE_INFO_P</span><span class=p>(</span><span class=n>op2</span><span class=p>)</span> <span class=o>==</span> <span class=n>IS_LONG</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=o>&amp;&amp;</span> <span class=n>EXPECTED</span><span class=p>((</span><span class=n>zend_ulong</span><span class=p>)</span><span class=n>Z_LVAL_P</span><span class=p>(</span><span class=n>op2</span><span class=p>)</span> <span class=o>&lt;</span> <span class=n>SIZEOF_ZEND_LONG</span> <span class=o>*</span> <span class=mi>8</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>ZVAL_LONG</span><span class=p>(</span><span class=n>EX_VAR</span><span class=p>(</span><span class=n>opline</span><span class=o>-&gt;</span><span class=n>result</span><span class=p>.</span><span class=n>var</span><span class=p>),</span> <span class=n>Z_LVAL_P</span><span class=p>(</span><span class=n>op1</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>Z_LVAL_P</span><span class=p>(</span><span class=n>op2</span><span class=p>));</span>
</span></span><span class=line><span class=cl>		<span class=n>ZEND_VM_NEXT_OPCODE</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>SAVE_OPLINE</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>OP1_TYPE</span> <span class=o>==</span> <span class=n>IS_CV</span> <span class=o>&amp;&amp;</span> <span class=n>UNEXPECTED</span><span class=p>(</span><span class=n>Z_TYPE_INFO_P</span><span class=p>(</span><span class=n>op1</span><span class=p>)</span> <span class=o>==</span> <span class=n>IS_UNDEF</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>op1</span> <span class=o>=</span> <span class=n>GET_OP1_UNDEF_CV</span><span class=p>(</span><span class=n>op1</span><span class=p>,</span> <span class=n>BP_VAR_R</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>OP2_TYPE</span> <span class=o>==</span> <span class=n>IS_CV</span> <span class=o>&amp;&amp;</span> <span class=n>UNEXPECTED</span><span class=p>(</span><span class=n>Z_TYPE_INFO_P</span><span class=p>(</span><span class=n>op2</span><span class=p>)</span> <span class=o>==</span> <span class=n>IS_UNDEF</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>op2</span> <span class=o>=</span> <span class=n>GET_OP2_UNDEF_CV</span><span class=p>(</span><span class=n>op2</span><span class=p>,</span> <span class=n>BP_VAR_R</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=n>shift_left_function</span><span class=p>(</span><span class=n>EX_VAR</span><span class=p>(</span><span class=n>opline</span><span class=o>-&gt;</span><span class=n>result</span><span class=p>.</span><span class=n>var</span><span class=p>),</span> <span class=n>op1</span><span class=p>,</span> <span class=n>op2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>FREE_OP1</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=n>FREE_OP2</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=n>ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>实现以使用<code>GET_OPn_ZVAL_PTR_UNDEF</code>在<code>BP_VAR_R</code>模式下查询操作数开始，这里的<code>UNDEF</code>部分表示的是在处理 CV 的时候不需要检查变量是否被定义，而是只需要返回一个 UNDEF 数值。当我们拿到了操作数，我们校验它们是否都是整数类型和移动的长度是超出范围，然后操作的结果会被直接计算出来，我们会继续执行下一个 opcode。因为这里的类型校验不会处理 UNDEF 的操作数，所以这里使用<code>GET_OPn_ZVAL_PTR_UNDEF</code>是恰当的。</p><p>如果操作数不能满足 fast-path，我们就会进入到一般的实现当中，这种实现以<code>SAVE_OPLINE()</code>开始，这就是一个信号表明了“潜在的操作如下”。在进行其他操作之前，需要处理未定义的变量的强开。<code>GET_OPn_UNDEF_CV</code>在这种情况下会发出一个未定义变量的警告并且返回 NULL。接着普通的<code>shift_left_function</code>被调用，并且将结果写入到<code>EX_VAR(opline->result.var)</code>中，最后将输入操作数释放掉（如果有必要的话），然后检查异常后推进执行下一个 opcode（这表明，在推进前 opline 会被重置）。</p><p>对于上面的代码，fast-path 节省了两次对未定义变量的校验和一次函数调用，释放操作，还有保存和重置 opline 给异常处理的操作。大多数对性能敏感的 opcode 都是以这种方式呈现的。</p><h2 id=vm-macros data-numberify>VM macros<a class="anchor ms-1 d-none" href=#vm-macros>#</a></h2><p>正如前面代码清单中看到的那样，虚拟机实现了许多可以自由使用的宏。其中一些是普通的 C 语言宏，另一些在虚拟机被生成的时候才会确定。特别地，这些宏包含了一些查找和释放指令的操作：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>OPn_TYPE</span>
</span></span><span class=line><span class=cl><span class=n>OP_DATA_TYPE</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>GET_OPn_ZVAL_PTR</span><span class=p>(</span><span class=n>BP_VAR_</span><span class=o>*</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>GET_OPn_ZVAL_PTR_DEREF</span><span class=p>(</span><span class=n>BP_VAR_</span><span class=o>*</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>GET_OPn_ZVAL_PTR_UNDEF</span><span class=p>(</span><span class=n>BP_VAR_</span><span class=o>*</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>GET_OPn_ZVAL_PTR_PTR</span><span class=p>(</span><span class=n>BP_VAR_</span><span class=o>*</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>GET_OPn_ZVAL_PTR_PTR_UNDEF</span><span class=p>(</span><span class=n>BP_VAR_</span><span class=o>*</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>GET_OPn_OBJ_ZVAL_PTR</span><span class=p>(</span><span class=n>BP_VAR_</span><span class=o>*</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>GET_OPn_OBJ_ZVAL_PTR_UNDEF</span><span class=p>(</span><span class=n>BP_VAR_</span><span class=o>*</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>GET_OPn_OBJ_ZVAL_PTR_DEREF</span><span class=p>(</span><span class=n>BP_VAR_</span><span class=o>*</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>GET_OPn_OBJ_ZVAL_PTR_PTR</span><span class=p>(</span><span class=n>BP_VAR_</span><span class=o>*</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>GET_OPn_OBJ_ZVAL_PTR_PTR_UNDEF</span><span class=p>(</span><span class=n>BP_VAR_</span><span class=o>*</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>GET_OP_DATA_ZVAL_PTR</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>GET_OP_DATA_ZVAL_PTR_DEREF</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>FREE_OPn</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>FREE_OPn_IF_VAR</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>FREE_OPn_VAR_PTR</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>FREE_UNFETCHED_OPn</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>FREE_OP_DATA</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>FREE_UNFETCHED_OP_DATA</span><span class=p>()</span>
</span></span></code></pre></div><p>如你所见，这些宏有很多类型。<code>BP_VAR_*</code>参数指定了查找模式，支持同样模式的还有<code>FETCH_*</code>指令。</p><p><code>GET_OPn_ZVAL_PTR()</code>是一个基本的操作数查找指令。如果遇到未定义的 CV，会抛出一个警告，并且不会解引操作数。<code>GET_OPn_ZVAL_PTR_UNDEF()</code>不会校验 CVs 是否为未定义，<code>GET_OPn_ZVAL_PTR_DEREF()</code>包含了对 zval 的<code>DEREF</code>操作，这是 GET 操作的一部分，因为解引对 CVs 和 VARs 是很有必要的，但是不适用于 CONSTs 和 TMPs。由于这个宏需要区分 TMPs 和 VARs，所以只能被用于<code>TMP|VAR</code>类型操作数中（而不能用于<code>TMPVAR</code>）。</p><p><code>GET_OPn_OBJ_ZVAL_PTR*()</code>是一类会额外处理 UNUSED 操作数的宏。正如前面提到的，在访问<code>$this</code>的情况下，使用一个 UNUSED 操作数，<code>GET_OPn_OBJ_ZVAL_PTR*()</code>宏会为 UNUSED 操作数返回一个<code>EX(This)</code>的引用。</p><p>最后，还有一类<code>PTR_PTR</code>的宏，这种名字是 PHP5 时代的残存物，它们实际上用于对 zval 双重取址的指针。这些宏在被用于写操作的时候只适用于 CV 和 VAR 类型的操作数（其他的一律返回 NULL）。</p><p><code>FREE_OP*()</code>宏用于释放查询到的操作数。操作的时候，它们需要一个定义为<code>zend_free_op free_opN</code>的变量，其中 GET 操作存放的数据会被释放。<code>FREE_OPn()</code>操作会释放 TMPs 和 VARs，但是不会释放 CONSTs 和 CVs。<code>FREE_OPn_IF_VAR()</code>顾名思义：如果操作数是一个 VAR 的话就释放。</p><p><code>FREE_OP*_VAR_PTR()</code>是跟<code>PTR_PTR</code>查询结合使用的，它只会释放 VAR 操作数并且它们不能是 INDIRECTed。</p><p><code>FREE_UNFETCHED_OP*()</code>用于操作数在被 GET 查找之前就必须被释放的情况。典型的使用场景就是当异常发生在操作数查找前面的时候。</p><p>除了这些特定的宏，还有一些更普通的宏。VM 定义了一些用于控制一个 opcode handler 执行完之后的行为的宏：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>ZEND_VM_CONTINUE</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>ZEND_VM_ENTER</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>ZEND_VM_LEAVE</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>ZEND_VM_RETURN</span><span class=p>()</span>
</span></span></code></pre></div><p>CONTINUE 会继续执行正常的 opcodes，ENTER/LEAVE 用于进入或退出一个嵌套函数调用。这些操作的具体细节取决于编译器是如何编译的。从广义上讲，它们在继续执行前会同步一些全局状态。RETURN 用于退出主 VM 循环。</p><p>ZEND_VM_CONTINUE()要求 opline 事先更新完。当然也有一些其他的相关的宏：</p><pre tabindex=0><code>                                        | Continue? | Check exception? | Check interrupt?
ZEND_VM_NEXT_OPCODE()                   |   yes     |       no         |       no
ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION()   |   yes     |       yes        |       no
ZEND_VM_SET_NEXT_OPCODE(op)             |   no      |       no         |       no
ZEND_VM_SET_OPCODE(op)                  |   no      |       no         |       yes
ZEND_VM_SET_RELATIVE_OPCODE(op, offset) |   no      |       no         |       yes
ZEND_VM_JMP(op)                         |   yes     |       yes        |       yes
</code></pre><p>这个表格展示了哪些宏当中隐含了 ZEND_VM_CONTINUE()操作，它们是否需要做异常校验和是否校验 VM 中断。</p><p>接着是<code>SAVE_OPLINE()</code>，<code>LOAD_OPLINE()</code>和<code>HANDLE_EXCEPTION()</code>。正如前面提到的，SAVE_OPLINE()用于 opcode handler 中第一次进入 slow-path 操作之前。如果有必要的话，它会将 VM 使用的 opline 备份（通常在一个全局寄存器）到 execute data 里。LOAD_OPLINE()是一个逆操作，但是现今它已经很少被使用，因为它被有效的柔和到 ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION()和 ZEND_VM_JMP()里了。</p><p>HANDLE_EXCEPTION()用于当你在一个 opcode handler 返回前已经明确知道有异常被抛出的情况下。它会同时执行 LOAD_OPLINE 和 CONTINUE，它们被有效的分配到了 HANDLE_EXCEPTION opcode 里。</p><p>当然，还有很多宏没有介绍到，但是我想这里应该已经覆盖到最重要的部分了吧。</p></div></div><div class="modal fade" id=rewardModal tabindex=-1 aria-labelledby=rewardModalLabel aria-hidden=true><div class=modal-dialog><div class="modal-content surface"><div class=modal-header><h5 class="modal-title text-surface" id=rewardModalLabel><i class="fas fa-fw fa-coffee me-1"></i>打赏</h5><a href=# data-bs-dismiss=modal class=btn-close aria-label=Close></a></div><div class=modal-body><ul class="nav nav-tabs mb-3" role=tablist><li class="nav-item text-nowrap" role=presentation><a class="nav-link active" id=reward-alipay-tab data-bs-toggle=tab href=#reward-alipay role=tab aria-controls=reward-alipay aria-selected=true><i class="fab fa-fw fa-alipay me-1"></i>支付宝</a></li><li class="nav-item text-nowrap" role=presentation><a class=nav-link id=reward-wechat-tab data-bs-toggle=tab href=#reward-wechat role=tab aria-controls=reward-wechat aria-selected=true><i class="fab fa-fw fa-weixin me-1"></i>微信</a></li></ul><div class=tab-content id=rewardTabContent><div class="tab-pane fade post-reward-content text-center show active" id=reward-alipay role=tabpanel aria-labelledby=reward-alipay-tab><img class="img-fluid post-reward-img" src=https://iliubang.cn/images/reward/alipay.jpg loading=lazy data-viewer-invisible></div><div class="tab-pane fade post-reward-content text-center show" id=reward-wechat role=tabpanel aria-labelledby=reward-wechat-tab><img class="img-fluid post-reward-img" src=https://iliubang.cn/images/reward/wechat.jpg loading=lazy data-viewer-invisible></div></div></div></div></div></div></div><div class=card-footer><div class="post-navs d-flex justify-content-evenly"><div class="post-nav post-prev"><i class="fas fa-fw fa-chevron-down post-prev-icon me-1" data-fa-transform=rotate-90></i>
<a href=https://iliubang.cn/posts/php/2017-10-12-php%E5%92%8C%E7%BA%BF%E7%A8%8B/>PHP和线程</a></div><div class="post-nav post-next"><a href=https://iliubang.cn/posts/cpp/2018-02-13-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/>c++编程之面向对象</a>
<i class="fas fa-fw fa-chevron-down post-next-icon ms-1" data-fa-transform=rotate-270></i></div></div></div></article><div class="post-copyright mb-3 row card component" id=post-copyright><div class=card-header><h2 class="card-title fs-4 my-2 text-surface">版权</h2></div><div class=card-body><a class="d-flex align-items-center flex-column" target=_blank rel="license noopener noreferrer" href=https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh><span><i class="fab fa-fw fa-2x fa-creative-commons"></i><i class="fab fa-fw fa-2x fa-creative-commons-by"></i><i class="fab fa-fw fa-2x fa-creative-commons-nc"></i><i class="fab fa-fw fa-2x fa-creative-commons-nd"></i></span>
CC BY-NC-ND 4.0</a></div></div><section class="related-posts row card component"><div class=card-header><h2 class="card-title fs-4 my-2 text-surface">相关文章</h2></div><div class=card-body><ul class="post-list list-unstyled"><li class="mb-3 border-bottom"><a class=post-title href=https://iliubang.cn/posts/php/2017-10-12-php%E5%92%8C%E7%BA%BF%E7%A8%8B/>PHP和线程</a>
<span class="post-meta post-date float-end">2017-10-12</span><div class="post-summary my-3"><p>原文地址http://blog.jpauli.tech/2017/01/12/threads-and-php.html
前言# PHP 和线程，单凭这简短的几个字，就足以写一本书。像往常一样，我们不会这么做，但是会给出一定程度上跟这个话题相关的信息与细节。让我们从一些人在谈论这个话题时通常感到的困惑开始，PHP 不是一种线程语言， PHP 的内核没有使用线程，而且 PHP 天生也不允许用户层代码通过任何方式使用多线程作为并发机制。
因此 PHP 跟其他一些技术有很大的区别，例如 Java。Java 不仅自身使用了大量的线程，它还允许用户通过编程来是用线程。然而，PHP 不适用线程是有它的原因的。
PHP 内核没有使用线程，主要是为了...</p><div><a class="btn btn-sm btn-outline-primary btn-read-more" href=https://iliubang.cn/posts/php/2017-10-12-php%E5%92%8C%E7%BA%BF%E7%A8%8B/>阅读更多</a></div></div></li><li class="mb-3 border-bottom"><a class=post-title href=https://iliubang.cn/posts/php/2017-08-28-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8/>PHP扩展开发之迭代器</a>
<span class="post-meta post-date float-end">2017-08-28</span><div class="post-summary my-3"><p>preface# 在之前的文章中，我们已经实现了一些 object handlers 来将我们的 ArrayBuffer 整合到 php 中。但是美中不足的是，我们的 ArrayBufferView 并不支持迭代器操作。也就是它不能像 php 中的数组那样使用foreach来遍历。 那么，我们接下来就来看看迭代器在内核中是如何实现的，并且给我们的 ArrayBufferView 也增加一个迭代器。
get_iterator handler# 内核中的迭代器跟用户端的IteratorAggregate接口功能是一样的。一个具有迭代功能的类都有一个get_iterator处理器，它会返回一个zend_object_iterator *类...</p><div><a class="btn btn-sm btn-outline-primary btn-read-more" href=https://iliubang.cn/posts/php/2017-08-28-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8/>阅读更多</a></div></div></li><li class="mb-3 border-bottom"><a class=post-title href=https://iliubang.cn/posts/php/2017-08-27-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%A4%84%E7%90%86%E5%99%A8/>PHP扩展开发之对象处理器(Object Handlers)</a>
<span class="post-meta post-date float-end">2017-08-27</span><div class="post-summary my-3"><p>Object Handlers# 在前面的博文中，已经介绍过一些 object handlers 了，也特别介绍了如何通过指定 handlers 来创建一个自定义的结构和使用clone_obj来对自定义的结构进行克隆操作。 然而，这只是开始：在 php 中，几乎所有的对象操作，都可以通过 object handlers 来实现，而且所有的魔术方法和魔术接口在内核中都是实现了对应的 object handler。此外， 一些 handlers 并没有开放给用户端的 php，例如，内部类可以自定义类的比较操作，而使用 php 代码是无法实现的。
由于 php 中有很多不同的 object handlers，这里只挑几个来讨论，其它的只给...</p><div><a class="btn btn-sm btn-outline-primary btn-read-more" href=https://iliubang.cn/posts/php/2017-08-27-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%A4%84%E7%90%86%E5%99%A8/>阅读更多</a></div></div></li><li class="mb-3 border-bottom"><a class=post-title href=https://iliubang.cn/posts/php/2017-08-25-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E6%89%93%E9%80%A0%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84arraybuffer/>PHP扩展开发之打造一个简易的ArrayBuffer</a>
<span class="post-meta post-date float-end">2017-08-25</span><div class="post-summary my-3"><p>ArrayBuffer 简介# ArrayBuffer 又叫二进制数组，是一个用来表示通用的，固定长度的二进制数据缓冲区。你不能直接操纵 ArrayBuffer 的内容， 而是创建一个表示特定格式的 buffer 的类型化数组对象（也叫做数据视图对象）来对 buffer 的内容进行读写操作。
我最早了解 ArrayBuffer 是从 JavaScript 开始的，具体的用法和 api 可以参考JavaScript 标准库－－ArrayBuffer
那么接下来，我们就给 PHP 扩展一个简单的 ArrayBuffer，顺便巩固一下php 扩展开发之自定义对象的存储。
定义 ArrayBuffer 的数据结构和相关 handlers#...</p><div><a class="btn btn-sm btn-outline-primary btn-read-more" href=https://iliubang.cn/posts/php/2017-08-25-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E6%89%93%E9%80%A0%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84arraybuffer/>阅读更多</a></div></div></li><li class="mb-3 border-bottom"><a class=post-title href=https://iliubang.cn/posts/php/2017-08-24-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%98%E5%82%A8/>PHP扩展开发之自定义对象的存储</a>
<span class="post-meta post-date float-end">2017-08-24</span><div class="post-summary my-3"><p>前言# 对于 php 扩展开发，很多人可能已经不那么陌生了，zend 引擎为了们提供了非常丰富了函数和 macro，来帮助我们很快速的创建一个标准的 php 类，然而，当我们在使用自定义的数据结构(struct)， 并想把我们自己定义的数据结构封装成 php 的类的时候可能就会有些困惑，因为我们都知道 php 中的所有变量都是通过 zval 来存储的，而我们自定义的数据结构要怎样才能和 zval 实现完美的对接呢？ 以前我通常采用的一种方式就是使用 zend 引擎提供的资源类型，因为资源类型的封装中包含了通用的数据类型，而且有很丰富的函数来操作资源，所以使用起来很简单也很方便。然而，强大的 zend 引擎真的没有其他方式扩展数据结构...</p><div><a class="btn btn-sm btn-outline-primary btn-read-more" href=https://iliubang.cn/posts/php/2017-08-24-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%98%E5%82%A8/>阅读更多</a></div></div></li></ul></div></section><div class="card component row post-comments" id=post-comments><div class=card-header><h2 class="card-title my-2 fs-4 text-surface">评论</h2></div><div class=card-body><script src=https://utteranc.es/client.js repo=liubang/blog issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script></div></div></div></div><aside class="col-lg-4 sidebar d-flex"><div class="container d-flex flex-column"><div class="accordion profile"><div class="accordion-item card row text-center component"><div class="accordion-header card-header border-0" id=profile-header><a class="accordion-button d-lg-none mb-2 shadow-none p-0 bg-transparent text-surface" type=button data-bs-toggle=collapse data-bs-target=#profile aria-expanded=true aria-controls=profile>Profile</a></div><div class="card-body collapse accordion-collapse accordion-body d-lg-block show" id=profile aria-labelledby=profile-header><div class="col-12 d-flex align-items-center justify-content-center"><picture><img class="profile-avatar rounded-circle" alt=liubang src=https://iliubang.cn/images/profile.webp loading=lazy data-viewer-invisible width=484 height=483></picture></div><div class="col-12 profile-meta"><div class="profile-name fw-fold fs-lg">liubang</div><div class=profile-bio>Whether you are an antelope or a lion, you ought to dash forward without hesitation when the sun rise</div><div class=profile-company><i class="fas fa-fw fa-building"></i>Baidu</div><div class=profile-location><i class="fas fa-fw fa-map-marker-alt"></i>Beijing</div><div class="profile-about text-primary"><i class="fas fa-fw fa-user"></i><a href=https://iliubang.cn/about/>关于</a></div></div><nav class="social-links nav justify-content-center mt-1 justify-content-around"><a class="nav-link social-link" href=mailto:it.liubang@gmail.com title=电子邮箱><i class="fas fa-fw fa-2x fa-envelope"></i></a>
<a class="nav-link social-link" target=_blank href=https://github.com/liubang title=GitHub rel="noopener noreferrer"><i class="fa-fw fa-2x fab fa-github"></i></a>
<a class="nav-link social-link" target=_blank href=https://weibo.com/2113750192 title=微博 rel="noopener noreferrer"><i class="fa-fw fa-2x fab fa-weibo"></i></a>
<a class="nav-link social-link" target=_blank href=https://iliubang.cn/index.xml title=RSS rel="noopener noreferrer"><i class="fas fa-fw fa-2x fa-rss"></i></a></nav></div></div></div><div class="accordion taxonomies-toggle"><section class="row card component accordion-item"><div class="accordion-header card-header border-0"><a class="accordion-button d-lg-none mb-1 shadow-none p-0 bg-transparent" type=button data-bs-toggle=collapse data-bs-target=#taxonomies-toggle aria-expanded=true aria-controls=taxonomies-toggle>Taxonomies</a></div><div class="card-body collapse accordion-collapse accordion-body d-lg-block show" id=taxonomies-toggle><ul class="nav nav-pills nav-fill" id=myTab role=tablist><li class=nav-item role=presentation><button class="nav-link active" id=taxonomyTagsTab data-bs-toggle=tab data-bs-target=#taxonomyTags type=button role=tab aria-controls=标签 aria-selected=true>
标签</button></li><li class=nav-item role=presentation><button class=nav-link id=taxonomyArchivesTab data-bs-toggle=tab data-bs-target=#taxonomyArchive type=button role=tab aria-controls=taxonomyArchives aria-selected=true>
归档</button></li></ul><div class="tab-content mt-3"><div class="tab-pane active" id=taxonomyTags role=tabpanel aria-labelledby=taxonomyTagsTab tabindex=0><a href=https://iliubang.cn/tags/c++/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-tag me-2 mb-2" title=c++>c++
<span class="badge badge-sm text-secondary bg-white ms-1">16</span></a>
<a href=https://iliubang.cn/tags/c/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-tag me-2 mb-2" title=c>c
<span class="badge badge-sm text-secondary bg-white ms-1">14</span></a>
<a href=https://iliubang.cn/tags/php/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-tag me-2 mb-2" title=php>php
<span class="badge badge-sm text-secondary bg-white ms-1">8</span></a>
<a href=https://iliubang.cn/tags/sp/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-tag me-2 mb-2" title=sp>sp
<span class="badge badge-sm text-secondary bg-white ms-1">5</span></a>
<a href=https://iliubang.cn/tags/c++17/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-tag me-2 mb-2" title=c++17>c++17
<span class="badge badge-sm text-secondary bg-white ms-1">4</span></a>
<a href=https://iliubang.cn/tags/c++11/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-tag me-2 mb-2" title=c++11>c++11
<span class="badge badge-sm text-secondary bg-white ms-1">3</span></a>
<a href=https://iliubang.cn/tags/java/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-tag me-2 mb-2" title=Java>Java
<span class="badge badge-sm text-secondary bg-white ms-1">3</span></a>
<a href=https://iliubang.cn/tags/jni/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-tag me-2 mb-2" title=JNI>JNI
<span class="badge badge-sm text-secondary bg-white ms-1">3</span></a>
<a href=https://iliubang.cn/tags/c++14/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-tag me-2 mb-2" title=c++14>c++14
<span class="badge badge-sm text-secondary bg-white ms-1">2</span></a>
<a href=https://iliubang.cn/tags/compiler/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-tag me-2 mb-2" title=compiler>compiler
<span class="badge badge-sm text-secondary bg-white ms-1">2</span></a>
<a href=https://iliubang.cn/tags class="btn btn-sm btn-secondary post-taxonomy ps-3 post-tag me-2 mb-2" title=全部>全部
<span class="badge badge-sm text-secondary bg-white ms-1">20</span></a></div><div class=tab-pane id=taxonomyArchive role=tabpanel aria-labelledby=taxonomyArchiveTab tabindex=0><a href class="btn btn-sm btn-secondary post-taxonomy ps-3 me-2 mb-2" title=2022>2022 <span class="badge badge-sm text-secondary bg-white ms-1">10</span></a>
<a href class="btn btn-sm btn-secondary post-taxonomy ps-3 me-2 mb-2" title=2021>2021 <span class="badge badge-sm text-secondary bg-white ms-1">1</span></a>
<a href class="btn btn-sm btn-secondary post-taxonomy ps-3 me-2 mb-2" title=2020>2020 <span class="badge badge-sm text-secondary bg-white ms-1">1</span></a>
<a href class="btn btn-sm btn-secondary post-taxonomy ps-3 me-2 mb-2" title=2019>2019 <span class="badge badge-sm text-secondary bg-white ms-1">2</span></a>
<a href class="btn btn-sm btn-secondary post-taxonomy ps-3 me-2 mb-2" title=2018>2018 <span class="badge badge-sm text-secondary bg-white ms-1">10</span></a>
<a href class="btn btn-sm btn-secondary post-taxonomy ps-3 me-2 mb-2" title=2017>2017 <span class="badge badge-sm text-secondary bg-white ms-1">15</span></a></div></div></div></section></div><div class="accordion posts-toggle"><section class="row card component accordion-item"><div class="accordion-header card-header border-0"><a class="accordion-button d-lg-none mb-1 shadow-none p-0 bg-transparent" type=button data-bs-toggle=collapse data-bs-target=#posts-toggle aria-expanded=true aria-controls=posts-toggle>文章</a></div><div class="card-body collapse accordion-collapse accordion-body d-lg-block show" id=posts-toggle><ul class="nav nav-pills nav-fill" id=myTab role=tablist><li class=nav-item role=presentation><button class="nav-link active" id=recent-posts-tab data-bs-toggle=tab data-bs-target=#recent-posts type=button role=tab aria-controls=recent-posts aria-selected=true>
最近文章</button></li></ul><div class="tab-content mt-3"><div class="tab-pane active" id=recent-posts role=tabpanel aria-labelledby=recent-posts-tab tabindex=0><ul class="post-list list-unstyled ms-1"><li class=mb-2><div class=d-flex><div class="flex-grow-1 d-flex flex-column h-auto justify-content-center"><a class=post-title href=https://iliubang.cn/posts/cpp/2022-05-15-%E4%BD%BF%E7%94%A8stdlist%E7%9A%84splice%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0lru-cache/>使用std::list的splice方法实现LRU Cache</a><div class="post-meta mt-2"><span class=post-date>2022-05-15</span></div></div></div></li><li class=mb-2><div class=d-flex><div class="flex-grow-1 d-flex flex-column h-auto justify-content-center"><a class=post-title href=https://iliubang.cn/posts/cpp/2022-05-03-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3enable_shared_from_this/>深入理解 enable_shared_from_this</a><div class="post-meta mt-2"><span class=post-date>2022-05-03</span></div></div></div></li><li class=mb-2><div class=d-flex><div class="flex-grow-1 d-flex flex-column h-auto justify-content-center"><a class=post-title href=https://iliubang.cn/posts/cpp/2022-04-20-c++%E4%B8%ADunique_ptr%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/>c++ 中 unique_ptr 的一些使用技巧</a><div class="post-meta mt-2"><span class=post-date>2022-04-20</span></div></div></div></li><li class=mb-2><div class=d-flex><div class="flex-grow-1 d-flex flex-column h-auto justify-content-center"><a class=post-title href=https://iliubang.cn/posts/cpp/2022-04-06-expression-templates/>Expression Templates</a><div class="post-meta mt-2"><span class=post-date>2022-04-06</span></div></div></div></li><li class=mb-2><div class=d-flex><div class="flex-grow-1 d-flex flex-column h-auto justify-content-center"><a class=post-title href=https://iliubang.cn/posts/cpp/2022-03-23-c++%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81%E5%92%8C%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81/>c++中的动态多态和静态多态</a><div class="post-meta mt-2"><span class=post-date>2022-03-23</span></div></div></div></li></ul></div></div></div></section></div><div class="accordion post-toc d-none d-lg-block"><div class="accordion-item row mb-4 card component" id=postTOC><div class="card-header accordion-header"><h2 class="card-title fs-4 my-2 text-surface d-none d-lg-block">目录</h2><a class="accordion-button d-lg-none mb-1 collapsed shadow-none p-0 bg-transparent" type=button data-bs-toggle=collapse data-bs-target=#post-toc aria-expanded=false aria-controls=post-toc>目录</a></div><div class="card-body collapse accordion-collapse accordion-body d-lg-block" id=post-toc aria-labelledby=post-toc-header><nav id=TableOfContents><ul><li><a href=#opcodes>Opcodes</a></li><li><a href=#输出-opcode>输出 Opcode</a></li><li><a href=#变量类型>变量类型</a></li><li><a href=#op-arrays>Op arrays</a></li><li><a href=#栈帧布局>栈帧布局</a></li><li><a href=#函数调用function-call>函数调用(Function call)</a></li><li><a href=#传送参数argument-sending>传送参数(Argument sending)</a></li><li><a href=#查询模式fetch-modes>查询模式(Fetch modes)</a><ul><li><a href=#writes-and-memory-safety>Writes and memory safety</a></li></ul></li><li><a href=#异常处理exception-handling>异常处理(Exception handling)</a></li><li><a href=#finally-handling>Finally handling</a></li><li><a href=#生成器-generators>生成器 (Generators)</a></li><li><a href=#smart-branches>Smart branches</a></li><li><a href=#runtime-cache>Runtime cache</a></li><li><a href=#vm-interrupts>VM interrupts</a></li><li><a href=#specialization>Specialization</a></li><li><a href=#fast-path--slow-path-split>Fast-path / slow-path split</a></li><li><a href=#vm-macros>VM macros</a></li></ul></nav></div></div></div></div></aside></div></main><footer class="footer mt-auto py-3 text-center container"><div class="offcanvas offcanvas-bottom h-auto" tabindex=-1 id=offcanvasActionsPanel aria-labelledby=offcanvasActionsPanelLabel><div class=offcanvas-header><h5 class="offcanvas-title fs-4" id=offcanvasActionsPanelLabel><i class="fas fa-fw fa-th-large me-1"></i>
操作</h5><button type=button class="btn-close ms-auto" data-bs-dismiss=offcanvas data-bs-target=offcanvasActionsPanel aria-label=Close></button></div><div class="offcanvas-body mt-2"><div class="social-share mb-4 d-flex overflow-auto"><a class="btn-social-share d-flex flex-column align-items-center me-3" rel="noopener noreferrer" aria-label="Twitter Share Button" target=_blank href="https://twitter.com/intent/tweet?title=PHP7%e8%99%9a%e6%8b%9f%e6%9c%ba&url=https%3a%2f%2filiubang.cn%2fposts%2fphp%2f2017-11-29-php7%25E8%2599%259A%25E6%258B%259F%25E6%259C%25BA%2f"><i class="fab fa-2x fa-fw fa-twitter mb-2"></i> Twitter</a>
<a class="btn-social-share d-flex flex-column align-items-center me-3" rel="noopener noreferrer" aria-label="Facebook Share Button" target=_blank href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2filiubang.cn%2fposts%2fphp%2f2017-11-29-php7%25E8%2599%259A%25E6%258B%259F%25E6%259C%25BA%2f"><i class="fab fa-2x fa-fw fa-facebook-f mb-2"></i> Facebook</a></div><hr class=mb-4><div class="actions d-flex overflow-auto align-items-center"><a role=button class="action action-go-back d-flex flex-column align-items-center me-3" href="javascript: window.history.back();"><span class="action-icon mb-2"><i class="fas fa-2x fa-chevron-circle-down" data-fa-transform=rotate-90></i></span> 返回</a>
<a role=button class="action action-reload-page d-flex flex-column align-items-center me-3"><span class="action-icon mb-2"><i class="fas fa-2x fa-redo-alt"></i></span> 刷新</a>
<a role=button class="action action-copy-url d-flex flex-column align-items-center me-3"><span class="action-icon mb-2"><i class="fas fa-2x fa-link"></i></span> 复制链接</a></div></div></div><nav class="social-links nav justify-content-center mb-2"><a class="nav-link social-link" href=mailto:it.liubang@gmail.com title=电子邮箱><i class="fas fa-fw fa-2x fa-envelope"></i></a>
<a class="nav-link social-link" target=_blank href=https://github.com/liubang title=GitHub rel="noopener noreferrer"><i class="fa-fw fa-2x fab fa-github"></i></a>
<a class="nav-link social-link" target=_blank href=https://weibo.com/2113750192 title=微博 rel="noopener noreferrer"><i class="fa-fw fa-2x fab fa-weibo"></i></a>
<a class="nav-link social-link" target=_blank href=https://iliubang.cn/index.xml title=RSS rel="noopener noreferrer"><i class="fas fa-fw fa-2x fa-rss"></i></a></nav><div class="copyright mb-2">Copyright © 2016-2022 LiuBang. All Rights Reserved.</div><div class="powered-by mb-2">Powered by <a class=text-primary href=https://gohugo.io target=_blank rel="noopener noreferrer">Hugo</a> and the <a class=text-primary href=https://github.com/razonyang/hugo-theme-bootstrap target=_blank rel="noopener noreferrer">HBS</a> theme.</div></footer><script data-precache src=https://iliubang.cn/assets/main/bundle.min.2b9e5507a187cca4ac5908baa643e4f2b2a55389677244f512437bca85e6face.js integrity="sha256-K55VB6GHzKSsWQi6pkPk8rKlU4lnckT1EkN7yoXm+s4=" crossorigin=anonymous defer></script><script data-precache src=https://iliubang.cn/assets/icons/bundle.min.4ba087d9c203230e40a605c4c44dd349f33064ce869ff4f34e2ae194ce745b74.js integrity="sha256-S6CH2cIDIw5ApgXExE3TSfMwZM6Gn/TzTirhlM50W3Q=" crossorigin=anonymous defer></script>
<script data-precache src=https://iliubang.cn/assets/viewer/bundle.min.9f713149f059d05fcb65e7f7c27308e61c384500e80ab1c333c2510a36a5d70c.js integrity="sha256-n3ExSfBZ0F/LZef3wnMI5hw4RQDoCrHDM8JRCjal1ww=" crossorigin=anonymous defer></script><script data-precache defer src=https://iliubang.cn/assets/katex/bundle.min.5d4e21071a95ce5b1f635fc99cc98e30d14b157ff223fb4f76117fdf4029c3a5.js integrity="sha256-XU4hBxqVzlsfY1/JnMmOMNFLFX/yI/tPdhF/30Apw6U=" crossorigin=anonymous></script>
<script data-precache defer src=https://iliubang.cn/assets/mermaid/bundle.min.d546bc054f132268b44126f28393917868bd737db0c64f307d29d11eaaa548d7.js integrity="sha256-1Ua8BU8TImi0QSbyg5OReGi9c32wxk8wfSnRHqqlSNc=" crossorigin=anonymous></script>
<script async src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e89c5f05bb0c6ec"></script><script>"serviceWorker"in navigator&&window.addEventListener("load",()=>{navigator.serviceWorker.register("https://iliubang.cn/service-worker.min.js").then(function(e){console.log("Successfully registered service worker",e)}).catch(function(e){console.warn("Error whilst registering service worker",e)})})</script></body></html>