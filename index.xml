<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>liubang's blog</title><link>https://iliubang.cn/</link><description>Recent content on liubang's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2016-2024 LiuBang. All Rights Reserved.</copyright><lastBuildDate>Tue, 23 May 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://iliubang.cn/index.xml" rel="self" type="application/rss+xml"/><item><title>使用LLVM的libFuzzer进行fuzzy test</title><link>https://iliubang.cn/posts/cpp/2023-05-23-%E4%BD%BF%E7%94%A8llvm%E7%9A%84libfuzzer%E8%BF%9B%E8%A1%8Cfuzzy-test/</link><pubDate>2023-05-23</pubDate><guid>https://iliubang.cn/posts/cpp/2023-05-23-%E4%BD%BF%E7%94%A8llvm%E7%9A%84libfuzzer%E8%BF%9B%E8%A1%8Cfuzzy-test/</guid><description>&lt;h2 id="libfuzzer-简介" data-numberify>libFuzzer 简介&lt;a class="anchor ms-1" href="#libfuzzer-简介">&lt;/a>&lt;/h2>
&lt;p>LLVM libFuzzer 是 LLVM 生态系统中的一个fuzzy test工具，用于自动化地发现软件程序中的漏洞和错误。它通过生成大量的随机输入数据并观察程序的行为来进行fuzzy test。
libFuzzer 是一个基于内存的fuzzy test引擎，使用 LLVM 的插桩技术和代码优化功能来提高测试效率和覆盖率。&lt;/p>
&lt;p>以下是 libFuzzer 的一些功能特点：&lt;/p>
&lt;ol>
&lt;li>自动化fuzzy test：libFuzzer 提供了一种自动化的fuzzy test方法，可以生成大量的随机输入数据，并在每个输入上运行目标函数进行测试。它通过观察程序的崩溃、断言失败、未定义行为等反馈来发现潜在的问题。&lt;/li>
&lt;li>内存安全性：libFuzzer 通过使用 AddressSanitizer (ASan) 和 UndefinedBehaviorSanitizer (UBSan) 等工具来确保fuzzy test过程中的内存安全性。这有助于检测和报告内存错误、缓冲区溢出、使用已释放内存等问题。&lt;/li>
&lt;li>代码覆盖率分析：libFuzzer 使用 LLVM 提供的代码覆盖率分析技术，帮助确定已经执行过的代码路径和未执行的代码区域。这有助于评估测试的质量和覆盖范围，并帮助发现潜在的漏洞。&lt;/li>
&lt;li>快速收敛：libFuzzer 使用一种称为 &amp;ldquo;回退&amp;rdquo;（Backoff）的策略，以更快地收敛到程序中的漏洞。它会根据测试结果调整输入数据的变异程度，使得能够更快地发现问题并生成更有潜力的测试用例。&lt;/li>
&lt;li>灵活性和可定制性：libFuzzer 提供了多种选项和配置参数，使用户能够根据自己的需求进行定制。例如，可以设置最大测试时间、内存消耗限制、覆盖率报告等。&lt;/li>
&lt;li>多线程支持：libFuzzer 支持多线程执行，可以利用多核处理器并行进行fuzzy test，加快测试速度。&lt;/li>
&lt;/ol>
&lt;h2 id="示例" data-numberify>示例&lt;a class="anchor ms-1" href="#示例">&lt;/a>&lt;/h2>
&lt;p>下面是一个使用 libFuzzer 的简单示例&lt;/p>
&lt;p>首先我们有一个 test_fuzzy.cpp:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstddef&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstdint&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">DoSomethingWithData&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">uint8_t&lt;/span>&lt;span style="color:#f92672">*&lt;/span> data, std&lt;span style="color:#f92672">::&lt;/span>size_t size) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">*&lt;/span> p &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">nullptr&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (size &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>) &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (data[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;h&amp;#39;&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> data[&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;e&amp;#39;&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> data[&lt;span style="color:#ae81ff">2&lt;/span>] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;l&amp;#39;&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> data[&lt;span style="color:#ae81ff">3&lt;/span>] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;l&amp;#39;&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> data[&lt;span style="color:#ae81ff">4&lt;/span>] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">*&lt;/span>p &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">42&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">extern&lt;/span> &lt;span style="color:#e6db74">&amp;#34;C&amp;#34;&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> LLVMFuzzerTestOneInput(&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">uint8_t&lt;/span>&lt;span style="color:#f92672">*&lt;/span> data, std&lt;span style="color:#f92672">::&lt;/span>size_t size) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DoSomethingWithData(data, size);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用 clang++进行编译：&lt;/p></description></item><item><title>322.零钱兑换</title><link>https://iliubang.cn/leetcode/dp/exercises/322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/</link><pubDate>2023-04-19</pubDate><guid>https://iliubang.cn/leetcode/dp/exercises/322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/</guid><description>&lt;h2 id="题目描述" data-numberify>题目描述&lt;a class="anchor ms-1" href="#题目描述">&lt;/a>&lt;/h2>
&lt;blockquote>
&lt;p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。
计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。
你可以认为每种硬币的数量是无限的。&lt;/p>
&lt;/blockquote>
&lt;h2 id="题解" data-numberify>题解&lt;a class="anchor ms-1" href="#题解">&lt;/a>&lt;/h2>
&lt;ol>
&lt;li>定义状态：&lt;/li>
&lt;/ol>
&lt;p>$dp[i]$表示用所给的面值的硬币凑成金额$i$所需的最少的硬币个数。&lt;/p>
&lt;ol start="2">
&lt;li>设计状态转移方程：&lt;/li>
&lt;/ol>
&lt;p>$$ \forall coin \in coins, 当 i \geqslant coin，且 dp[i - coin] \neq -1 时, dp[i] = std::min(dp[i], dp[i - coin] + 1) $$&lt;/p>
&lt;ol start="3">
&lt;li>初始化：&lt;/li>
&lt;/ol>
&lt;p>对于 amount 为 0 的情况，所需的硬币数也为 0，因此：$dp[0] = 0$&lt;/p>
&lt;ol start="4">
&lt;li>递推求解：&lt;/li>
&lt;/ol>
&lt;p>这里我们使用了一个小技巧，默认将$dp$的值都填充为&lt;code>INT_MAX&lt;/code>，这样就可以避免对&lt;code>-1&lt;/code>这个负数做特殊的判断和处理，相当于我们用&lt;code>INT_MAX&lt;/code>
来代理了&lt;code>-1&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;vector&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;climits&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> coinChange(&lt;span style="color:#66d9ef">const&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> coins, &lt;span style="color:#66d9ef">int&lt;/span> amount) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> dp(amount &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, INT_MAX);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dp[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> amount; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> coin : coins) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (coin &lt;span style="color:#f92672">&amp;lt;=&lt;/span> i &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> dp[i &lt;span style="color:#f92672">-&lt;/span> coin] &lt;span style="color:#f92672">!=&lt;/span> INT_MAX) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dp[i] &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>min(dp[i], dp[i &lt;span style="color:#f92672">-&lt;/span> coin] &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> dp[amount] &lt;span style="color:#f92672">==&lt;/span> INT_MAX &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">:&lt;/span> dp[amount];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>70.爬楼梯</title><link>https://iliubang.cn/leetcode/dp/exercises/70.%E7%88%AC%E6%A5%BC%E6%A2%AF/</link><pubDate>2023-04-19</pubDate><guid>https://iliubang.cn/leetcode/dp/exercises/70.%E7%88%AC%E6%A5%BC%E6%A2%AF/</guid><description>&lt;h2 id="题目描述" data-numberify>题目描述&lt;a class="anchor ms-1" href="#题目描述">&lt;/a>&lt;/h2>
&lt;blockquote>
&lt;p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？&lt;/p>
&lt;/blockquote>
&lt;h2 id="题解" data-numberify>题解&lt;a class="anchor ms-1" href="#题解">&lt;/a>&lt;/h2>
&lt;p>这道题是一个非常典型而且很简单的动态规划题目。我们可以根据动态规划题目解题的一般思路来分析：&lt;/p>
&lt;ol>
&lt;li>定义状态：&lt;/li>
&lt;/ol>
&lt;p>$dp[i]$表示爬到第$i$级楼梯的不同方法数。由于每次可以选择爬 $1$ 级或者 $2$ 级楼梯，
所以爬到第 $i$ 级楼梯的方法数等于爬到第 $i-1$ 级楼梯和第 $i-2$ 级楼梯的方法数之和。
根据这个关系，我们可以使用动态规划的方式从 $1$ 级楼梯开始逐步计算到第 $n$ 级楼梯的方法数，最终返回 $dp[n]$即为结果。&lt;/p>
&lt;ol start="2">
&lt;li>设计状态转移方程：&lt;/li>
&lt;/ol>
&lt;p>$$dp[i] = dp[i - 1] + dp[i - 2]$$&lt;/p>
&lt;ol start="3">
&lt;li>初始化：&lt;/li>
&lt;/ol>
&lt;p>由题目可知，$dp[0] = 0$; $dp[1] = 1$，这里需要特别注意的是，$dp[2] \ne dp[0] + dp[1]$，而是$dp[2] = 2$，所以$dp[2]$也应该作为初始值&lt;/p>
&lt;ol start="4">
&lt;li>递推求解：&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;vector&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> climbStairs(&lt;span style="color:#66d9ef">int&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (n &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>) &lt;span style="color:#66d9ef">return&lt;/span> n;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> dp(n &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dp[&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dp[&lt;span style="color:#ae81ff">2&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dp[i] &lt;span style="color:#f92672">=&lt;/span> dp[i &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">+&lt;/span> dp[i &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> dp[n];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="5">
&lt;li>记忆优化：&lt;/li>
&lt;/ol>
&lt;p>从上面代码可以很容易发现，我们得出$dp[i]$只需要用到$dp[i - 1]$和$dp[i -2]$，其他的元素其实都用不到，所以上面的代码可以优化为：&lt;/p></description></item><item><title>416.分割等和子集</title><link>https://iliubang.cn/leetcode/dp/exercises/416/</link><pubDate>2023-04-16</pubDate><guid>https://iliubang.cn/leetcode/dp/exercises/416/</guid><description>&lt;h2 id="题目描述" data-numberify>题目描述&lt;a class="anchor ms-1" href="#题目描述">&lt;/a>&lt;/h2>
&lt;blockquote>
&lt;p>给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。&lt;/p>
&lt;/blockquote>
&lt;h2 id="题解" data-numberify>题解&lt;a class="anchor ms-1" href="#题解">&lt;/a>&lt;/h2>
&lt;p>由题可知，数组&lt;code>nums&lt;/code>非空，所以分割后的两个子集也必然非空，由于都是正整数，所以&lt;code>nums&lt;/code>中元素之和必然为偶数。&lt;/p>
&lt;p>这道题是典型的 01 背包问题，假设$dp[i][j]$表示&lt;code>nums&lt;/code>中前$i$个元素是否包含和为$j$的子集，那么：&lt;/p>
&lt;ol>
&lt;li>当&lt;code>nums[i] = j&lt;/code>的时候，&lt;code>dp[i][j] = true&lt;/code>&lt;/li>
&lt;li>当&lt;code>nums[i] &amp;gt; j&lt;/code>的时候，&lt;code>dp[i][j] = dp[i - 1][j]&lt;/code>&lt;/li>
&lt;li>当&lt;code>nums[i] &amp;lt; j&lt;/code>的时候，&lt;code>dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]]&lt;/code>&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;vector&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;numeric&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> canPartition(&lt;span style="color:#66d9ef">const&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> nums) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> size &lt;span style="color:#f92672">=&lt;/span> nums.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> sum &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>accumulate(nums.begin(), nums.end(), &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (size &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">||&lt;/span> (sum &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#66d9ef">return&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> target &lt;span style="color:#f92672">=&lt;/span> sum &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">bool&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> dp(size &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">bool&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>(target &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> size; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; j &lt;span style="color:#f92672">&amp;lt;=&lt;/span> target; &lt;span style="color:#f92672">++&lt;/span>j) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> num &lt;span style="color:#f92672">=&lt;/span> nums[i &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (num &lt;span style="color:#f92672">==&lt;/span> j) dp[i][j] &lt;span style="color:#f92672">=&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#a6e22e">if&lt;/span> (num &lt;span style="color:#f92672">&amp;gt;&lt;/span> j) dp[i][j] &lt;span style="color:#f92672">=&lt;/span> dp[i &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>][j];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> dp[i][j] &lt;span style="color:#f92672">=&lt;/span> dp[i &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>][j] &lt;span style="color:#f92672">|&lt;/span> dp[i &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>][j &lt;span style="color:#f92672">-&lt;/span> num];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> dp[size][target];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>155.最小栈</title><link>https://iliubang.cn/leetcode/stack/exercises/155/</link><pubDate>2022-12-06</pubDate><guid>https://iliubang.cn/leetcode/stack/exercises/155/</guid><description>&lt;h2 id="题目描述" data-numberify>题目描述&lt;a class="anchor ms-1" href="#题目描述">&lt;/a>&lt;/h2>
&lt;blockquote>
&lt;p>设计一个支持 &lt;code>push&lt;/code> ，&lt;code>pop&lt;/code> ，&lt;code>top&lt;/code> 操作，并能在常数时间内检索到最小元素的栈。
实现 &lt;code>MinStack&lt;/code> 类:
&lt;code>MinStack()&lt;/code> 初始化
&lt;code>void push(int val)&lt;/code> 将元素推入堆栈
&lt;code>void pop()&lt;/code> 删除堆栈顶部的元素
&lt;code>int pop()&lt;/code> 获取堆栈顶部的元素
&lt;code>int getMin()&lt;/code> 获取堆栈中的最小元素&lt;/p>
&lt;/blockquote>
&lt;h2 id="题解" data-numberify>题解：&lt;a class="anchor ms-1" href="#题解">&lt;/a>&lt;/h2>
&lt;p>这道题首先要满足堆栈的特性 LIFO，其次是能够在常数时间内获取当前栈中最小的元素，因此我们可以用堆栈保存
个二元组，二元组的第一个元素是存入栈中的值，第二个元素是当前元素作为栈顶元素的时候，栈中的最小值。有
了这个思路，代码实现起来就很简单了。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MinStack&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MinStack() &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">default&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">push&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> val) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack_.emplace(val, std&lt;span style="color:#f92672">::&lt;/span>min(val, getMin()));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">pop&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack_.pop();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">top&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> stack_.top().first;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">getMin&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (stack_.empty()) &lt;span style="color:#66d9ef">return&lt;/span> INT_MAX;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> stack_.top().second;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>stack&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>pair&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> stack_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>84. 柱状图中最大的矩形</title><link>https://iliubang.cn/leetcode/stack/exercises/84/</link><pubDate>2022-12-06</pubDate><guid>https://iliubang.cn/leetcode/stack/exercises/84/</guid><description>&lt;h2 id="题目描述" data-numberify>题目描述&lt;a class="anchor ms-1" href="#题目描述">&lt;/a>&lt;/h2>
&lt;blockquote>
&lt;p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。
求在该柱状图中，能够勾勒出来的矩形的最大面积。&lt;/p>
&lt;/blockquote>
&lt;h2 id="解法一暴力求解" data-numberify>解法一：暴力求解&lt;a class="anchor ms-1" href="#解法一暴力求解">&lt;/a>&lt;/h2>
&lt;p>主要思路是，遍历每个柱子，然后往柱子左右两边寻找比当前柱子矮的位置，从而计算出，以当前柱子为高度，所能围成的最大面积。
然后将这些面积中最大的值返回即可。暴力求解的时间复杂度为&lt;code>O(n^2)&lt;/code>&lt;/p>
&lt;p>不过我尝试过各种暴力求解，在 leetcode 中提交后都会超时。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> largestRectangleInHistogram(&lt;span style="color:#66d9ef">const&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> inputs) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>size_t n &lt;span style="color:#f92672">=&lt;/span> inputs.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> max_area &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> min_height &lt;span style="color:#f92672">=&lt;/span> INT_MAX;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> i; j &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span>j) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> min_height &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>min(min_height, inputs[j]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> max_area &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>max(max_area, min_height &lt;span style="color:#f92672">*&lt;/span> (j &lt;span style="color:#f92672">-&lt;/span> i &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> max_area;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;h2 id="解法二单调栈" data-numberify>解法二：单调栈&lt;a class="anchor ms-1" href="#解法二单调栈">&lt;/a>&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> largestRectangleInHistogram(&lt;span style="color:#66d9ef">const&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> inputs) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> inputs.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>stack&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> stk;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> ret &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>stk.empty() &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> inputs[stk.top()] &lt;span style="color:#f92672">&amp;gt;&lt;/span> inputs[i]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> w &lt;span style="color:#f92672">=&lt;/span> i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> h &lt;span style="color:#f92672">=&lt;/span> inputs[stk.top()];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stk.pop();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>stk.empty()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> w &lt;span style="color:#f92672">=&lt;/span> i &lt;span style="color:#f92672">-&lt;/span> stk.top() &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ret &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>max(ret, w &lt;span style="color:#f92672">*&lt;/span> h);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stk.push(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>stk.empty()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> w &lt;span style="color:#f92672">=&lt;/span> n;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> h &lt;span style="color:#f92672">=&lt;/span> inputs[stk.top()];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stk.pop();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>stk.empty()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> w &lt;span style="color:#f92672">=&lt;/span> n &lt;span style="color:#f92672">-&lt;/span> stk.top() &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ret &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>max(ret, w &lt;span style="color:#f92672">*&lt;/span> h);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ret;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>141.环形链表</title><link>https://iliubang.cn/leetcode/linkedlist/exercises/141/</link><pubDate>2022-11-30</pubDate><guid>https://iliubang.cn/leetcode/linkedlist/exercises/141/</guid><description>&lt;h2 id="题目描述" data-numberify>题目描述&lt;a class="anchor ms-1" href="#题目描述">&lt;/a>&lt;/h2>
&lt;blockquote>
&lt;p>给你一个链表的头节点 head ，判断链表中是否有环。
如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。
如果链表中存在环 ，则返回 true 。 否则，返回 false 。&lt;/p>
&lt;/blockquote>
&lt;h2 id="解法一hash-法" data-numberify>解法一：hash 法&lt;a class="anchor ms-1" href="#解法一hash-法">&lt;/a>&lt;/h2>
&lt;p>hash 法是我们在判断重复元素类问题中最常用的方法。针对链表是否有环来说，我们可以遍历链表，并用&lt;code>std::set&lt;/code>
存放遍历过的元素，判断是否存在重复元素，如果存在则表示有环，如果遍历结束且不存在重复，则没有环。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> hasCycle(ListNode&lt;span style="color:#f92672">*&lt;/span> head) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>set&lt;span style="color:#f92672">&amp;lt;&lt;/span>ListNode&lt;span style="color:#f92672">*&amp;gt;&lt;/span> set;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ListNode&lt;span style="color:#f92672">*&lt;/span> cur &lt;span style="color:#f92672">=&lt;/span> head;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (cur) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (set.count(cur) &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#66d9ef">return&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> set.insert(cur);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cur &lt;span style="color:#f92672">=&lt;/span> cur&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;h2 id="解法二快慢指针" data-numberify>解法二：快慢指针&lt;a class="anchor ms-1" href="#解法二快慢指针">&lt;/a>&lt;/h2>
&lt;p>快慢指针就是用两个指针，一个一次移动一个位置，另一个一次移动两个位置，如果链表存在环，那么快的指针一定会
在某个地方和慢的指针重合，这个思路虽然很简单，但是具体的编码还是要多练习，不然也容易出错。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> hasCycle(ListNode&lt;span style="color:#f92672">*&lt;/span> head) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>head) &lt;span style="color:#66d9ef">return&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ListNode&lt;span style="color:#f92672">*&lt;/span> slow &lt;span style="color:#f92672">=&lt;/span> head;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ListNode&lt;span style="color:#f92672">*&lt;/span> fast &lt;span style="color:#f92672">=&lt;/span> head&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (fast) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (fast &lt;span style="color:#f92672">==&lt;/span> slow) &lt;span style="color:#66d9ef">return&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>fast&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next) &lt;span style="color:#66d9ef">return&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> slow &lt;span style="color:#f92672">=&lt;/span> slow&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fast &lt;span style="color:#f92672">=&lt;/span> fast&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>20.有效的括号</title><link>https://iliubang.cn/leetcode/stack/exercises/20/</link><pubDate>2022-11-30</pubDate><guid>https://iliubang.cn/leetcode/stack/exercises/20/</guid><description>&lt;h2 id="题目描述" data-numberify>题目描述&lt;a class="anchor ms-1" href="#题目描述">&lt;/a>&lt;/h2>
&lt;blockquote>
&lt;p>给定一个只包括 &amp;lsquo;(&amp;rsquo;，&amp;rsquo;)&amp;rsquo;，&amp;rsquo;{&amp;rsquo;，&amp;rsquo;}&amp;rsquo;，&amp;rsquo;[&amp;rsquo;，&amp;rsquo;]&amp;rsquo; 的字符串 s ，判断字符串是否有效。
有效字符串需满足：
左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
每个右括号都有一个对应的相同类型的左括号。&lt;/p>
&lt;/blockquote>
&lt;h2 id="解法一stack" data-numberify>解法一：stack&lt;a class="anchor ms-1" href="#解法一stack">&lt;/a>&lt;/h2>
&lt;p>这道题目是典型的堆栈数据结构的应用，虽然思路很清晰，代码也很简单，但是要注意逻辑的严谨性。尤其是在判断
栈顶元素是否匹配之前，要先判断栈是否为空。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> isValid(&lt;span style="color:#66d9ef">const&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>string&lt;span style="color:#f92672">&amp;amp;&lt;/span> s) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>stack&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> st;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> s.length(); &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span> c &lt;span style="color:#f92672">=&lt;/span> s[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (c &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;(&amp;#39;&lt;/span> &lt;span style="color:#f92672">||&lt;/span> c &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;{&amp;#39;&lt;/span> &lt;span style="color:#f92672">||&lt;/span> c &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;[&amp;#39;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> st.push(c);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (st.empty()) &lt;span style="color:#66d9ef">return&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (c &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;)&amp;#39;&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> st.top() &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;(&amp;#39;&lt;/span>) &lt;span style="color:#66d9ef">return&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (c &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;}&amp;#39;&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> st.top() &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;{&amp;#39;&lt;/span>) &lt;span style="color:#66d9ef">return&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (c &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;]&amp;#39;&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> st.top() &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;[&amp;#39;&lt;/span>) &lt;span style="color:#66d9ef">return&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> st.pop();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> st.empty();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>206.反转链表</title><link>https://iliubang.cn/leetcode/linkedlist/exercises/206/</link><pubDate>2022-11-30</pubDate><guid>https://iliubang.cn/leetcode/linkedlist/exercises/206/</guid><description>&lt;h2 id="题目描述" data-numberify>题目描述&lt;a class="anchor ms-1" href="#题目描述">&lt;/a>&lt;/h2>
&lt;blockquote>
&lt;p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。&lt;/p>
&lt;/blockquote>
&lt;h2 id="解法一迭代" data-numberify>解法一：迭代&lt;a class="anchor ms-1" href="#解法一迭代">&lt;/a>&lt;/h2>
&lt;p>迭代法应该是我们最容易想到的常规方法，也比较符合人的思维逻辑。其核心思想就是通过两个指针移动，来
一个一个的修改链表的指向方向。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ListNode&lt;span style="color:#f92672">*&lt;/span> reverseList(ListNode&lt;span style="color:#f92672">*&lt;/span> head) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>head &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#f92672">!&lt;/span>head&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next) &lt;span style="color:#66d9ef">return&lt;/span> head;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ListNode&lt;span style="color:#f92672">*&lt;/span> prev &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">nullptr&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ListNode&lt;span style="color:#f92672">*&lt;/span> cur &lt;span style="color:#f92672">=&lt;/span> head;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (cur) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ListNode&lt;span style="color:#f92672">*&lt;/span> tmp &lt;span style="color:#f92672">=&lt;/span> cur&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cur&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next &lt;span style="color:#f92672">=&lt;/span> prev;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> prev &lt;span style="color:#f92672">=&lt;/span> cur;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cur &lt;span style="color:#f92672">=&lt;/span> tmp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> prev;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;h2 id="解法二递归" data-numberify>解法二：递归&lt;a class="anchor ms-1" href="#解法二递归">&lt;/a>&lt;/h2>
&lt;p>第二个方法就是使用递归，递归这种方法虽然不太容易能够想到，但是代码却很简洁。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ListNode&lt;span style="color:#f92672">*&lt;/span> reverseList(ListNode&lt;span style="color:#f92672">*&lt;/span> head) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>head &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#f92672">!&lt;/span>head&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next) &lt;span style="color:#66d9ef">return&lt;/span> head;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ListNode&lt;span style="color:#f92672">*&lt;/span> newHead &lt;span style="color:#f92672">=&lt;/span> reverseList(head&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> head&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next &lt;span style="color:#f92672">=&lt;/span> head;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> head&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">nullptr&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> newHead;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>225.用队列实现栈</title><link>https://iliubang.cn/leetcode/queue/exercises/225/</link><pubDate>2022-11-30</pubDate><guid>https://iliubang.cn/leetcode/queue/exercises/225/</guid><description>&lt;h2 id="题目描述" data-numberify>题目描述&lt;a class="anchor ms-1" href="#题目描述">&lt;/a>&lt;/h2>
&lt;blockquote>
&lt;p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。&lt;/p>
&lt;p>实现 MyStack 类：&lt;/p>
&lt;ul>
&lt;li>void push(int x) 将元素 x 压入栈顶。&lt;/li>
&lt;li>int pop() 移除并返回栈顶元素。&lt;/li>
&lt;li>int top() 返回栈顶元素。&lt;/li>
&lt;li>boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。&lt;/li>
&lt;/ul>
&lt;p>注意：&lt;/p>
&lt;p>你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。
你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。&lt;/p>
&lt;/blockquote>
&lt;h2 id="题解" data-numberify>题解&lt;a class="anchor ms-1" href="#题解">&lt;/a>&lt;/h2>
&lt;p>队列是 FIFO 的，而堆栈是 LIFO，要想用队列模拟堆栈，就需要在取出元素的时候，将一个队列中的除了最后一个元素的其他移动到另一个队列中，然后返回最后一个元素即可。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyStack&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MyStack() &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">default&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">push&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> x) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> q &lt;span style="color:#f92672">=&lt;/span> q1_.size() &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">:&lt;/span> q1_ &lt;span style="color:#f92672">?&lt;/span> q2_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> q.push(x);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">pop&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>queue&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> q1_.size() &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">?&lt;/span> q1_ : q2_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>queue&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> o &lt;span style="color:#f92672">=&lt;/span> q1_.size() &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">?&lt;/span> q2_ : q1_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (i.size() &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> o.push(i.front());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i.pop();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> ret &lt;span style="color:#f92672">=&lt;/span> i.front();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i.pop();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ret;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">top&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>queue&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> q1_.size() &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">?&lt;/span> q1_ : q2_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>queue&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> o &lt;span style="color:#f92672">=&lt;/span> q1_.size() &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">?&lt;/span> q2_ : q1_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (i.size() &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> o.push(i.front());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i.pop();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> ret &lt;span style="color:#f92672">=&lt;/span> i.front();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i.pop();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> o.push(ret);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ret;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">empty&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> q1_.empty() &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> q2_.empty();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>queue&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> q1_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>queue&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> q2_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>232.用栈实现队列</title><link>https://iliubang.cn/leetcode/stack/exercises/232/</link><pubDate>2022-11-30</pubDate><guid>https://iliubang.cn/leetcode/stack/exercises/232/</guid><description>&lt;h2 id="题目描述" data-numberify>题目描述&lt;a class="anchor ms-1" href="#题目描述">&lt;/a>&lt;/h2>
&lt;blockquote>
&lt;p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：
实现 MyQueue 类：&lt;/p>
&lt;ul>
&lt;li>void push(int x) 将元素 x 推到队列的末尾&lt;/li>
&lt;li>int pop() 从队列的开头移除并返回元素&lt;/li>
&lt;li>int peek() 返回队列开头的元素&lt;/li>
&lt;li>boolean empty() 如果队列为空，返回 true ；否则，返回 false&lt;/li>
&lt;/ul>
&lt;p>说明：
你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。
你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。&lt;/p>
&lt;/blockquote>
&lt;h2 id="题解" data-numberify>题解&lt;a class="anchor ms-1" href="#题解">&lt;/a>&lt;/h2>
&lt;p>堆栈的特性是 LIFO，而队列则是 FIFO，因此想要用堆栈实现队列，需要用两个堆栈的 LIFO 叠加效果，来实现 FIFO。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyQueue&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MyQueue() &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">default&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">push&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> x) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>output_.empty()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> input_.push(output_.top());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> output_.pop();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> input_.push(x);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">pop&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>input_.empty()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> output_.push(input_.top());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> input_.pop();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> ret &lt;span style="color:#f92672">=&lt;/span> output_.top();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> output_.pop();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ret;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">peek&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>input_.empty()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> output_.push(input_.top());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> input_.pop();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> output_.top();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">empty&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> input_.empty() &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> output_.empty();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>stack&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> input_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>stack&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> output_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>24.两两交换链表中的节点</title><link>https://iliubang.cn/leetcode/linkedlist/exercises/24/</link><pubDate>2022-11-30</pubDate><guid>https://iliubang.cn/leetcode/linkedlist/exercises/24/</guid><description>&lt;h2 id="题目描述" data-numberify>题目描述&lt;a class="anchor ms-1" href="#题目描述">&lt;/a>&lt;/h2>
&lt;blockquote>
&lt;p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。&lt;/p>
&lt;/blockquote>
&lt;h2 id="方法一递归" data-numberify>方法一：递归&lt;a class="anchor ms-1" href="#方法一递归">&lt;/a>&lt;/h2>
&lt;p>这道题，最最简洁的方法应该就是使用递归了。主要思路是，每两个一组，进行交换，然后递归执行。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LinkedList&lt;span style="color:#f92672">*&lt;/span> swapPairs(LinkedList&lt;span style="color:#f92672">*&lt;/span> head) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>head &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#f92672">!&lt;/span>head&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next) &lt;span style="color:#66d9ef">return&lt;/span> head;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 当前组下的新的head
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> LinkedList&lt;span style="color:#f92672">*&lt;/span> newHead &lt;span style="color:#f92672">=&lt;/span> head&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> head&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next &lt;span style="color:#f92672">=&lt;/span> swapPairs(newHead&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> newHead&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next &lt;span style="color:#f92672">=&lt;/span> head;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> newHead;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Rust和C++: 泛型和特例化</title><link>https://iliubang.cn/posts/rust/2022-11-13-rust%E5%92%8Cc++%E5%AF%B9%E6%AF%94%E4%B9%8B%E6%B3%9B%E5%9E%8B%E5%92%8C%E7%89%B9%E4%BE%8B%E5%8C%96/</link><pubDate>2022-11-12</pubDate><guid>https://iliubang.cn/posts/rust/2022-11-13-rust%E5%92%8Cc++%E5%AF%B9%E6%AF%94%E4%B9%8B%E6%B3%9B%E5%9E%8B%E5%92%8C%E7%89%B9%E4%BE%8B%E5%8C%96/</guid><description>&lt;blockquote>
&lt;p>Ref: &lt;a href="https://www.tangramvision.com/blog/c-rust-generics-and-specialization" target="_blank" rel="noopener noreferrer">https://www.tangramvision.com/blog/c-rust-generics-and-specialization&lt;i class="fas fa-external-link-square-alt ms-1">&lt;/i>&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="泛型入门输入的类型" data-numberify>泛型入门：输入的类型&lt;a class="anchor ms-1" href="#泛型入门输入的类型">&lt;/a>&lt;/h2>
&lt;p>C++和 Rust 中的泛型都是一种将其他类型作为其定义的一部分的类型。泛型是通过在类型定义中指定占位符的一种方式，然后可以
使用更具体的类型来替换，例如在 C++中可以这定义一个泛型类型：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">MyArray&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> T&lt;span style="color:#f92672">*&lt;/span> raw_array;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>size_t size;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对于这个泛型结构而言，&lt;code>MyArray&amp;lt;int&amp;gt;&lt;/code>和&lt;code>MyArray&amp;lt;std::string&amp;gt;&lt;/code>是不同的类型。我们可以通过指定具体的&lt;code>T&lt;/code>类型，来复用&lt;code>MyArray&lt;/code>这个泛型结构体。这里的&lt;code>MyArray&amp;lt;T&amp;gt;&lt;/code>就像一个“模板”一样。
泛型不仅仅局限于结构体，我们同样也能写出泛型函数：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>T timestwo(T number) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> number &lt;span style="color:#f92672">+&lt;/span> number;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面我们定义了一个非常简单的函数，用来将数值加倍。同理，用具体类型实例化的&lt;code>timestwo&amp;lt;int&amp;gt;&lt;/code>和&lt;code>timestwo&amp;lt;double&amp;gt;&lt;/code>也不是同一个函数。&lt;/p>
&lt;p>而要在 Rust 中实现上面的函数，可能稍微复杂一点：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">use&lt;/span> std::ops::Add;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">timestwo&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span>(number: &lt;span style="color:#a6e22e">T&lt;/span>) -&amp;gt; &lt;span style="color:#f92672">&amp;lt;&lt;/span>T &lt;span style="color:#66d9ef">as&lt;/span> Add&lt;span style="color:#f92672">&amp;gt;&lt;/span>::Output
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">where&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> T: &lt;span style="color:#a6e22e">Add&lt;/span> &lt;span style="color:#f92672">+&lt;/span> Copy,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> number &lt;span style="color:#f92672">+&lt;/span> number
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>很显然，上面 Rust 版本和 C++版本的实现相比看上去多了很多额外的语法。其中主要的区别是我们调用了特征边界检查，也就是&lt;code>T: Add + Copy&lt;/code>，
或者用更通俗的话来说，&lt;code>T&lt;/code>类型必须实现&lt;code>Add&lt;/code>和&lt;code>Copy&lt;/code> 特征(trait)。&lt;/p>
&lt;h3 id="特征traits" data-numberify>特征(traits)&lt;a class="anchor ms-1" href="#特征traits">&lt;/a>&lt;/h3>
&lt;p>Rust 中使用&lt;code>trait&lt;/code>作为我们在程序中与类型交互的方式。&lt;code>trait&lt;/code>是与实现&lt;code>trait&lt;/code>的类型相关联的一组属性、函数或者类型。例如
&lt;code>Add&lt;/code> 是一个允许执行添加操作的接口。它表示一个类型具有“添加”到其他类型的特征。其定义大致如下：&lt;/p></description></item><item><title>130.被围绕的区域</title><link>https://iliubang.cn/leetcode/union-find/exercises/130/</link><pubDate>2022-11-07</pubDate><guid>https://iliubang.cn/leetcode/union-find/exercises/130/</guid><description>&lt;h2 id="题目描述" data-numberify>题目描述&lt;a class="anchor ms-1" href="#题目描述">&lt;/a>&lt;/h2>
&lt;blockquote>
&lt;p>给你一个 &lt;code>m x n&lt;/code> 的矩阵 &lt;code>board&lt;/code> ，由若干字符 &amp;lsquo;X&amp;rsquo; 和 &amp;lsquo;O&amp;rsquo; ，找到所有被 &amp;lsquo;X&amp;rsquo; 围绕的区域，并将这些区域里所有的 &amp;lsquo;O&amp;rsquo; 用 &amp;lsquo;X&amp;rsquo; 填充。&lt;/p>
&lt;/blockquote>
&lt;h2 id="解法一并查集" data-numberify>解法一：并查集&lt;a class="anchor ms-1" href="#解法一并查集">&lt;/a>&lt;/h2>
&lt;p>这道题通常会用DFS来解，但是也可以用并查集解：首先我们将四条边上的&amp;rsquo;O&amp;rsquo;合并成一个连通分量，然后再将圈内的所有相邻的
&amp;lsquo;O&amp;rsquo;连接起来，最后遍历整个表，将所有为&amp;rsquo;O&amp;rsquo;且不与四条边上的&amp;rsquo;O&amp;rsquo;所在的连通分量相连的节点设置为&amp;rsquo;X&amp;rsquo;即可。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;vector&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;unordered_map&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">UnionFind&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> UnionFind(&lt;span style="color:#66d9ef">int&lt;/span> num) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> num; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parent_.push_back(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">unite&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> p, &lt;span style="color:#66d9ef">int&lt;/span> q) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> pRoot &lt;span style="color:#f92672">=&lt;/span> find(p);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> qRoot &lt;span style="color:#f92672">=&lt;/span> find(q);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (pRoot &lt;span style="color:#f92672">==&lt;/span> qRoot) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parent_[pRoot] &lt;span style="color:#f92672">=&lt;/span> qRoot;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">connected&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> p, &lt;span style="color:#66d9ef">int&lt;/span> q) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> find(p) &lt;span style="color:#f92672">==&lt;/span> find(q);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">find&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> p) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (p &lt;span style="color:#f92672">!=&lt;/span> parent_[p]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parent_[p] &lt;span style="color:#f92672">=&lt;/span> find(parent_[p]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> parent_[p];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> parent_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> solve(std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;amp;&lt;/span> board) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> m &lt;span style="color:#f92672">=&lt;/span> board.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> board[&lt;span style="color:#ae81ff">0&lt;/span>].size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> UnionFind &lt;span style="color:#a6e22e">uf&lt;/span>(m &lt;span style="color:#f92672">*&lt;/span> n &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> dummy &lt;span style="color:#f92672">=&lt;/span> m &lt;span style="color:#f92672">*&lt;/span> n;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 先将四条边上为&amp;#39;O&amp;#39;的节点连接起来
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> m; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (board[i][&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;O&amp;#39;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uf.unite(dummy, i &lt;span style="color:#f92672">*&lt;/span> n);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (board[i][n &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;O&amp;#39;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uf.unite(dummy, i &lt;span style="color:#f92672">*&lt;/span> n &lt;span style="color:#f92672">+&lt;/span> n &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; j &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span>j) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (board[&lt;span style="color:#ae81ff">0&lt;/span>][j] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;O&amp;#39;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uf.unite(dummy, j);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (board[m &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>][j] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;O&amp;#39;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uf.unite(dummy, (m &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> n &lt;span style="color:#f92672">+&lt;/span> j);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 再将内部相邻的&amp;#39;O&amp;#39;连接起来
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 上 下 左 右
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> directions &lt;span style="color:#f92672">=&lt;/span> {{&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>}, {&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>}, {&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>}, {&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>}};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> m &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; j &lt;span style="color:#f92672">&amp;lt;&lt;/span> n &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#f92672">++&lt;/span>j) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (board[i][j] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;X&amp;#39;&lt;/span>) &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">auto&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> dir : directions) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (board[i &lt;span style="color:#f92672">+&lt;/span> dir[&lt;span style="color:#ae81ff">0&lt;/span>]][j &lt;span style="color:#f92672">+&lt;/span> dir[&lt;span style="color:#ae81ff">1&lt;/span>]] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;X&amp;#39;&lt;/span>) &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uf.unite(n &lt;span style="color:#f92672">*&lt;/span> i &lt;span style="color:#f92672">+&lt;/span> j, n &lt;span style="color:#f92672">*&lt;/span> (i &lt;span style="color:#f92672">+&lt;/span> dir[&lt;span style="color:#ae81ff">0&lt;/span>]) &lt;span style="color:#f92672">+&lt;/span> j &lt;span style="color:#f92672">+&lt;/span> dir[&lt;span style="color:#ae81ff">1&lt;/span>]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 最后将所有不与dummy连通的&amp;#39;O&amp;#39;设置为&amp;#39;X&amp;#39;即可
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> m; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; j &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span>j) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (board[i][j] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;O&amp;#39;&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>uf.connected(dummy, n &lt;span style="color:#f92672">*&lt;/span> i &lt;span style="color:#f92672">+&lt;/span> j)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> board[i][j] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;X&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>990.等式方程的可满足性</title><link>https://iliubang.cn/leetcode/union-find/exercises/990/</link><pubDate>2022-11-06</pubDate><guid>https://iliubang.cn/leetcode/union-find/exercises/990/</guid><description>&lt;h2 id="题目描述" data-numberify>题目描述&lt;a class="anchor ms-1" href="#题目描述">&lt;/a>&lt;/h2>
&lt;blockquote>
&lt;p>给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程&lt;code>equations[i]&lt;/code>的长度为 4，并采用两种不同的形式之一：&lt;code>&amp;quot;a==b&amp;quot;&lt;/code> 或 &lt;code>&amp;quot;a!=b&amp;quot;&lt;/code>。在这里，&lt;code>a&lt;/code> 和 &lt;code>b&lt;/code> 是小写字母（不一定不同），表示单字母变量名。
只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 &lt;code>true&lt;/code>，否则返回 &lt;code>false&lt;/code>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="题解" data-numberify>题解&lt;a class="anchor ms-1" href="#题解">&lt;/a>&lt;/h2>
&lt;p>这一道题，显然是用并查集来解决，思路很简单，由于相等具有传递性，可以认为，一开始所有的字母变量都是独立的
集合，通过等式传递性，可以将这些相等的字母合并到同一个集合，最后看不等式中，是否存在连通的字母，如果存在
则表示等式方程不满足条件。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;vector&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;unordered_map&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">UnionFind&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> UnionFind(&lt;span style="color:#66d9ef">int&lt;/span> num) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> num; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parent_.push_back(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">unite&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> p, &lt;span style="color:#66d9ef">int&lt;/span> q) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> pRoot &lt;span style="color:#f92672">=&lt;/span> find(p);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> qRoot &lt;span style="color:#f92672">=&lt;/span> find(q);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (pRoot &lt;span style="color:#f92672">==&lt;/span> qRoot) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parent_[pRoot] &lt;span style="color:#f92672">=&lt;/span> qRoot;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">find&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> p) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (p &lt;span style="color:#f92672">!=&lt;/span> parent_[p]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parent_[p] &lt;span style="color:#f92672">=&lt;/span> find(parent_[p]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> parent_[p];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> parent_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> equationsPossible(&lt;span style="color:#66d9ef">const&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>string&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> equations) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 26个小写字母
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> UnionFind &lt;span style="color:#a6e22e">uf&lt;/span>(&lt;span style="color:#ae81ff">26&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">auto&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> e : equations) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (e[&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;!&amp;#39;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uf.unite(e[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#e6db74">&amp;#39;a&amp;#39;&lt;/span>, e[&lt;span style="color:#ae81ff">3&lt;/span>] &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#e6db74">&amp;#39;a&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">auto&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> e : equations) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (e[&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;=&amp;#39;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (uf.find(e[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#e6db74">&amp;#39;a&amp;#39;&lt;/span>) &lt;span style="color:#f92672">==&lt;/span> uf.find(e[&lt;span style="color:#ae81ff">3&lt;/span>] &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#e6db74">&amp;#39;a&amp;#39;&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>128.最长连续序列</title><link>https://iliubang.cn/leetcode/union-find/exercises/128/</link><pubDate>2022-11-05</pubDate><guid>https://iliubang.cn/leetcode/union-find/exercises/128/</guid><description>&lt;h2 id="题目描述" data-numberify>题目描述&lt;a class="anchor ms-1" href="#题目描述">&lt;/a>&lt;/h2>
&lt;blockquote>
&lt;p>给定一个未排序的整数数&lt;code>nums&lt;/code>，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。
请你设计并实现时间复杂度&lt;code>O(n)&lt;/code>的算法解决此问题。&lt;/p>
&lt;/blockquote>
&lt;h2 id="解法一并查集" data-numberify>解法一：并查集&lt;a class="anchor ms-1" href="#解法一并查集">&lt;/a>&lt;/h2>
&lt;p>这道题目可以用并查集来解决。初始状态下数组中的每个元素都是一个独立的集合，然后遍历数组，将当前元素相邻的
元素合并到一个集合，最后返回所有集合中元素个数最多的数量。这里要注意去重。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;vector&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;unordered_map&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">UnionFind&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> UnionFind(&lt;span style="color:#66d9ef">int&lt;/span> num) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> num; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parent_.push_back(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size_.push_back(&lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">unite&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> p, &lt;span style="color:#66d9ef">int&lt;/span> q) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> pRoot &lt;span style="color:#f92672">=&lt;/span> find(p);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> qRoot &lt;span style="color:#f92672">=&lt;/span> find(q);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (pRoot &lt;span style="color:#f92672">==&lt;/span> qRoot) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parent_[pRoot] &lt;span style="color:#f92672">=&lt;/span> qRoot;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size_[qRoot] &lt;span style="color:#f92672">+=&lt;/span> size_[pRoot];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">find&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> p) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (p &lt;span style="color:#f92672">!=&lt;/span> parent_[p]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parent_[p] &lt;span style="color:#f92672">=&lt;/span> find(parent_[p]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> parent_[p];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">maxConnectedSize&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> ret &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> parent_.size(); &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (parent_[i] &lt;span style="color:#f92672">==&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ret &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>max(ret, size_[i]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ret;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> parent_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> size_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> longestConsecutive(std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> nums) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 用于记录元素和下标的对应关系，同时也用来去重
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>unordered_map map;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 构造一个并查集实例，以下标来表示nums中的一个数字
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 初始状态下，每个元素都是独立的集合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> UnionFind &lt;span style="color:#a6e22e">uf&lt;/span>(nums.size());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> nums.size(); &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 去重
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (map.find(nums[i]) &lt;span style="color:#f92672">!=&lt;/span> map.end()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 将比当前元素小1的元素连接起来
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (map.find(nums[i] &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">!=&lt;/span> map.end()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uf.unite(i, map[nums[i] &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 将比当前元素大1的元素连接起来
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (map.find(nums[i] &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">!=&lt;/span> map.end()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uf.unite(i, map[nums[i] &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 记录元素和下标的对应关系
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> map[nums[i]] &lt;span style="color:#f92672">=&lt;/span> i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 返回最终所有集合中，元素最多的集合的元素个数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> uf.maxConnectedSize();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Rust和C++: 可变性、移动和所有权</title><link>https://iliubang.cn/posts/rust/2022-11-01-rust%E5%92%8Cc++%E5%AF%B9%E6%AF%94%E4%B9%8B%E5%8F%AF%E5%8F%98%E6%80%A7%E7%A7%BB%E5%8A%A8%E5%92%8C%E6%89%80%E6%9C%89%E6%9D%83/</link><pubDate>2022-11-01</pubDate><guid>https://iliubang.cn/posts/rust/2022-11-01-rust%E5%92%8Cc++%E5%AF%B9%E6%AF%94%E4%B9%8B%E5%8F%AF%E5%8F%98%E6%80%A7%E7%A7%BB%E5%8A%A8%E5%92%8C%E6%89%80%E6%9C%89%E6%9D%83/</guid><description>&lt;blockquote>
&lt;p>Ref: &lt;a href="https://www.tangramvision.com/blog/c-rust-interior-mutability-moving-and-ownership" target="_blank" rel="noopener noreferrer">https://www.tangramvision.com/blog/c-rust-interior-mutability-moving-and-ownership&lt;i class="fas fa-external-link-square-alt ms-1">&lt;/i>&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="c和-rust-中的不变性constness" data-numberify>C++和 Rust 中的不变性(constness)&lt;a class="anchor ms-1" href="#c和-rust-中的不变性constness">&lt;/a>&lt;/h2>
&lt;h3 id="值" data-numberify>值&lt;a class="anchor ms-1" href="#值">&lt;/a>&lt;/h3>
&lt;p>Rust 和 C++有两个非常相似的概念，即 Rust 中的 mutability/immutability 和 C++中的 constness/non-constness.
在 Rust 中，一个给定的值要么是可变的(mutable)，要么是不可变的(immutable)，正如这些限定符名称所代表的含义，可变的值可以被修改，不可变的值不能被修改。
然而与 C++不同的是，Rust 中不可变的值可以被移动(move)，就像下面的代码实例那样：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">foo&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">{}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, x)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x &lt;span style="color:#f92672">*=&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">{}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, x);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 C++中，给定的值要么是常量(const)，要么是非常量(non-const)。但是 C++中的常量值不能被移动(move)。在 C++中，对一个 const 限定符修饰的值
进行&lt;code>std::move&lt;/code>操作，实际上会触发拷贝构造，这一点在&amp;quot;Effective Modern C++&amp;ldquo;这本书中作者也有提到：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Annotation&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">explicit&lt;/span> Annotation(&lt;span style="color:#66d9ef">const&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>string text)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">:&lt;/span> value(std&lt;span style="color:#f92672">::&lt;/span>move(text)) &lt;span style="color:#75715e">//here we want to call string(string&amp;amp;&amp;amp;),
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">//but because text is const,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">//the return type of std::move(text) is const std::string&amp;amp;&amp;amp;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">//so we actually called string(const string&amp;amp;)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">//it is a bug which is very hard to find out
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>string value;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们也可以自己写一段程序来验证一下：&lt;/p></description></item><item><title>为什么c++中有了函数指针却还需要std::function</title><link>https://iliubang.cn/posts/cpp/2022-09-28-%E4%B8%BA%E4%BB%80%E4%B9%88c++%E4%B8%AD%E6%9C%89%E4%BA%86%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%8D%B4%E8%BF%98%E9%9C%80%E8%A6%81stdfunction/</link><pubDate>2022-09-28</pubDate><guid>https://iliubang.cn/posts/cpp/2022-09-28-%E4%B8%BA%E4%BB%80%E4%B9%88c++%E4%B8%AD%E6%9C%89%E4%BA%86%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%8D%B4%E8%BF%98%E9%9C%80%E8%A6%81stdfunction/</guid><description>&lt;p>在C/C++中，我们经常会像下面的代码那样使用一个指向函数的指针，我们称之为函数指针：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// demo.c
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">func&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> a) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> a &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> argc, &lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">*&lt;/span> argv[]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>f)(&lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> func;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;%p&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, f);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的例子中，我们定义了一个函数&lt;code>func&lt;/code>，然后通过函数指针&lt;code>f&lt;/code>指向&lt;code>func&lt;/code>，接着使用&lt;code>print&lt;/code>函数打印指针变量&lt;code>f&lt;/code>指向
的地址。代码平淡无奇，接着我们编译代码，然后使用&lt;code>objdump -D demo&lt;/code>来查看生成的二进制结构如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">0000000100003f&lt;/span>&lt;span style="color:#ae81ff">34&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>_func&lt;span style="color:#f92672">&amp;gt;:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">100003f&lt;/span>&lt;span style="color:#ae81ff">34&lt;/span>&lt;span style="color:#f92672">:&lt;/span> ff &lt;span style="color:#ae81ff">43&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> d1 sub sp, sp, &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span>&lt;span style="color:#ae81ff">16&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">100003f&lt;/span>&lt;span style="color:#ae81ff">38&lt;/span>&lt;span style="color:#f92672">:&lt;/span> e0 &lt;span style="color:#ae81ff">0f&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> b9 str w0, [sp, &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span>&lt;span style="color:#ae81ff">12&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">100003f&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>c: e8 &lt;span style="color:#ae81ff">0f&lt;/span> &lt;span style="color:#ae81ff">40&lt;/span> b9 ldr w8, [sp, &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span>&lt;span style="color:#ae81ff">12&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">100003f&lt;/span>&lt;span style="color:#ae81ff">40&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">05&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">11&lt;/span> add w0, w8, &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">100003f&lt;/span>&lt;span style="color:#ae81ff">44&lt;/span>&lt;span style="color:#f92672">:&lt;/span> ff &lt;span style="color:#ae81ff">43&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#ae81ff">91&lt;/span> add sp, sp, &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span>&lt;span style="color:#ae81ff">16&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">100003f&lt;/span>&lt;span style="color:#ae81ff">48&lt;/span>&lt;span style="color:#f92672">:&lt;/span> c0 &lt;span style="color:#ae81ff">03&lt;/span> &lt;span style="color:#ae81ff">5f&lt;/span> d6 ret
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上述结果是我在arm64-apple-darwin21.6.0环境下，使用clang
14.0编译出来的结果，gcc编译的结果稍微有点区别，但是对于本文分析问题影响不大。&lt;/p>
&lt;p>正如我们所看到的，编译后的&lt;code>func&lt;/code>函数位于&lt;code>0x102e0bf34&lt;/code>地址，让我们记住这个地址，接着往后看。&lt;/p>
&lt;p>接下来我们来运行编译后的二进制文件，很显然它应该输出的是&lt;code>func&lt;/code>函数在内存中的地址：&lt;/p>
&lt;pre tabindex="0">&lt;code>./demo
0x102e0bf34
&lt;/code>&lt;/pre>&lt;p>你猜对了，只是尽管函数指针也是指针，它指向的是内存中的一段代码，而不是内存中的数据。&lt;/p>
&lt;p>通常情况下，函数指针作为回调是没有问题的，但是如果考虑到闭包的情况，我们发现函数指针就无能为力了。
因为闭包不仅是一个函数，而且还要能捕获相关的数据，由于函数指针仅仅是指向内存中的一段代码，并没有指向内存中的数据，
所以函数指针无法实现闭包的功能。如果要想实现，就需要做一些改进：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#a6e22e">void&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>func) (&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">closure&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> func f;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>arg;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如上，我们定义了一个结构&lt;code>closure&lt;/code>，其中包含了两部分，一个指针变量指向一个函数，一个变量保存参数。
也就是说，&lt;code>closure&lt;/code>既包含了一段代码，也包含了运行该代码所需要的数据，或者称之为上下文环境，不管它叫什么，总之就是
运行函数所需要的数据。&lt;/p></description></item><item><title>使用std::list的splice方法实现LRU Cache</title><link>https://iliubang.cn/posts/cpp/2022-05-15-%E4%BD%BF%E7%94%A8stdlist%E7%9A%84splice%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0lru-cache/</link><pubDate>2022-05-15</pubDate><guid>https://iliubang.cn/posts/cpp/2022-05-15-%E4%BD%BF%E7%94%A8stdlist%E7%9A%84splice%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0lru-cache/</guid><description>&lt;h2 id="stdlist-splice-简介" data-numberify>std::list splice 简介&lt;a class="anchor ms-1" href="#stdlist-splice-简介">&lt;/a>&lt;/h2>
&lt;p>&lt;code>splice&lt;/code>函数通过重新排列链表指针，将一个&lt;code>std::list&lt;/code>中的节点转移到另一个&lt;code>std::list&lt;/code>中。在元素的转移过程中不会触发元素的拷贝或者移动。因此，调用&lt;code>splice&lt;/code>函数之后，元素现有的引用和迭代器都不会失效。&lt;/p>
&lt;p>下面是一个将&lt;code>listA&lt;/code>中所有节点附加到&lt;code>listB&lt;/code>的一个简单代码示例，转移的过程不会导致&lt;code>listA&lt;/code>中元素的引用和迭代器失效:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Note: c++17 required below. (For CTAD(Class template argument deducation))
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>list listA{&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>std&lt;span style="color:#f92672">::&lt;/span>list listB{&lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">6&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">auto&lt;/span> it &lt;span style="color:#f92672">=&lt;/span> listA.begin(); &lt;span style="color:#75715e">// Iterator to 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Append listA to listB
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>listB.splice(listB.end(), listA);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// All listA elements transferred to listB
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> listB.size() &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> listA.size() &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl; &lt;span style="color:#75715e">// 6 0
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Prints Below: 4 5 6 1 2 3
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">auto&lt;/span> i : listB) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Iterator still valid
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#f92672">*&lt;/span>it &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl; &lt;span style="color:#75715e">// 1
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当然，我们也可以在不使用&lt;code>splice&lt;/code>的情况下将一个 list 中的元素转移到另一个 list 中，但是需要将原 list 中的元素删除，并在目标 list 中插入新的元素。删除和新增元素对于较小的对象（例如 int）是可以接受的，但是对于较大的对象来说，由于需要调用拷贝/移动构造和析构函数，所以成本会很高。&lt;/p></description></item><item><title>深入理解 enable_shared_from_this</title><link>https://iliubang.cn/posts/cpp/2022-05-03-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3enable_shared_from_this/</link><pubDate>2022-05-03</pubDate><guid>https://iliubang.cn/posts/cpp/2022-05-03-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3enable_shared_from_this/</guid><description>&lt;h2 id="关于-shared_ptr" data-numberify>关于 shared_ptr&lt;a class="anchor ms-1" href="#关于-shared_ptr">&lt;/a>&lt;/h2>
&lt;p>&lt;code>shared_ptr&lt;/code>是一种共享所有权的智能指针，它允许我们安全地访问和管理对象的生命周期。&lt;code>shared_ptr&lt;/code>的多个实例通过共享控制块结构来控制对象的生命周期。
控制块维护了引用计数(reference count)，弱引用计数(weak count)和其他必要的信息，通过这些信息，控制块能够确定一个对象在内存中是否可以被安全销毁。&lt;/p>
&lt;p>当使用原始指针构造或者初始化一个&lt;code>shared_ptr&lt;/code>时，将会创建一个新的控制块。为了确保一个对象仅由一个共享的控制块管理，必须通过复制已存在的&lt;code>shared_ptr&lt;/code>对象来创建一个新的&lt;code>shared_ptr&lt;/code>实例，例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">good&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> p{&lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>(&lt;span style="color:#ae81ff">10&lt;/span>)}; &lt;span style="color:#75715e">// p is int*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// create additional shared_ptr from an existing shared_ptr
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>shared_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> sp1{p};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// sp2 shares control block with sp1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">auto&lt;/span> sp2{sp1};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>而使用指向已由&lt;code>shared_ptr&lt;/code>管理的对象的原始指针来初始化另一个&lt;code>shared_ptr&lt;/code>时，会创建一个新的控制块来管理该对象，
这样同一个对象就同时被多个控制块管理，这会导致 undefined behavior，例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">bad&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> p{&lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>(&lt;span style="color:#ae81ff">10&lt;/span>);};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>shared_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> sp1{p};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>shared_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> sp2{p}; &lt;span style="color:#75715e">// Undefined behavior!
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过原始指针的方式实例化&lt;code>shared_ptr&lt;/code>很容易产生同一个原始指针实例化多个&lt;code>shared_ptr&lt;/code>这样的编码疏忽，从而造成严重后果。
因此尽量使用&lt;code>std::make_shared&lt;/code>或者&lt;code>std::allocate_shared&lt;/code>来降低出错的可能性。毕竟除非有人刻意为之，否则我们似乎很难遇到或写出这样的代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">auto&lt;/span> sp1 &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>make_shared&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>std&lt;span style="color:#f92672">::&lt;/span>shared_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> sp2{sp1.get()};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>但是在某些情况下，&lt;code>shared_ptr&lt;/code>管理的对象需要为自己获取&lt;code>shared_ptr&lt;/code>，我会在后面的篇幅中重点讲解这种情况。
但是首先需要说明的是，类似于下面这样尝试从自身指针创建&lt;code>shared_ptr&lt;/code>的方式是行不通的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Egg&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>shared_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>Egg&lt;span style="color:#f92672">&amp;gt;&lt;/span> get_self_ptr()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>shared_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>Egg&lt;span style="color:#f92672">&amp;gt;&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">spam&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> sp1 &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>make_shared&lt;span style="color:#f92672">&amp;lt;&lt;/span>Egg&lt;span style="color:#f92672">&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> sp2 &lt;span style="color:#f92672">=&lt;/span> sp1&lt;span style="color:#f92672">-&amp;gt;&lt;/span>get_self_ptr(); &lt;span style="color:#75715e">// undefined behavior
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// sp1 and sp2 have two different control blocks managing same Egg
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>为了解决这个问题，我们就需要用到&lt;code>std::enable_shared_from_this&lt;/code>。&lt;code>public&lt;/code> 继承&lt;code>std::enable_shared_from_this&lt;/code>
的类可以通过调用&lt;code>shared_from_this()&lt;/code>方法来获取自身的&lt;code>shared_ptr&lt;/code>，下面是一个简单的例子：&lt;/p></description></item><item><title>c++ 中 unique_ptr 的一些使用技巧</title><link>https://iliubang.cn/posts/cpp/2022-04-20-c++%E4%B8%ADunique_ptr%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</link><pubDate>2022-04-20</pubDate><guid>https://iliubang.cn/posts/cpp/2022-04-20-c++%E4%B8%ADunique_ptr%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</guid><description>&lt;h2 id="前言" data-numberify>前言&lt;a class="anchor ms-1" href="#前言">&lt;/a>&lt;/h2>
&lt;p>c++11 对智能指针做了很大的优化，废弃了 c++98 中的&lt;code>auto_ptr&lt;/code>，引入了三种新的智能指针：&lt;code>unique_ptr&lt;/code>，&lt;code>shared_ptr&lt;/code>，&lt;code>weak_ptr&lt;/code>。
本文将针对&lt;code>unique_ptr&lt;/code>的一些使用技巧做一些整理和归纳。在正式开始之前，我们首先来回顾一下&lt;code>unique_ptr&lt;/code>的特点：一个&lt;code>unique_ptr&lt;/code>对象内包含一个原始指针，该&lt;code>unique_ptr&lt;/code>对象负责管理原始指针的生命周期。
一个&lt;code>unique_ptr&lt;/code>对象始终是其关联的原始指针的唯一拥有者。&lt;/p>
&lt;p>在了解了&lt;code>unique_ptr&lt;/code>的特点之后，我们来具体看看日常开发中&lt;code>unique_ptr&lt;/code>的一些使用场景和技巧。&lt;/p>
&lt;h2 id="一些场景" data-numberify>一些场景&lt;a class="anchor ms-1" href="#一些场景">&lt;/a>&lt;/h2>
&lt;h3 id="本地对象指针" data-numberify>本地对象指针&lt;a class="anchor ms-1" href="#本地对象指针">&lt;/a>&lt;/h3>
&lt;p>在开发中，我们经常会遇到或者写出类似于下面这样的逻辑：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">somefunc&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object obj &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Object;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#75715e">/* event 1 */&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">delete&lt;/span> obj;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#75715e">/* event 2 */&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">delete&lt;/span> obj;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">delete&lt;/span> obj;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对于这样的代码，写起来很麻烦，看上去也及其丑陋。以前我们常用的一种优化手段就是使用&lt;code>goto&lt;/code>，而在 c++11 之后，我们有了一种更加优雅简洁的方式，来对上面的代码进行优化，那就是使用&lt;code>unique_ptr&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">somefunc&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>unique_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>Object&lt;span style="color:#f92672">&amp;gt;&lt;/span> obj &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>make_unique&lt;span style="color:#f92672">&amp;lt;&lt;/span>Object&lt;span style="color:#f92672">&amp;gt;&lt;/span>(); &lt;span style="color:#75715e">// need c++14
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#75715e">/* event 1 */&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#75715e">/* event 2 */&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>只需要将本地指针对象用&lt;code>unique_ptr&lt;/code>包装起来，后面无需关心指针释放的问题，整体逻辑看上去更加简洁。&lt;/p></description></item><item><title>Expression Templates</title><link>https://iliubang.cn/posts/cpp/2022-04-06-expression-templates/</link><pubDate>2022-04-06</pubDate><guid>https://iliubang.cn/posts/cpp/2022-04-06-expression-templates/</guid><description>&lt;h2 id="什么是-expression-templates" data-numberify>什么是 Expression Templates&lt;a class="anchor ms-1" href="#什么是-expression-templates">&lt;/a>&lt;/h2>
&lt;p>Expression Templates 是一种 C++ 模板元编程技术，它通过在编译时构建按需执行的计算表达式，从而生成高效的代码。简单来说，通过 Expression Templates，我们可以实现惰性求值和消除因为中间结果而创建的临时变量。&lt;/p>
&lt;h2 id="一个常规示例" data-numberify>一个常规示例&lt;a class="anchor ms-1" href="#一个常规示例">&lt;/a>&lt;/h2>
&lt;p>我们构造了一个&lt;code>MyVector&lt;/code>类，并且重载了&lt;code>MyVector&lt;/code>的&lt;code>+&lt;/code>和&lt;code>*&lt;/code>操作符，实现两个&lt;code>MyVector&lt;/code>中相同下标元素的&lt;code>+&lt;/code>和&lt;code>*&lt;/code>操作。
对于这样的需求我们很容易写出形如下面代码的一个简单的实现：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cassert&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;vector&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyVector&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MyVector(&lt;span style="color:#66d9ef">const&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>size_t n)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">:&lt;/span> vec_(n)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MyVector(&lt;span style="color:#66d9ef">const&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>size_t n, &lt;span style="color:#66d9ef">const&lt;/span> T initvalues)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">:&lt;/span> vec_(n, initvalues)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>size_t size() &lt;span style="color:#66d9ef">const&lt;/span> { &lt;span style="color:#66d9ef">return&lt;/span> vec_.size(); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> T &lt;span style="color:#66d9ef">operator&lt;/span>[](&lt;span style="color:#66d9ef">const&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>size_t i) &lt;span style="color:#66d9ef">const&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> assert(i &lt;span style="color:#f92672">&amp;lt;&lt;/span> size());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> vec_[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> T&lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#66d9ef">operator&lt;/span>[](&lt;span style="color:#66d9ef">const&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>size_t i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> assert(i &lt;span style="color:#f92672">&amp;lt;&lt;/span> size());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> vec_[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> vec_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span> MyVector&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">operator&lt;/span>&lt;span style="color:#f92672">+&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> MyVector&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> a, &lt;span style="color:#66d9ef">const&lt;/span> MyVector&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> b)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> assert(a.size() &lt;span style="color:#f92672">==&lt;/span> b.size());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MyVector&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> result(a.size());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (std&lt;span style="color:#f92672">::&lt;/span>size_t i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> a.size(); &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result[i] &lt;span style="color:#f92672">=&lt;/span> a[i] &lt;span style="color:#f92672">+&lt;/span> b[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> result;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span> MyVector&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">operator&lt;/span>&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> MyVector&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> a, &lt;span style="color:#66d9ef">const&lt;/span> MyVector&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> b)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> assert(a.size() &lt;span style="color:#f92672">==&lt;/span> b.size());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MyVector&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> result(a.size());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (std&lt;span style="color:#f92672">::&lt;/span>size_t i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> a.size(); &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result[i] &lt;span style="color:#f92672">=&lt;/span> a[i] &lt;span style="color:#f92672">*&lt;/span> b[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> result;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>ostream&lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#66d9ef">operator&lt;/span>&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>(std&lt;span style="color:#f92672">::&lt;/span>ostream&lt;span style="color:#f92672">&amp;amp;&lt;/span> os, &lt;span style="color:#66d9ef">const&lt;/span> MyVector&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> vec)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;\n&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (std&lt;span style="color:#f92672">::&lt;/span>size_t i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> vec.size(); &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> vec[i] &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#39; &amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;\n&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> os;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> argc, &lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">*&lt;/span> argv[])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MyVector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">double&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> x(&lt;span style="color:#ae81ff">10&lt;/span>, &lt;span style="color:#ae81ff">5.4&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MyVector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">double&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> y(&lt;span style="color:#ae81ff">10&lt;/span>, &lt;span style="color:#ae81ff">10.3&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> ret &lt;span style="color:#f92672">=&lt;/span> x &lt;span style="color:#f92672">+&lt;/span> x &lt;span style="color:#f92672">+&lt;/span> y &lt;span style="color:#f92672">*&lt;/span> y;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> ret &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个实现平淡无奇，相信每个人都能随手写出来。在&lt;a href="https://godbolt.org/z/zTenMfe6G" target="_blank" rel="noopener noreferrer">godbolt&lt;i class="fas fa-external-link-square-alt ms-1">&lt;/i>&lt;/a>上编译成汇编来分析：&lt;/p></description></item><item><title>c++中的动态多态和静态多态</title><link>https://iliubang.cn/posts/cpp/2022-03-23-c++%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81%E5%92%8C%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81/</link><pubDate>2022-03-23</pubDate><guid>https://iliubang.cn/posts/cpp/2022-03-23-c++%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81%E5%92%8C%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81/</guid><description>&lt;h2 id="动态多态-dynamic-polymorphism" data-numberify>动态多态 (Dynamic Polymorphism)&lt;a class="anchor ms-1" href="#动态多态-dynamic-polymorphism">&lt;/a>&lt;/h2>
&lt;p>在 c++中为了实现多态，使用了一种动态绑定的技术，这个技术的核心就是虚函数表(virtual table)。下面就简单的说明一下基于虚表的动态绑定的原理，从而更好的与静态多态做比较。&lt;/p>
&lt;p>在 c++中，每个包含虚函数的类都有一个虚表。我们来看下面这个类：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// demo.cpp
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">A&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> vfunc1();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">vfunc2&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">func1&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">func2&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> m_data1, m_data2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以借助编译器来查看上述类的对象布局：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 使用llvm编译工具&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>clang -Xclang -fdump-record-layouts -stdlib&lt;span style="color:#f92672">=&lt;/span>libc++ -c demo.cpp &lt;span style="color:#75715e"># 查看对象布局&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>clang -Xclang -fdump-vtable-layouts -stdlib&lt;span style="color:#f92672">=&lt;/span>libc++ -c demo.cpp &lt;span style="color:#75715e"># 查看虚表布局&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 使用gcc编译工具&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>g++ -fdump-lang-class demo.cpp
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里为了便于分析，使用 clang 打印的结果来具体说明：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// clang -Xclang -fdump-record-layouts -stdlib=libc++ -c demo.cpp
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">***&lt;/span> Dumping AST Record Layout
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">A&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">|&lt;/span> (A vtable pointer)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">8&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> m_data1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">12&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> m_data2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|&lt;/span> [&lt;span style="color:#66d9ef">sizeof&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">16&lt;/span>, dsize&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">16&lt;/span>, align&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|&lt;/span> nvsize&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">16&lt;/span>, nvalign&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// clang -Xclang -fdump-vtable-layouts -stdlib=libc++ -c demo.cpp
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>Original map
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Vtable &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#e6db74">&amp;#39;A&amp;#39;&lt;/span> (&lt;span style="color:#ae81ff">4&lt;/span> entries).
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">|&lt;/span> offset_to_top (&lt;span style="color:#ae81ff">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">|&lt;/span> A RTTI
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">--&lt;/span> (A, &lt;span style="color:#ae81ff">0&lt;/span>) vtable address &lt;span style="color:#f92672">--&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> A&lt;span style="color:#f92672">::&lt;/span>vfunc1()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">3&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> A&lt;span style="color:#f92672">::&lt;/span>vfunc2()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>VTable indices &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#e6db74">&amp;#39;A&amp;#39;&lt;/span> (&lt;span style="color:#ae81ff">2&lt;/span> entries).
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> A&lt;span style="color:#f92672">::&lt;/span>vfunc1()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> A&lt;span style="color:#f92672">::&lt;/span>vfunc2()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>根据对象布局可以简单画出&lt;code>class A&lt;/code>的对象布局图：&lt;/p></description></item><item><title>c++17:constexpr if</title><link>https://iliubang.cn/posts/cpp/2022-03-18-c++17-constexpr_if/</link><pubDate>2022-03-18</pubDate><guid>https://iliubang.cn/posts/cpp/2022-03-18-c++17-constexpr_if/</guid><description>&lt;p>constexpr 是 c++11 引入的关键字，用于编译时常量和常量表达式。而 c++17 将这一特性做了增强，引入了 &lt;code>constexpr if&lt;/code> ，
使得编译器在编译时(compile time)能够做分支判断，从而有条件的编译代码。&lt;/p>
&lt;p>下面可以通过一个简单的例子来看看&lt;code>constexpr if&lt;/code>的用法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;type_traits&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">auto&lt;/span> getValue(T t)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">constexpr&lt;/span> (std&lt;span style="color:#f92672">::&lt;/span>is_pointer&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;::&lt;/span>value) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">*&lt;/span>t;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> t;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> argc, &lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">*&lt;/span> argv[])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">*&lt;/span> b &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> getValue(a);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> getValue(b);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其实和普通的条件判断区别不大，只不过&lt;code>constexpr if&lt;/code>中的条件是常量表达式，可以在编译时确定条件表达式的结果，从而选择编译对应的分支代码。
我们可以将上述代码编译成汇编来进一步分析：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">auto&lt;/span> getValue&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>)&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> push rbp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mov rbp, rsp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mov DWORD PTR [rbp&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">4&lt;/span>], edi
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mov eax, DWORD PTR [rbp&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">4&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pop rbp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ret
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">auto&lt;/span> getValue&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">*&amp;gt;&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> push rbp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mov rbp, rsp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mov QWORD PTR [rbp&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>], rdi
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mov rax, QWORD PTR [rbp&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mov eax, DWORD PTR [rax]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pop rbp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ret
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>......
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里可以看到，生成的&lt;code>getValue&amp;lt;int&amp;gt;&lt;/code>和&lt;code>getValue&amp;lt;int*&amp;gt;&lt;/code>两个版本的函数分别保留了对应类型的分支逻辑，而没有了条件判断。&lt;/p></description></item><item><title>c++20:Designated Initializers</title><link>https://iliubang.cn/posts/cpp/2022-03-15-c++20-designated_initializers/</link><pubDate>2022-03-15</pubDate><guid>https://iliubang.cn/posts/cpp/2022-03-15-c++20-designated_initializers/</guid><description>&lt;p>对于熟悉 c99 的人来说，Designated Initializers 并不算是什么新鲜事物，然而 c++直到 c++20 才正式支持这一特性。
虽然在 c++20 之前，像 GCC 这样的编译器通过扩展的形式已经对该特性做了支持，但是随着 c++20 将其纳入新标准，这一特性将在所有编译器中得到支持。&lt;/p>
&lt;h2 id="基本用法" data-numberify>基本用法&lt;a class="anchor ms-1" href="#基本用法">&lt;/a>&lt;/h2>
&lt;p>Designated Initialization 是聚合初始化(Aggregate Initialization)的一种形式。
在 c++20 中，聚合类型(Aggregate types)是指：&lt;/p>
&lt;ul>
&lt;li>数组类型&lt;/li>
&lt;li>具备如下特性的 class 类型：&lt;/li>
&lt;li>
&lt;ul>
&lt;li>has no private or protected direct non-static data members&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;ul>
&lt;li>has no user-declared or inherited constructors&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;ul>
&lt;li>has no virtual, private, or protected base classes&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;ul>
&lt;li>has no virtual member functions&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>c++20 中的 Designated Initializers 的用法跟 c99 非常相似：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Points&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">double&lt;/span> x{&lt;span style="color:#ae81ff">0.0&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">double&lt;/span> y{&lt;span style="color:#ae81ff">0.0&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> Points p{.x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1.1&lt;/span>, .y &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2.2&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> Points o{.x{&lt;span style="color:#ae81ff">1.1&lt;/span>}, .y{&lt;span style="color:#ae81ff">2.2&lt;/span>}};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> Points x{.x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1.1&lt;/span>, .y{&lt;span style="color:#ae81ff">2.2&lt;/span>}};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;h2 id="优点" data-numberify>优点&lt;a class="anchor ms-1" href="#优点">&lt;/a>&lt;/h2>
&lt;p>使用 Designated Initializers 最大的好处就是能够提升代码的可读性。&lt;/p></description></item><item><title>Linux磁盘IO</title><link>https://iliubang.cn/posts/linux/2022-02-25-linux%E7%A3%81%E7%9B%98io/</link><pubDate>2022-02-25</pubDate><guid>https://iliubang.cn/posts/linux/2022-02-25-linux%E7%A3%81%E7%9B%98io/</guid><description>&lt;h2 id="前言" data-numberify>前言&lt;a class="anchor ms-1" href="#前言">&lt;/a>&lt;/h2>
&lt;p>做存储开发，一定会经常涉及到 IO 相关的操作。而现在的高级编程语言，往往会帮助我们屏蔽 IO 操作的底层细节，虽然这样能降低开发门槛，提升效率，但是却也导致我们对 IO 底层操作实现的理解不够系统和深入。
所以呢，我一直想抽时间来系统整理一下 Linux IO 涉及的系统调用，以及相互之间的区别和联系，以加深对 IO 操作的理解。&lt;/p>
&lt;h2 id="io-操作" data-numberify>IO 操作&lt;a class="anchor ms-1" href="#io-操作">&lt;/a>&lt;/h2>
&lt;h3 id="fwrite" data-numberify>fwrite&lt;a class="anchor ms-1" href="#fwrite">&lt;/a>&lt;/h3>
&lt;p>fwrite 是 c 语言标准库中的文件写入函数，其作用是向指定的文件中写入若干数据。调用 fwrite 实际上是将数据写入到了 c 标准库的 IO Buffer 中。&lt;/p>
&lt;h3 id="mmap" data-numberify>mmap&lt;a class="anchor ms-1" href="#mmap">&lt;/a>&lt;/h3>
&lt;p>mmap 将一个文件或者其它对象映射进内存。文件被映射到多个页上，如果文件的大小不是所有页的大小之和，最后一个页不被使用的空间将会清零。mmap 在用户空间映射调用系统中作用很大。&lt;/p>
&lt;h3 id="fflush" data-numberify>fflush&lt;a class="anchor ms-1" href="#fflush">&lt;/a>&lt;/h3>
&lt;p>fflush 就是将 c 标准库中的 IO Buffer 中的数据写入到参数 stream 指定的文件中。&lt;/p>
&lt;h3 id="fsync" data-numberify>fsync&lt;a class="anchor ms-1" href="#fsync">&lt;/a>&lt;/h3>
&lt;p>fsync 系统调用就是将内核缓冲区中的数据同步到存储介质(如硬盘)。也可以在 open 文件的时候通过开启&lt;code>O_SYNC&lt;/code>来开启同步 I/O.&lt;/p>
&lt;h2 id="各-io-操作的区别与联系" data-numberify>各 IO 操作的区别与联系&lt;a class="anchor ms-1" href="#各-io-操作的区别与联系">&lt;/a>&lt;/h2>
&lt;p>&lt;picture>&lt;img class="img-fluid mx-auto d-block" alt="图片引用自 https://oscimg.oschina.net/oscnet/51a17cc9aa34eba47971af609fdecabf398.jpg" src="https://iliubang.cn/images/2022-02-28/linux_io_sub_system_arch.jpeg#center?v=7fdc4e1b5785be32c88d453deb32ca63" loading="lazy" width="1216" height="1224" />
&lt;/picture>
&lt;/p></description></item><item><title>c++元编程之遍历tuple</title><link>https://iliubang.cn/posts/cpp/2022-02-22-c++%E5%85%83%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%8D%E5%8E%86tuple/</link><pubDate>2022-02-22</pubDate><guid>https://iliubang.cn/posts/cpp/2022-02-22-c++%E5%85%83%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%8D%E5%8E%86tuple/</guid><description>&lt;p>对于一个标准的 c++容器来说，我们可以很容易在运行时使用迭代器和 range-based for
loop 来遍历其中的每一个元素。但是对于&lt;code>std::tuple&lt;/code>，却不能像普通的容器那样去遍历它。&lt;/p>
&lt;h2 id="stdtuple-简介" data-numberify>std::tuple 简介&lt;a class="anchor ms-1" href="#stdtuple-简介">&lt;/a>&lt;/h2>
&lt;p>&lt;code>std::tuple&lt;/code>是一个具有固定大小，包含不同类型值的集和。与之相似的是&lt;code>std::pair&lt;/code>，只不过&lt;code>std::pair&lt;/code>只能容纳两个元素，
而&lt;code>std::tuple&lt;/code>可以容纳许多元素：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>std&lt;span style="color:#f92672">::&lt;/span>tuple&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#66d9ef">double&lt;/span>, &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">*&amp;gt;&lt;/span> tup {&lt;span style="color:#ae81ff">42&lt;/span>, &lt;span style="color:#ae81ff">10.5&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// or with CTAD(class template argument deduction), C++17:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>tuple deducedTup {&lt;span style="color:#ae81ff">42&lt;/span>, &lt;span style="color:#ae81ff">10.5&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>}; &lt;span style="color:#75715e">// 自动推导类型
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>访问&lt;code>std::pair&lt;/code>中的元素只需要访问&lt;code>.first&lt;/code>和&lt;code>.second&lt;/code>成员即可:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>std&lt;span style="color:#f92672">::&lt;/span>pair p &lt;span style="color:#f92672">=&lt;/span> {&lt;span style="color:#ae81ff">10&lt;/span>, &lt;span style="color:#ae81ff">10.5&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>p.first &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然而&lt;code>std::tuple&lt;/code>并没有类似于&lt;code>.first&lt;/code>
&lt;code>.second&lt;/code>的成员，标准库中我们只能通过&lt;code>std::get&lt;/code>来直接访问其中的元素:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>std&lt;span style="color:#f92672">::&lt;/span>tuple tp {&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;world&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">10.5&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// by index
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>get&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>(tp) &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>std&lt;span style="color:#f92672">::&lt;/span>get&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>(tp) &lt;span style="color:#f92672">*=&lt;/span> &lt;span style="color:#ae81ff">20&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>get&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>(tp) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;\n&amp;#39;&lt;/span>; &lt;span style="color:#75715e">// hello
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>get&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>(tp) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;\n&amp;#39;&lt;/span>; &lt;span style="color:#75715e">// world
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// by type
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>get&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">double&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>(tp) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;\n&amp;#39;&lt;/span>; &lt;span style="color:#75715e">// 10.5
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;h2 id="如何遍历-tuple" data-numberify>如何遍历 tuple&lt;a class="anchor ms-1" href="#如何遍历-tuple">&lt;/a>&lt;/h2>
&lt;p>对 tuple 有了初步的了解，也知道了如何去获取 tuple 中的元素，那么接下来我们就来一步步构造对 tuple 遍历的方法。&lt;/p>
&lt;h3 id="准备工作" data-numberify>准备工作&lt;a class="anchor ms-1" href="#准备工作">&lt;/a>&lt;/h3>
&lt;p>首先我们来编写下面这样一段代码，通过向模板中传递一系列想要访问的元素下标，来完成对&lt;code>tuple&lt;/code>的遍历：&lt;/p></description></item><item><title>c++17:string_view</title><link>https://iliubang.cn/posts/cpp/2022-02-14-c++17%E4%B9%8Bstring_view/</link><pubDate>2022-02-14</pubDate><guid>https://iliubang.cn/posts/cpp/2022-02-14-c++17%E4%B9%8Bstring_view/</guid><description>&lt;h2 id="string_view-简介" data-numberify>string_view 简介&lt;a class="anchor ms-1" href="#string_view-简介">&lt;/a>&lt;/h2>
&lt;p>&lt;code>std::string_view&lt;/code>是 c++17 中新增的一种类型。其核心理念是，能够让我们在传统的 C++03 风格的具体性和泛型编程之间找到一个很好的折衷点。
在 C++17 标准之前，我们通常只能在粗糙的不严谨的模板实现和相对严谨但是有着冗长约束的模板之间做出选择。举个简单的例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// c++03 style
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Widget&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>string name_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> setName(&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">*&lt;/span> new_name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">setName&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>string&lt;span style="color:#f92672">&amp;amp;&lt;/span> new_name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 不正确的欠约束的模板
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Widget&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>string name_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">template&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> setName(T&lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> new_name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 正确的但是约束但滑稽冗长的模板
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Widget&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>string name_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">template&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span>, &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">= &lt;/span>&lt;span style="color:#a6e22e">decltype&lt;/span>(std&lt;span style="color:#f92672">::&lt;/span>declval&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>string&lt;span style="color:#f92672">&amp;amp;&amp;gt;&lt;/span>() &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>declval&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;amp;&amp;amp;&amp;gt;&lt;/span>()) &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> setName(T&lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> new_name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>而有了 &lt;code>string_view&lt;/code> 之后，以上代码就可以简化成如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Widget&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>string name_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> setName(std&lt;span style="color:#f92672">::&lt;/span>string_view name) { name_ &lt;span style="color:#f92672">=&lt;/span> name; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>string_view&lt;/code> 在替代&lt;code>const std::string&amp;amp;&lt;/code>参数上取得了巨大的成功，但是有人坚持尝试在任何地方
使用&lt;code>std::string_view&lt;/code>来替代&lt;code>const std::string&amp;amp;&lt;/code>，这是不对的，例如下面的例子：&lt;/p></description></item><item><title>LevelDB 源码阅读之 Compaction</title><link>https://iliubang.cn/posts/storage/2021-01-12-leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8Bcompaction/</link><pubDate>2021-01-12</pubDate><guid>https://iliubang.cn/posts/storage/2021-01-12-leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8Bcompaction/</guid><description>&lt;h2 id="1-概览" data-numberify>1. 概览&lt;a class="anchor ms-1" href="#1-概览">&lt;/a>&lt;/h2>
&lt;p>要谈论 LevelDB 的 Compaction 就不得不从 LevelDB 的整个数据写入流程入手。LevelDB 的基本写入流程大致为：&lt;/p>
&lt;ol>
&lt;li>数据先写入到 WAL 日志中，做持久化&lt;/li>
&lt;li>然后数据同步到&lt;code>mutable memtable&lt;/code>中&lt;/li>
&lt;li>当&lt;code>mutable memtable&lt;/code>大小达到&lt;code>Options.write_buffer_size&lt;/code>设置的大小时，就会变成&lt;code>immutable memtable&lt;/code>，并且创建一个新的&lt;code>mutable memtable&lt;/code>&lt;/li>
&lt;li>后台的 Compaction 线程会把&lt;code>immutable memtable&lt;/code>dump 成 sstable 文件，并设置于 Level 0 层&lt;/li>
&lt;li>当 Level i 达到一定条件后，就会和 Level i + 1 层的 sstable 进行合并，从而触发 Compaction 过程，并在 Level
n + 1 层生成一个新的 sstable 文件&lt;/li>
&lt;/ol>
&lt;h2 id="2-compaction-分类" data-numberify>2. Compaction 分类&lt;a class="anchor ms-1" href="#2-compaction-分类">&lt;/a>&lt;/h2>
&lt;p>在 LevelDB 中，Compaction 大体上可以分为两类，分别是：&lt;/p>
&lt;ul>
&lt;li>&lt;code>immutable memtable compaction&lt;/code>，也叫做&lt;strong>minor compaction&lt;/strong>，指的是将&lt;code>immutable memtable&lt;/code>dump 到 sstable 文件的过程&lt;/li>
&lt;li>&lt;code>sstable compaction&lt;/code>，也叫做&lt;strong>major compaction&lt;/strong>，指的是 sstable 文件之间的合并过程&lt;/li>
&lt;/ul>
&lt;p>而对于&lt;code>sstable compaction&lt;/code>又可以细分为三种：&lt;/p></description></item><item><title>分布式协议</title><link>https://iliubang.cn/posts/inf/2020-05-25-%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AE/</link><pubDate>2020-05-25</pubDate><guid>https://iliubang.cn/posts/inf/2020-05-25-%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AE/</guid><description>&lt;h2 id="拜占庭将军问题" data-numberify>拜占庭将军问题&lt;a class="anchor ms-1" href="#拜占庭将军问题">&lt;/a>&lt;/h2>
&lt;h3 id="简介" data-numberify>简介&lt;a class="anchor ms-1" href="#简介">&lt;/a>&lt;/h3>
&lt;ul>
&lt;li>在可能存在叛军的情况下，采用合适的通讯协议，让多个将军达成共识，执行统一的作战计划&lt;/li>
&lt;li>二忠一叛难题&lt;/li>
&lt;li>它是分布式领域最复杂的容错模型&lt;/li>
&lt;li>莱斯利·兰伯特（Leslie Lamport）&lt;a href="https://www.microsoft.com/en-us/research/uploads/prod/2016/12/The-Byzantine-Generals-Problem.pdf" target="_blank" rel="noopener noreferrer">The Byzantine Generals Problem&lt;i class="fas fa-external-link-square-alt ms-1">&lt;/i>&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="二忠一叛难题" data-numberify>二忠一叛难题&lt;a class="anchor ms-1" href="#二忠一叛难题">&lt;/a>&lt;/h3>
&lt;p>&lt;picture>&lt;img class="img-fluid mx-auto d-block" alt="" src="https://iliubang.cn/images/2020-05-25/bzt1.png#center?v=7fdc4e1b5785be32c88d453deb32ca63" loading="lazy" width="1035" height="575" />
&lt;/picture>
&lt;/p>
&lt;p>&lt;picture>&lt;img class="img-fluid mx-auto d-block" alt="" src="https://iliubang.cn/images/2020-05-25/bzt2.png#center?v=7fdc4e1b5785be32c88d453deb32ca63" loading="lazy" width="1100" height="569" />
&lt;/picture>
&lt;/p>
&lt;ul>
&lt;li>总共有三个将军，其中一个作为指挥官&lt;/li>
&lt;li>通过信使相互传递作战指令，进攻或者撤退&lt;/li>
&lt;li>所有忠诚的将军必须执行统一的作战计划，忠诚的将军必须执行忠诚的指挥官发布的指令&lt;/li>
&lt;li>假如 LIEUTENANT2 叛变，LIEUTENANT1 收到的作战指令就是“进攻，撤退”&lt;/li>
&lt;li>假如 COMMANDER 叛变，LIEUTENANT1 和 LIEUTENANT2 收到的作战指令都是“进攻，撤退”&lt;/li>
&lt;/ul>
&lt;h3 id="口信消息型解法" data-numberify>口信消息型解法&lt;a class="anchor ms-1" href="#口信消息型解法">&lt;/a>&lt;/h3>
&lt;ul>
&lt;li>叛变人数为 m 需要已知&lt;/li>
&lt;li>则所有参与者的人数至少为 3m+1&lt;/li>
&lt;li>第一轮由指挥官发送作战指令&lt;/li>
&lt;li>第二轮由各位将军相互发送指令&lt;/li>
&lt;li>收到指令的将军按照少数服从多数的原则执行指令&lt;/li>
&lt;li>按照这个公式，前面的例子叛军为 1 人的情况，则需要 1 个指挥官和 3 个将军&lt;/li>
&lt;/ul>
&lt;p>&lt;picture>&lt;img class="img-fluid mx-auto d-block" alt="" src="https://iliubang.cn/images/2020-05-25/bzt3.png#center?v=7fdc4e1b5785be32c88d453deb32ca63" loading="lazy" width="1181" height="529" />
&lt;/picture>
&lt;/p>
&lt;p>假如 LIEUTENANT3 叛变了，那么首先指挥官向各位将军发送“进攻”的指令，由于 3 号将军叛变了，所以最终 1 号将军收到的指令是 2 个进攻，1 个撤退，2 号将军同样收到 2 个进攻，1 个撤退，这样忠诚的将军将会执行一致的指令&lt;/p></description></item><item><title>基于公司私有gitlab的go module实践</title><link>https://iliubang.cn/posts/go/2019-10-17-%E5%9F%BA%E4%BA%8E%E5%85%AC%E5%8F%B8%E7%A7%81%E6%9C%89gitlab%E7%9A%84go-module%E5%AE%9E%E8%B7%B5/</link><pubDate>2019-10-17</pubDate><guid>https://iliubang.cn/posts/go/2019-10-17-%E5%9F%BA%E4%BA%8E%E5%85%AC%E5%8F%B8%E7%A7%81%E6%9C%89gitlab%E7%9A%84go-module%E5%AE%9E%E8%B7%B5/</guid><description>&lt;h2 id="背景" data-numberify>背景&lt;a class="anchor ms-1" href="#背景">&lt;/a>&lt;/h2>
&lt;p>我们 laser 存储为了更好的跟引擎对接，适应其他团队的技术生态，决定开发一套 golang 的公共库来给大家使用。于是我们在公司私有的 gitlab 上新建了一个项目:git.yourcomp.com/ad/ads_core/adgo，并且我们想使用单一的 codebase 来管理所有的公共 library.&lt;/p>
&lt;p>而且，为了更好的管理模块，我们统一使用了 go mod。&lt;/p>
&lt;p>按照平时我们在 github 上拉取 go library 的惯例，我本以为直接使用&lt;code>go get git.yourcomp.com/ad/ads_core/adgo/xxx&lt;/code>就能直接拉取到相应的模块了，然而在开发完功能测试的时候却发现，事实并不是想象中那样。&lt;/p>
&lt;h2 id="遇到的问题和解决方案" data-numberify>遇到的问题和解决方案&lt;a class="anchor ms-1" href="#遇到的问题和解决方案">&lt;/a>&lt;/h2>
&lt;h3 id="1-仓库问题" data-numberify>1. 仓库问题&lt;a class="anchor ms-1" href="#1-仓库问题">&lt;/a>&lt;/h3>
&lt;p>执行&lt;code>go get&lt;/code>后，实际上会请求&amp;quot;https://git.yourcomp.com/ad/ads_core/adgo?go-get=1&amp;quot;这个地址，如果使用&lt;code>-insecure&lt;/code>选项，则会请求&amp;quot;http://git.yourcomp.com/ad/ads_core/adgo?go-get=1&amp;quot;，正常情况下回返回meta tag：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-html" data-lang="html">&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="color:#f92672">html&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">head&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">meta&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;go-import&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">content&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;git.yourcomp.com/ad/ads_core git http://git.yourcomp.com/ad/ads_core.git&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> /&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;/&lt;span style="color:#f92672">head&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;/&lt;span style="color:#f92672">html&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这是 go remote import 的协议，meta tag 的格式一般为&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-html" data-lang="html">&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="color:#f92672">meta&lt;/span> &lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;go-import&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">content&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;import-prefix vcs repo-root&amp;#34;&lt;/span> /&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>由于 gitlab 的版本问题，如果使用了 subgroup，则不能正确返回 meta tag。也就是说，我们使用的 gitlab 版本只支持一层 namespace 下建的项目。而&amp;quot;ad/ads_core/adgo&amp;quot;就是两层 namespace，所以 meta tag 中返回的 repo 地址是&amp;quot;http://git.yourcomp.com/ad/ads_core.git&amp;quot;显然是错的。于是我们又对代码库进行了迁移。&lt;/p></description></item><item><title>使用c语言模拟lisp语法</title><link>https://iliubang.cn/posts/sp/2019-08-18-c%E8%AF%AD%E8%A8%80%E6%A8%A1%E6%8B%9Flisp%E8%AF%AD%E6%B3%95/</link><pubDate>2019-08-18</pubDate><guid>https://iliubang.cn/posts/sp/2019-08-18-c%E8%AF%AD%E8%A8%80%E6%A8%A1%E6%8B%9Flisp%E8%AF%AD%E6%B3%95/</guid><description>&lt;p>使用 c 语言的 macro 操作，能够很简单的用 c 语言模拟 lisp 语法。&lt;/p>
&lt;h3 id="下面我们来定义-lisph-头文件" data-numberify>下面我们来定义 lisp.h 头文件&lt;a class="anchor ms-1" href="#下面我们来定义-lisph-头文件">&lt;/a>&lt;/h3>
&lt;pre tabindex="0">&lt;code>#ifndef LISP_H_OTE1HWPK
#define LISP_H_OTE1HWPK
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#define define(ret, name, args, block) \
ret name args { return block; }
#define if(expr, block1, block2) \
expr ? block1 : block2
#define eq(a, b) \
a == b
#define neq(a, b) \
a != b
#define sub(a, b) \
a - b
#define mul(a, b) \
a * b
#define add(a, b) \
a + b
#define div(a, b) \
a / b
#endif /* end of include guard: LISP_H_OTE1HWPK */
&lt;/code>&lt;/pre>
&lt;h3 id="然后来用类似于-lisp-的语法编写一段求阶乘的代码" data-numberify>然后来用类似于 lisp 的语法编写一段求阶乘的代码：&lt;a class="anchor ms-1" href="#然后来用类似于-lisp-的语法编写一段求阶乘的代码">&lt;/a>&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">define&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>, factorial, (&lt;span style="color:#66d9ef">int&lt;/span> n),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#a6e22e">eq&lt;/span>(n, &lt;span style="color:#ae81ff">0&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">1&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">mul&lt;/span>(n, &lt;span style="color:#a6e22e">factorial&lt;/span>(&lt;span style="color:#a6e22e">sub&lt;/span>(n, &lt;span style="color:#ae81ff">1&lt;/span>)))))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">define&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>, main, (&lt;span style="color:#66d9ef">void&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;10! = %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">factorial&lt;/span>(&lt;span style="color:#ae81ff">10&lt;/span>)), EXIT_SUCCESS))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;h3 id="编写-makefile" data-numberify>编写 Makefile:&lt;a class="anchor ms-1" href="#编写-makefile">&lt;/a>&lt;/h3>
&lt;pre tabindex="0">&lt;code>CFLAGS = -Wall -include &amp;#34;lisp.h&amp;#34;
TARGET=factorial
all:
gcc -o $(TARGET) $(TARGET).c $(CFLAGS)
clean:
rm -f $(TARGET)
&lt;/code>&lt;/pre>
&lt;h3 id="编译并运行" data-numberify>编译并运行：&lt;a class="anchor ms-1" href="#编译并运行">&lt;/a>&lt;/h3>
&lt;pre tabindex="0">&lt;code>liubang@venux-dev:~$ make
gcc -o factorial factorial.c -Wall -include &amp;#34;lisp.h&amp;#34;
liubang@venux-dev:~$ ./factorial
10! = 3628800
&lt;/code>&lt;/pre></description></item><item><title>动态连接器技巧之使用LD_PRELOAD改变程序的行为</title><link>https://iliubang.cn/posts/sp/2019-07-18-%E5%8A%A8%E6%80%81%E8%BF%9E%E6%8E%A5%E5%99%A8%E6%8A%80%E5%B7%A7%E4%B9%8B%E4%BD%BF%E7%94%A8ld_preload%E6%94%B9%E5%8F%98%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A1%8C%E4%B8%BA/</link><pubDate>2019-07-18</pubDate><guid>https://iliubang.cn/posts/sp/2019-07-18-%E5%8A%A8%E6%80%81%E8%BF%9E%E6%8E%A5%E5%99%A8%E6%8A%80%E5%B7%A7%E4%B9%8B%E4%BD%BF%E7%94%A8ld_preload%E6%94%B9%E5%8F%98%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A1%8C%E4%B8%BA/</guid><description>&lt;p>我们有这样一段简单的代码，用来输出 10 个[0, 100)的随机数：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// random.c
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdlib.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;time.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">srand&lt;/span>(&lt;span style="color:#a6e22e">time&lt;/span>(NULL));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (i&lt;span style="color:#f92672">--&lt;/span>) &lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">rand&lt;/span>() &lt;span style="color:#f92672">%&lt;/span> &lt;span style="color:#ae81ff">100&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>编译运行：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>liubang@venux-dev:~$ gcc random.c -o random
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>liubang@venux-dev:~$ ./random
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">44&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">46&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">97&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">51&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">62&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">76&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">92&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">76&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">38&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个程序每次运行的结果都是不一样的，现在我们希望我们能够在不修改源码的情况下，控制程序的输出结果，例如我希望这段程序运行的结果是
每次都能输出 10 个 10。由于不能修改源码，或者我们根本没有源码，面对这样一个编译后的可执行二进制文件，想要修改程序的运行结果，可能显
得有些困难。然而，如果能够善用动态连接器的话，这都不是问题。&lt;/p>
&lt;p>下面我们来创建一段程序：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// unrandom.c
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">rand&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后将它编译成动态链接库：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>liubang@venux-dev:~$ gcc -shared -fPIC unrandom.c -o libunrandom.so
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样我们就得到了一个名为&lt;code>libunrandom.so&lt;/code>的动态链接库，然后执行：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>liubang@venux-dev:~$ LD_PRELOAD&lt;span style="color:#f92672">=&lt;/span>./libunrandom.so ./random
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>是不是发现原来程序的结果变成了 10 个 10，即使执行多次，结果都一样。为什么会这样呢？&lt;code>LD_PRELOAD&lt;/code>到底做了什么事？
下面我们来进一步了解其中的原理。&lt;/p></description></item><item><title>Spring Boot With BDD</title><link>https://iliubang.cn/posts/java/2019-03-15-spring_boot_with_bdd/</link><pubDate>2019-03-15</pubDate><guid>https://iliubang.cn/posts/java/2019-03-15-spring_boot_with_bdd/</guid><description>&lt;h2 id="什么是-bdd" data-numberify>什么是 BDD&lt;a class="anchor ms-1" href="#什么是-bdd">&lt;/a>&lt;/h2>
&lt;p>BDD(Behavior Driven Development)，行为驱动开发，是一种敏捷软件开发的技术，它鼓励软件项目中的开发者、QA 和非技术人员或商业参与者之间的协作。&lt;/p>
&lt;p>BDD 的重点是通过与利益相关者的讨论取得对预期的软件行为的清醒认识。它通过用自然语言书写非程序员可读的测试用例扩展了测试驱动开发方法。行为驱动开发人员使用混合了领域中统一的语言的母语语言来描述他们的代码的目的。这让开发者得以把精力集中在代码应该怎么写，而不是技术细节上，而且也最大程度的减少了将代码编写者的技术语言与商业客户、用户、利益相关者、项目管理者等的领域语言之间来回翻译的代价。&lt;/p>
&lt;h2 id="具体怎么操作" data-numberify>具体怎么操作&lt;a class="anchor ms-1" href="#具体怎么操作">&lt;/a>&lt;/h2>
&lt;p>结合我们项目开发使用的 spring boot 2.x，下面我们来具体说明如何在实际项目中使用 BDD。&lt;/p>
&lt;h3 id="依赖的包" data-numberify>依赖的包&lt;a class="anchor ms-1" href="#依赖的包">&lt;/a>&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;cucumber.version&amp;gt;&lt;/span>4.2.5&lt;span style="color:#f92672">&amp;lt;/cucumber.version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>io.cucumber&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>cucumber-junit&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>${cucumber.version}&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;scope&amp;gt;&lt;/span>test&lt;span style="color:#f92672">&amp;lt;/scope&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>io.cucumber&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>cucumber-java&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>${cucumber.version}&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;scope&amp;gt;&lt;/span>test&lt;span style="color:#f92672">&amp;lt;/scope&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>io.cucumber&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>cucumber-spring&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>${cucumber.version}&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;scope&amp;gt;&lt;/span>test&lt;span style="color:#f92672">&amp;lt;/scope&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;h3 id="定义启动文件" data-numberify>定义启动文件&lt;a class="anchor ms-1" href="#定义启动文件">&lt;/a>&lt;/h3>
&lt;p>BDD 其实也是依赖 junit，然后调用&lt;code>Cucumber&lt;/code>的 Runner 来运行相应的测试。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> com.weibo.ad.bp.st.ryujo.web.test;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> cucumber.api.CucumberOptions;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> cucumber.api.junit.Cucumber;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> org.junit.runner.RunWith;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@RunWith&lt;/span>(Cucumber.&lt;span style="color:#a6e22e">class&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@CucumberOptions&lt;/span>(features &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;classpath:features&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tags &lt;span style="color:#f92672">=&lt;/span> {&lt;span style="color:#e6db74">&amp;#34;not @ignored&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;@base&amp;#34;&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> plugin &lt;span style="color:#f92672">=&lt;/span> {&lt;span style="color:#e6db74">&amp;#34;pretty&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;html:target/cucumber&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;junit:target/junit-report.xml&amp;#34;&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> glue &lt;span style="color:#f92672">=&lt;/span> {&lt;span style="color:#e6db74">&amp;#34;classpath:com.weibo.ad.bp.st.ryujo.web.test.step&amp;#34;&lt;/span>})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">RunCucumberTest&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>@CucumberOptions&lt;/code>中的 features，用于指定我们项目中要运行的 feature 的目录&lt;/li>
&lt;li>&lt;code>@CucumberOptions&lt;/code>中的 format，用于指定我们项目中要运行时生成的报告，并指定之后可以在 target 目录中找到对应的测试报告&lt;/li>
&lt;li>&lt;code>@CucumberOptions&lt;/code>中的 glue，用于指定项目运行时查找实现 step 定义文件的目录&lt;/li>
&lt;li>&lt;code>@CucumberOptions&lt;/code>中的 tags,用来决定想要 Cucumber 执行哪个特定标签（以及场景），标签以“@”开头，如果是排除某个特定标签，用&lt;code>&amp;quot;not @ignored&amp;quot;&lt;/code>&lt;/li>
&lt;/ul>
&lt;h3 id="定义-feature" data-numberify>定义 feature&lt;a class="anchor ms-1" href="#定义-feature">&lt;/a>&lt;/h3>
&lt;p>在项目模块的&lt;code>test/resources/features&lt;/code>目录下新建一个&lt;code>get_mid_info.feature&lt;/code> 文件&lt;/p></description></item><item><title>多线程编程</title><link>https://iliubang.cn/posts/sp/2018-12-05-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</link><pubDate>2018-12-05</pubDate><guid>https://iliubang.cn/posts/sp/2018-12-05-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</guid><description>&lt;h2 id="开始之前" data-numberify>开始之前&lt;a class="anchor ms-1" href="#开始之前">&lt;/a>&lt;/h2>
&lt;p>这篇文章主要是为了帮助大家熟悉 POSIX 线程库以及在实际开发中使用它的特性。我们会具体讲解如何利用这个线程库定义的不同工具
来解决编程中的问题。当然这里隐含了一个假设，就是读者已经了解过并行编程（或者多进程）的相关概念，如果没有这些背景知识
的话，读者可能会感觉到很难理解。不过也没关系，我的另一篇教程里边有专门为只具备线性编程思维的读者提供了对并行编程理论
和相关术语的讲解。&lt;/p>
&lt;p>同样的，我假设聪明的你已经熟悉了异步编程模型，那些经常使用桌面环境的人会更容易去接受多线程编程的理念。&lt;/p>
&lt;p>当我们谈到 POSIX 线程的时候，肯定会有人心生疑惑：“我们应该使用哪个标准下的 POSIX 线程？”。由于 POSIX 线程标准已经修订了好
多年，人们会发现，依据不同标准的实现有不同的函数集，不同的默认值和不同的细微差别。所以在此说明的是，本教程使用的是 v0.5 版的 Linux 内核中的线程库，使用其他操作系统和使用其他版本的读者，需要阅读一下你们对应的系统文档来同本文中的实例进行对应。同时，有些示例代码中使用到了阻塞式的系统调用，它们不能再用户级的线程库中很好的工作（参考另一篇文章：&lt;a href="http://www.actcom.co.il/~choo/lupg/tutorials/parallel-programming-theory/parallel-programming-theory.html#multi_thread_lib" target="_blank" rel="noopener noreferrer">parallel programming theory tutorial&lt;i class="fas fa-external-link-square-alt ms-1">&lt;/i>&lt;/a> 来获取详细信息）。好了，说了那么多，主要是为了能保证文章中的示例代码能够在其他系统中正常使用，从而提高跨平台性。&lt;/p>
&lt;h2 id="什么是线程为什么要使用线程" data-numberify>什么是线程？为什么要使用线程？&lt;a class="anchor ms-1" href="#什么是线程为什么要使用线程">&lt;/a>&lt;/h2>
&lt;p>线程是一个迷你版的进程，它们拥有自己的栈，能够执行给定的一段代码。但是不同于进程的是，线程通常与其他线程共享记忆体（而
每个进程都拥有一个独立的记忆体区域）。一个线程组就是一个执行相同代码的线程的集合，他们共用记忆体，可以访问相同的全局变
量，拥有同样的文件描述符等等，他们以并行的方式执行（可能是时间片的方式，或者对于多核心系统，他们会真正平行执行）。&lt;/p>
&lt;p>使用线程组而不是普通顺序执行程序的好处是多个操作可以同时进行，当一些事件产生的时候，他们能立马被处理（例如：如果我们有
一个线程处理用户接口，另一个线程处理数据库查询，那么我们可以在处理很多用户查询的同时，依然能够响应用户的输入）。&lt;/p>
&lt;p>使用线程组而不是进程组的好处是线程间的上下文切换要比进程间的上下文切换要快很多（上下文切换是指系统从一个正在运行的线程或进程切换到去执行另一个线程或进程）。此外，线程间的通信也远远比进程间通信要高效很多。&lt;/p>
&lt;p>线程编程有利也有弊，由于线程组共享记忆体，如果一个线程破坏了记忆体，那么其他线程也要受到牵连。但是进程就不同了，操作系
统会将进程之间隔离开，如果一个进程破坏了它的记忆体，那么其他进程不会受到影响。使用进程的另一个好处是，不同的进程可以运
行在不同的机器上，但是线程必须运行在同一台机器上（至少通常情况下是这样的）。&lt;/p>
&lt;h2 id="创建和销毁线程" data-numberify>创建和销毁线程&lt;a class="anchor ms-1" href="#创建和销毁线程">&lt;/a>&lt;/h2>
&lt;p>当一个多线程程序启动执行到&lt;code>main()&lt;/code>函数的时候，就会有一个线程运行，这是一个全程线程（full-fledged thread，或者叫主线程），如果想创建一个新的线程，程序中需要使用&lt;code>pthread_create()&lt;/code>函数&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;pthread.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">do_loop&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>data)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> i; &lt;span style="color:#75715e">// counter, to print numbers
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> j; &lt;span style="color:#75715e">// counter, for delay
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> me &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">*&lt;/span>((&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)data);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; j &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">50000&lt;/span>; j&lt;span style="color:#f92672">++&lt;/span>) &lt;span style="color:#75715e">// delay loop
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> ;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;&amp;#39;%d&amp;#39; - Got &amp;#39;%d&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, me, i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// terminate the thread
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">pthread_exit&lt;/span>(NULL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> argc, &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>argv[])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> thr_id; &lt;span style="color:#75715e">// thread ID for the newly created thread
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">pthread_t&lt;/span> p_thread; &lt;span style="color:#75715e">// thread&amp;#39;s structure
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#75715e">// thread 1 identifying number
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> b &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>; &lt;span style="color:#75715e">// thread 2 identifying number
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// create a new thread that will execute &amp;#39;do_loop()&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> thr_id &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">pthread_create&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>p_thread, NULL, do_loop, (&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">&amp;amp;&lt;/span>a);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// run &amp;#39;do_loop&amp;#39; in the main thread as well
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">do_loop&lt;/span>((&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">&amp;amp;&lt;/span>b);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上述这段代码需要特殊说明的是：&lt;/p></description></item><item><title>使用正则表达式开发一个高性能路由</title><link>https://iliubang.cn/posts/php/2018-04-16-%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E9%AB%98%E6%80%A7%E8%83%BD%E8%B7%AF%E7%94%B1/</link><pubDate>2018-04-16</pubDate><guid>https://iliubang.cn/posts/php/2018-04-16-%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E9%AB%98%E6%80%A7%E8%83%BD%E8%B7%AF%E7%94%B1/</guid><description>&lt;p>原文地址：&lt;a href="http://nikic.github.io/2014/02/18/Fast-request-routing-using-regular-expressions.html" target="_blank" rel="noopener noreferrer">http://nikic.github.io/2014/02/18/Fast-request-routing-using-regular-expressions.html&lt;i class="fas fa-external-link-square-alt ms-1">&lt;/i>&lt;/a>&lt;/p>
&lt;p>前一些日子，我发现了一个叫做&lt;a href="https://github.com/c9s/Pux" target="_blank" rel="noopener noreferrer">Pux&lt;i class="fas fa-external-link-square-alt ms-1">&lt;/i>&lt;/a>的路由库，这个路由库声称自己比现有的路由要快很多，为了实现这个特点，该库使用了 C 语言编写了 PHP 扩展。&lt;/p>
&lt;p>然而，当我瞅了几眼它的代码后，我非常怀疑这个库在路由过程中做了错误的优化，而且我能够很容易在不适用扩展的情况下做出更高性能的实现。
当我在看了 benchmarking 代码后更加确定了我的怀疑，因为我发现这里仅仅只是对及其确定的单个路由做了测试。&lt;/p>
&lt;p>为了进一步研究这个问题，我写了一个轻量的路由库：&lt;a href="https://github.com/nikic/FastRoute" target="_blank" rel="noopener noreferrer">FastRoute&lt;i class="fas fa-external-link-square-alt ms-1">&lt;/i>&lt;/a>。这个库中实现的分发过程接下来我会具体描述。为了给出一些前期印象，这里先给出一个
同 Pux 库的 benchmark 结果：&lt;/p>
&lt;pre tabindex="0">&lt;code>1 placeholder | Pux (no ext) | Pux (ext) | FastRoute
-----------------------------------------------------
First route | 0.17 s | 0.13 s | 0.14 s
Last route | 2.51 s | 1.20 s | 0.49 s
Unknown route | 2.34 s | 1.10 s | 0.34 s
9 placeholders | Pux (no ext) | Pux (ext) | FastRoute
-----------------------------------------------------
First route | 0.22 s | 0.19 s | 0.20 s
Last route | 2.65 s | 1.78 s | 0.59 s
Unknown route | 2.50 s | 1.49 s | 0.40 s
&lt;/code>&lt;/pre>&lt;p>这个 benchmark 使用了 100 个路由，分别对最好和最坏的情况做了测试。而且分两个方面进行：一个是只包含一个占位符的路由，另一个是包含 9 个占位符的路由。整个过程
重复了上千次。&lt;/p></description></item><item><title>c++编程之标准库和STL</title><link>https://iliubang.cn/posts/cpp/2018-03-19-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93%E5%92%8Cstl/</link><pubDate>2018-03-19</pubDate><guid>https://iliubang.cn/posts/cpp/2018-03-19-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93%E5%92%8Cstl/</guid><description>&lt;h2 id="1-c标准库" data-numberify>1. C++标准库&lt;a class="anchor ms-1" href="#1-c标准库">&lt;/a>&lt;/h2>
&lt;p>C++提供了很多库：&lt;/p>
&lt;ol>
&lt;li>标准 ANSI C 库都可以移植到 C++中。不同于 ANSI C 库的是，C++中需要在库名前加上&amp;quot;c&amp;quot;前缀，而且去掉&amp;quot;.h&amp;quot;，例如&lt;code>&amp;lt;cmath&amp;gt;&lt;/code>对应于 C 语言就是&lt;code>&amp;lt;math.h&amp;gt;&lt;/code>，&lt;code>&amp;lt;cstdlib&amp;gt;&lt;/code>对应于 C 语言的&lt;code>&amp;lt;stlib.h&amp;gt;&lt;/code>&lt;/li>
&lt;li>C++新增的库，例如 &lt;code>&amp;lt;iostream&amp;gt;&lt;/code>，&lt;code>&amp;lt;iomanip&amp;gt;&lt;/code>，&lt;code>&amp;lt;string&amp;gt;&lt;/code>，&lt;code>&amp;lt;fstream&amp;gt;&lt;/code>，&lt;code>&amp;lt;sstream&amp;gt;&lt;/code>&lt;/li>
&lt;li>C++STL：包括容器，迭代器，算法和函数对象&lt;/li>
&lt;li>Boost C++库&lt;/li>
&lt;/ol>
&lt;h3 id="11-c-库和相关头文件" data-numberify>1.1 C 库和相关头文件&lt;a class="anchor ms-1" href="#11-c-库和相关头文件">&lt;/a>&lt;/h3>
&lt;ul>
&lt;li>&lt;code>&amp;lt;cstring&amp;gt;&lt;/code>：待会解释&lt;/li>
&lt;li>&lt;code>&amp;lt;cmath&amp;gt;&lt;/code>：数学计算相关的库&lt;/li>
&lt;li>&lt;code>&amp;lt;cstdlib&amp;gt;&lt;/code>：通用工具，例如异常（abort, exit, EXIT_SUCCESS, EXIT_FAILURE）；环境相关（getenv）；动态内存管理（malloc, free, calloc, realloc），字符解析（atoi, atof, atol, strtod），
伪随机序列生成（rand, srand, RAND_MAX）；数组搜索和排序（bsearch, qsort）&lt;/li>
&lt;li>&lt;code>&amp;lt;cctype&amp;gt;&lt;/code>：字符类型检测（isalpha, isdigit, isalnum, isspace, isupper, islower, isblank, iscntrl, isgraph, isprint, ispunct, isxdigit）和字符转换（toupper, tolower）&lt;/li>
&lt;li>&lt;code>&amp;lt;climits&amp;gt;&lt;/code>, &lt;code>&amp;lt;cfloat&amp;gt;&lt;/code>：Size and limit of integer types (INT_MAX, INT_MIN, UINT_MAX, CHAR_BIT; and SHRT_XXX for short, LONG_XXX for long, LLONG_XXX for long long, CHAR_XXX for char) and floating-point types (DBL_MIN, DBL_MAX, DBL_DIG, DBL_MIN_EXP, DBL_MAX_EXP; and FLT_XXX for float, LDBL_XXX for long double)&lt;/li>
&lt;li>&lt;code>&amp;lt;ctime&amp;gt;&lt;/code>：time, difftime, clock, gmttime, localtime, and etc.&lt;/li>
&lt;li>&lt;code>&amp;lt;cstdio&amp;gt;&lt;/code>: C&amp;rsquo;s IO operations (scanf, printf, fscanf, fprintf, fopen, fclose, etc)&lt;/li>
&lt;li>&lt;code>&amp;lt;cassert&amp;gt;&lt;/code>, &lt;code>&amp;lt;cerrno&amp;gt;&lt;/code>, &lt;code>csignal&amp;gt;&lt;/code>: 断言和错误&lt;/li>
&lt;li>&lt;code>&amp;lt;clocale&amp;gt;&lt;/code>：本地化&lt;/li>
&lt;li>&lt;code>&amp;lt;cstdbool&amp;gt;&lt;/code>, &lt;code>&amp;lt;cstdint&amp;gt;&lt;/code>, &lt;code>&amp;lt;cstddef&amp;gt;&lt;/code>, &lt;code>&amp;lt;cstdarg&amp;gt;&lt;/code>:&lt;/li>
&lt;li>&lt;code>&amp;lt;cuchar&amp;gt;&lt;/code>, &lt;code>&amp;lt;cwchar&amp;gt;&lt;/code>, &lt;code>&amp;lt;cwcchar&amp;gt;&lt;/code>: Unicode 字符&lt;/li>
&lt;/ul>
&lt;h3 id="12-c库和相关头文件" data-numberify>1.2 C++库和相关头文件&lt;a class="anchor ms-1" href="#12-c库和相关头文件">&lt;/a>&lt;/h3>
&lt;ul>
&lt;li>&lt;code>&amp;lt;ios&amp;gt;, &amp;lt;iostream&amp;gt;, &amp;lt;istream&amp;gt;, &amp;lt;ostream&amp;gt;, &amp;lt;fstream&amp;gt;, &amp;lt;sstream&amp;gt;&lt;/code>&lt;/li>
&lt;li>&lt;code>&amp;lt;iomanip&amp;gt;&lt;/code>&lt;/li>
&lt;li>&lt;code>&amp;lt;string&amp;gt;&lt;/code>&lt;/li>
&lt;li>&lt;code>&amp;lt;regex&amp;gt;&lt;/code>&lt;/li>
&lt;li>&lt;code>&amp;lt;random&amp;gt;&lt;/code>&lt;/li>
&lt;li>&lt;code>&amp;lt;limits&amp;gt;&lt;/code>&lt;/li>
&lt;li>&lt;code>&amp;lt;stdexception&amp;gt;, &amp;lt;exception&amp;gt;&lt;/code>&lt;/li>
&lt;li>&lt;code>&amp;lt;complex&amp;gt;, &amp;lt;tuple&amp;gt;, &amp;lt;valarry&amp;gt;&lt;/code>&lt;/li>
&lt;li>&lt;code>&amp;lt;locale&amp;gt;&lt;/code>&lt;/li>
&lt;li>&lt;code>&amp;lt;typeinfo&amp;gt;&lt;/code>&lt;/li>
&lt;li>&lt;code>&amp;lt;chrono&amp;gt;&lt;/code>&lt;/li>
&lt;li>其它：&lt;code>&amp;lt;codecvt&amp;gt;, &amp;lt;new&amp;gt;, &amp;lt;ratio&amp;gt;, &amp;lt;system_error&amp;gt;, &amp;lt;type_traits&amp;gt;&lt;/code>&lt;/li>
&lt;/ul>
&lt;h3 id="13-c-stl-和相关头文件" data-numberify>1.3 C++ STL 和相关头文件&lt;a class="anchor ms-1" href="#13-c-stl-和相关头文件">&lt;/a>&lt;/h3>
&lt;p>STL 主要由以下头文件提供：&lt;/p></description></item><item><title>c++编程之字符和字符串</title><link>https://iliubang.cn/posts/cpp/2018-03-15-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/</link><pubDate>2018-03-15</pubDate><guid>https://iliubang.cn/posts/cpp/2018-03-15-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid><description>&lt;h2 id="1-字符" data-numberify>1. 字符&lt;a class="anchor ms-1" href="#1-字符">&lt;/a>&lt;/h2>
&lt;h3 id="11-字符类型库头文件cctype" data-numberify>1.1 字符类型库：头文件"cctype"&lt;a class="anchor ms-1" href="#11-字符类型库头文件cctype">&lt;/a>&lt;/h3>
&lt;p>在头文件&lt;code>&amp;lt;cctype&amp;gt;&lt;/code>（相当于 C 语言中的&lt;code>&amp;lt;ctype.h&amp;gt;&lt;/code>），包含了一下字符处理函数：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>FUNCTION&lt;/th>
&lt;th>EXAMPLE&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>int isalpha(int ch);//如果 ch 是字母，返回 1，否则 0&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>int isdigit(int ch);//如果 ch 是数字，返回 1，否则 0&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>int isalnum(int ch);//如果 ch 是字母或数字，返回 1，否则 0&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>int isxdigit(int ch);//如果 ch 是十六进制数字[0-9A-Fa-f]，返回 1&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>int isupper(int ch);//如果 ch 是大写字母，返回 1&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>int islower(int ch);//如果 ch 是小写字母，返回 1&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>int toupper(int ch);//转成大写字母&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>int tolower(int ch);//转成小写&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>int isspace(int ch);&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>int ispunct(int ch);//是否是标点符号&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>int iscntrl(int ch);//是否是 control&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>int isprint(int ch);//是否是可打印字符&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>int isgraph(int ch);//是否图形表示&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="2-字符串c-string-和-string-类" data-numberify>2. 字符串：C-String 和 string 类&lt;a class="anchor ms-1" href="#2-字符串c-string-和-string-类">&lt;/a>&lt;/h2>
&lt;p>回顾一下，我们知道 C++支持两种类型的字符串：&lt;/p></description></item><item><title>c++编程之操作符重载</title><link>https://iliubang.cn/posts/cpp/2018-03-14-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/</link><pubDate>2018-03-14</pubDate><guid>https://iliubang.cn/posts/cpp/2018-03-14-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/</guid><description>&lt;p>操作符重载就是指操作符会对不同类型的操作数表现出不同的行为。例如：(a) 按位左移操作符&amp;rsquo;&amp;laquo;&amp;lsquo;在操作流对象的时候就变成了插入操作；(b) &lt;code>*&lt;/code>操作符操作于两个数字的时候就是乘法操作，而作用于
地址的时候就是间接寻址操作。C++允许你再用户端扩展操作符重载。&lt;/p>
&lt;p>操作符重载就像函数重载那样，同一个函数名可以因为参数不同而同时存在很多版本。&lt;/p>
&lt;h2 id="1-string-类中重载的操作符" data-numberify>1. string 类中重载的操作符&lt;a class="anchor ms-1" href="#1-string-类中重载的操作符">&lt;/a>&lt;/h2>
&lt;p>C++的&amp;quot;string&amp;quot;类中重载了以下操作符来作用于&amp;quot;string&amp;quot;对象：&lt;/p>
&lt;ul>
&lt;li>字符串比较操作(=,!=,&amp;gt;,&amp;lt;,&amp;gt;=,&amp;lt;=)：例如，使用&lt;code>str1 == str2&lt;/code>来比较两个&amp;quot;string&amp;quot;对象&lt;/li>
&lt;li>流插入和取出操作(&amp;laquo;,&amp;raquo;)：例如，你可以使用&lt;code>cout &amp;lt;&amp;lt; st1&lt;/code>和&lt;code>cin &amp;gt;&amp;gt; str2&lt;/code>来输出/输入&amp;quot;string&amp;quot;对象&lt;/li>
&lt;li>字符串连接(+,+=)：例如，&lt;code>str1 + str2&lt;/code>，将两个&amp;quot;string&amp;quot;对象合并成一个新的&amp;quot;string&amp;quot;对象，&lt;code>str1 += str2&lt;/code>将&lt;code>str2&lt;/code>追加到&lt;code>str1&lt;/code>后&lt;/li>
&lt;li>字符索引或下标([])：例如，你可以使用&lt;code>str[n]&lt;/code>来获取下标为 n 的字符；或者&lt;code>str[n] = c&lt;/code>来修改下标为 n 处的字符。需要注意的是&amp;rsquo;[]&amp;lsquo;操作符不会
做边界检测，也就是说，你需要自己保证下标不会超出边界，你可以使用&amp;quot;string&amp;quot;类的&lt;code>at()&lt;/code>函数来做边界检测&lt;/li>
&lt;li>赋值(=)：例如，&lt;code>str1 = str2&lt;/code>，将&lt;code>str2&lt;/code>赋值给&lt;code>str1&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>示例代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iomanip&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;string&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> argc, &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>argv[]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> string msg1(&lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> string msg2(&lt;span style="color:#e6db74">&amp;#34;HELLO&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> string msg3(&lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> boolalpha;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> (msg1 &lt;span style="color:#f92672">==&lt;/span> msg2) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> (msg1 &lt;span style="color:#f92672">==&lt;/span> msg3) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> (msg1 &lt;span style="color:#f92672">&amp;lt;&lt;/span> msg2) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> string msg4 &lt;span style="color:#f92672">=&lt;/span> msg1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> msg4 &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> (msg1 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> msg2) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> msg3 &lt;span style="color:#f92672">+=&lt;/span> msg2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> msg3 &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> msg1[&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> msg1[&lt;span style="color:#ae81ff">99&lt;/span>] &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;h2 id="2-用户自定义操作符重载" data-numberify>2. 用户自定义操作符重载&lt;a class="anchor ms-1" href="#2-用户自定义操作符重载">&lt;/a>&lt;/h2>
&lt;h3 id="21-operator函数" data-numberify>2.1 operator"函数&lt;a class="anchor ms-1" href="#21-operator函数">&lt;/a>&lt;/h3>
&lt;p>为了实现操作符重载，我们需要使用一种特殊的函数形式，叫做操作符函数。操作符函数形如：&amp;ldquo;operator Δ()&amp;quot;，Δ 就是将要被重载的操作符。&lt;/p></description></item><item><title>c++编程之模板和泛型编程</title><link>https://iliubang.cn/posts/cpp/2018-03-14-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/</link><pubDate>2018-03-14</pubDate><guid>https://iliubang.cn/posts/cpp/2018-03-14-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/</guid><description>&lt;h2 id="1-简介" data-numberify>1. 简介&lt;a class="anchor ms-1" href="#1-简介">&lt;/a>&lt;/h2>
&lt;p>我们对传递数值或变量给函数都很熟悉，除了传递变量，我们还能传递类型给模板。传递类型就是大家所熟知的泛型编程，因为
我们可以用泛型编写程序，而用特定的类型调用。&lt;/p>
&lt;p>泛型编程的目的是为了编写的程序不依赖于数据类型。在 C 语言中，所有的代码都需要绑定到确定的数据类型，这样写的代码只能对特定的数据类型起作用。
而模板可以让我们实现泛型编程。你可以将类型作为参数来构建模板函数和类模板。当你的算法需要作用于多种数据类型的时候，模板就显得及其有用了。&lt;/p>
&lt;p>C++的标准模板库(STL)提供了一些常用的容器类模板的实现，例如&lt;code>vector&lt;/code>，可以用来存放所有类型的元素。&lt;/p>
&lt;h2 id="2-示例stl-中的-vector-类模板" data-numberify>2. 示例：STL 中的 vector 类模板&lt;a class="anchor ms-1" href="#2-示例stl-中的-vector-类模板">&lt;/a>&lt;/h2>
&lt;p>C/C++中的内置数组有一些缺点：&lt;/p>
&lt;ol>
&lt;li>它的大小是固定的，需要在声明的时候确定大小，不支持动态声明。你不能在执行期给数组扩容；&lt;/li>
&lt;li>数组不提供下标边界校验，你可以使用超出边界的下标&lt;/li>
&lt;li>你需要自己实现数组比较，和赋值操作&lt;/li>
&lt;/ol>
&lt;p>C++提供了一个&lt;code>vector&lt;/code>类模板，作为标准模板库(STL)的一部分。&lt;code>vector&lt;/code>被定义在&lt;code>&amp;lt;vector&amp;gt;&lt;/code>头文件中，属于&lt;code>std&lt;/code>命名空间。vector 是最常用的 STL 类，它能够取代数组，并且支持动态分配空间和一些其它操作（例如比较和赋值）。&lt;/p>
&lt;p>vector 是一个类模板，它可以被特定类型的实例化，形如：&lt;code>vector&amp;lt;int&amp;gt;&lt;/code>, &lt;code>vector&amp;lt;double&amp;gt;&lt;/code>, &lt;code>vector&amp;lt;string&amp;gt;&lt;/code>。同一个模板能够用于多种类型，而不必为每种类型都写一套实现。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;vector&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;string&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">print&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>v);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> argc, &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>argv[]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> v1(&lt;span style="color:#ae81ff">5&lt;/span>); &lt;span style="color:#75715e">// Create a vector with 5 elements.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Assign values into v1, using array-like index []
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// You can retrieve the size of vector via size()
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> v1.size(); i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> v1[i] &lt;span style="color:#f92672">=&lt;/span> (i &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Print vector content, using at()
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> v1.size(); i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> v1.at(i) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> v2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Assign v1 to v2 memberwise
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> v2 &lt;span style="color:#f92672">=&lt;/span> v1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> v2.size(); i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> v2[i] &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Compare 2 vectors memberwise
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> boolalpha &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> (v1 &lt;span style="color:#f92672">==&lt;/span> v2) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Append more elements - synamically allocate memory
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> v1.push_back(&lt;span style="color:#ae81ff">80&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> v1.push_back(&lt;span style="color:#ae81ff">81&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> v1.size(); i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> v1[i] &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>string&lt;span style="color:#f92672">&amp;gt;&lt;/span> v3;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> v3.push_back(&lt;span style="color:#e6db74">&amp;#34;a for apple&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> v3.push_back(&lt;span style="color:#e6db74">&amp;#34;b for boy&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> v3.size(); i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> v3[i] &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>说明：&lt;/p></description></item><item><title>c++编程之继承和多态</title><link>https://iliubang.cn/posts/cpp/2018-03-05-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/</link><pubDate>2018-03-05</pubDate><guid>https://iliubang.cn/posts/cpp/2018-03-05-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/</guid><description>&lt;h2 id="1-继承" data-numberify>1. 继承&lt;a class="anchor ms-1" href="#1-继承">&lt;/a>&lt;/h2>
&lt;h3 id="11-术语" data-numberify>1.1 术语&lt;a class="anchor ms-1" href="#11-术语">&lt;/a>&lt;/h3>
&lt;p>超类（基类）和子类（派生类）：在面向对象程序设计中，我们通常使用继承来避免代码冗余。在 C++中，继承的语法规则如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SubclassName&lt;/span> &lt;span style="color:#f92672">:&lt;/span> inheritance&lt;span style="color:#f92672">-&lt;/span>access&lt;span style="color:#f92672">-&lt;/span>specifier SuperclassName {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>子类继承了父类所有的成员，子类也可以定义自己的构造器和成员。&lt;/p>
&lt;p>&lt;strong>访问标识符&lt;/strong>：C++支持三种访问标识符：&lt;code>private&lt;/code>，&lt;code>public&lt;/code>和&lt;code>protected&lt;/code>。一个类的 public 成员变量、成员函数，可以通过类的成员函数、类的实例变量进行访问。
一个类的 protected 成员变量、成员函数，无法通过类的实例变量进行访问。但是可以通过类的友元函数、友元类进行访问。一个类的 private 成员变量、成员函数，无法通过类的实例变量进行访问。但是可以通过类的友元函数、友元类进行访问。&lt;/p>
&lt;p>&lt;strong>继承访问标识符&lt;/strong>：public 继承不改变基类成员的访问权限，private 继承使得基类所有成员在子类中的访问权限变为 private，protected 继承将基类中 public 成员变为子类的 protected 成员，其它成员的访问 权限不变。
基类中的 private 成员不受继承方式的影响，子类永远无权访问。&lt;/p>
&lt;h3 id="12-一个示例" data-numberify>1.2 一个示例&lt;a class="anchor ms-1" href="#12-一个示例">&lt;/a>&lt;/h3>
&lt;p>&lt;picture>&lt;img class="img-fluid mx-auto d-block" alt="" src="https://iliubang.cn/images/2018-03-05/ClassDiagram_MovablePoint.png#center?v=7fdc4e1b5785be32c88d453deb32ca63" loading="lazy" width="289" height="584" />
&lt;/picture>
&lt;/p>
&lt;p>MovablePoint.h&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#ifndef MOVING_POINT_H
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define MOVING_POINT_H
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;#34;Point.h&amp;#34;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MoviablePoint&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> Point {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> xSpeed, ySpeed;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MovablePoint(&lt;span style="color:#66d9ef">int&lt;/span> x, &lt;span style="color:#66d9ef">int&lt;/span> y, &lt;span style="color:#66d9ef">int&lt;/span> xSpeed &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#66d9ef">int&lt;/span> ySpeed &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">getXSpeed&lt;/span>() &lt;span style="color:#66d9ef">const&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">getYSpeed&lt;/span>() &lt;span style="color:#66d9ef">const&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">setXSpeed&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> xSpeed);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">setYSpeed&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> ySpeed);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">move&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">print&lt;/span>() &lt;span style="color:#66d9ef">const&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#endif
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>MovablePoint.cpp&lt;/p></description></item><item><title>c++编程之OOP示例</title><link>https://iliubang.cn/posts/cpp/2018-03-02-c++%E7%BC%96%E7%A8%8B%E4%B9%8Boop%E7%A4%BA%E4%BE%8B/</link><pubDate>2018-03-02</pubDate><guid>https://iliubang.cn/posts/cpp/2018-03-02-c++%E7%BC%96%E7%A8%8B%E4%B9%8Boop%E7%A4%BA%E4%BE%8B/</guid><description>&lt;h2 id="1-示例使用引用的time类" data-numberify>1. 示例：使用引用的"Time"类&lt;a class="anchor ms-1" href="#1-示例使用引用的time类">&lt;/a>&lt;/h2>
&lt;p>回到之前版本的&amp;quot;Time&amp;quot;类，假设我们想增加链式操作，例如&lt;code>t.nextSecond().nextSecond().print()&lt;/code>，我们就需要让&lt;code>nextSecond()&lt;/code>返回&lt;code>this&lt;/code>的一个引用。&lt;/p>
&lt;p>Time.h&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Time&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Time &lt;span style="color:#f92672">&amp;amp;&lt;/span>nextSecond(); &lt;span style="color:#75715e">// Return a reference to &amp;#34;this&amp;#34; instance
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> ......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在函数原型中，我们申明了一个&lt;code>nextSecond()&lt;/code>的成员函数，返回&lt;code>Time&lt;/code>对象的引用。返回的引用可以用来继续调用成员函数。&lt;/p>
&lt;p>Time.cpp&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Increase this instance by one second and return this instance by reference.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>Time &lt;span style="color:#f92672">&amp;amp;&lt;/span>Time&lt;span style="color:#f92672">::&lt;/span>nextSecond() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">++&lt;/span>second &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">60&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> second &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">++&lt;/span>minute &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">60&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> minute &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">++&lt;/span>hour &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">24&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hour &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">this&lt;/span>; &lt;span style="color:#75715e">// Return this instance by reference
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// &amp;#34;this&amp;#34; is a pointer to this instance. *this refers to the instance.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>C++有一个关键字&amp;quot;this&amp;quot;，它保存了一个指向当前实例的指针。也就是说，&lt;code>*this&lt;/code>指的是当前实例。&lt;/p></description></item><item><title>c++编程之指针，引用和内存动态分配</title><link>https://iliubang.cn/posts/cpp/2018-02-23-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D/</link><pubDate>2018-02-23</pubDate><guid>https://iliubang.cn/posts/cpp/2018-02-23-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D/</guid><description>&lt;p>指针，引用和动态分配内存是 C/C++语言中最强大的特性，这些特性使得程序员能够直接操作计算机中非常珍贵的记忆体资源，进而对内存进行最大性能和高效的使用。
然而指针也是一把双刃剑，它也是 C/C++编程语言中最复杂和最难的特性。&lt;/p>
&lt;p>指针之所以这么强大，是因为它允许你通过地址来访问和操作对应记忆体中存储的内容。但是指针也很难被驾驭，使用好的话确实能够大大提升性能，而用的
不好的话，也会导致很多问题，例如著名的内存泄漏和缓冲区溢出，这些 bug 会致使系统发生紊乱。一些新的编程语言（例如 Java 和 C#），将指针从它的语法
中去掉，通过提供自动内存管理的方式来避免使用指针导致的许多问题。&lt;/p>
&lt;p>虽然你在编写 C/C++代码的时候可以不使用指针，但是在学习 C/C++的时候很难不提及指针。指针也许不是为新手和笨蛋而设计的。&lt;/p>
&lt;h2 id="1-指针变量" data-numberify>1. 指针变量&lt;a class="anchor ms-1" href="#1-指针变量">&lt;/a>&lt;/h2>
&lt;p>计算机记忆体位置有一个地址，对应地址处保存数据。记忆体地址通常是一个数字（一般用十六进制表示），这个数字很难被程序员直接使用。通常一个地址位置
的容量是 8-bit（也就是 1-byte），里面可以存储整数，实数，字符或者字符串，这完全取决于程序员如何解析。&lt;/p>
&lt;p>为了减轻程序员使用数字地址和解析数据的负担，早期的编程语言（例如 C 语言）中产生了一种新的变量——这种变量是一个被命名了的变量的位置，它可以存储一个特定类型的值。
取代数字地址的是用名字（或者标识符）直接关联到确定的地址上，而且变量类型（如&lt;code>int&lt;/code>, &lt;code>double&lt;/code>, &lt;code>char&lt;/code>）与之关联，从而简化了对数据的解析。&lt;/p>
&lt;p>每个内存地址占 8 位（也就是 1 个字节），一个 4 个字节的&lt;code>int&lt;/code>值需要 4 个内存位置。一个 32 位的系统通常使用 32 位的地址。同样的，存储这个 32 位的地址也需要 4 个内存位置。&lt;/p>
&lt;p>下面的插图形象的描绘了计算机内存地址，内存中数据，变量名，变量类型以及变量值之间的关系。&lt;/p>
&lt;p>&lt;picture>&lt;img class="img-fluid mx-auto d-block" alt="" src="https://iliubang.cn/images/2018-02-23/MemoryAddressContent.png#center?v=7fdc4e1b5785be32c88d453deb32ca63" loading="lazy" width="661" height="503" />
&lt;/picture>
&lt;/p>
&lt;h3 id="11-指针变量" data-numberify>1.1 指针变量&lt;a class="anchor ms-1" href="#11-指针变量">&lt;/a>&lt;/h3>
&lt;p>指针变量（简称指针）基本上跟其他变量一样，都可以用来存放数据，但是跟普通变量不同的是，普通变量存储的是数值，而指针存放的是内存地址。&lt;/p>
&lt;h3 id="12-申明指针" data-numberify>1.2 申明指针&lt;a class="anchor ms-1" href="#12-申明指针">&lt;/a>&lt;/h3>
&lt;p>指针在使用前必须先申明。申明指针的语法是在指针名前加上一个&lt;code>*&lt;/code>符号。指针必须跟类型关联。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>type &lt;span style="color:#f92672">*&lt;/span>ptr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// or
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>type&lt;span style="color:#f92672">*&lt;/span> ptr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// or
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>type &lt;span style="color:#f92672">*&lt;/span> ptr;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>例如：&lt;/p></description></item><item><title>c++编程之面向对象</title><link>https://iliubang.cn/posts/cpp/2018-02-13-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link><pubDate>2018-02-13</pubDate><guid>https://iliubang.cn/posts/cpp/2018-02-13-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid><description>&lt;h2 id="1-为什么要使用-oop" data-numberify>1. 为什么要使用 OOP？&lt;a class="anchor ms-1" href="#1-为什么要使用-oop">&lt;/a>&lt;/h2>
&lt;p>假如你想组装一台电脑，你会去硬件商店购买主板、处理器、内存条、硬盘、机箱、电源，然后将它们组装在一起，然后打开电源，电脑就能运行。
你不用考虑主板是 4 重板还是 6 重板，硬盘是什么尺寸，内存是哪里生产的诸如此类的问题。你只需要将这些硬件单元组合在一起，就能期待电脑能够运行。
当然，你需要保证你有正确的接口，比如，如果你的主板只支持 IDE 接口，而你需要购买一个 IDE 的硬盘而不是 SCSI 硬盘，又例如你需要选择一个合适速率的
内存。即便如此，将硬件组件组装成一台机器也没有任何难度。&lt;/p>
&lt;p>同样的，一辆车也是由多个部分组装起来的，例如底盘、车门、引擎、车轮、刹车和传动装置。这些组件都是可复用的。比如车轮，就能够被用于很多辆同型号的骑车上。&lt;/p>
&lt;p>像电脑和汽车这样的硬件能够用可复用的部分组装起来。那么软件是否也是如此呢？我们是否能够将不同地方的程序片段“组装”起来，然后期待程序能正常运行呢？
答案显然是 no！跟硬件不同的是，很难从软件片段中“组装”一个应用。自从计算机 60 年前问世以来，人们写了大量的程式码。然而，对于每一个新的应用程序，我们都需要
重新造轮子。&lt;/p>
&lt;p>为什么要重新造轮子呢？&lt;/p>
&lt;h3 id="11-传统的面向过程的编程语言" data-numberify>1.1 传统的面向过程的编程语言&lt;a class="anchor ms-1" href="#11-传统的面向过程的编程语言">&lt;/a>&lt;/h3>
&lt;p>&lt;picture>&lt;img class="img-fluid mx-auto d-block" alt="" src="https://iliubang.cn/images/2018-02-13/OOP_CFunction.png#center?v=7fdc4e1b5785be32c88d453deb32ca63" loading="lazy" width="326" height="335" />
&lt;/picture>
&lt;/p>
&lt;p>传统的面向过程的编程语言（例如 C 和 Pascal）在创建可重用组件方面遇到了一些显著的缺陷：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>程序是由函数组织起来的。函数通常是不可重用的，我们很难将一个函数直接拷贝到别的地方去使用，因为函数很有可能引用了头文件，或者全局变量，或者调用了其他函数。
换句话说，函数不能很好的封装成一个独立的可重用单元。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>面向过程的语言不适合高层抽象来解决现实生活中的问题。例如 c 程序使用&amp;quot;if-else&amp;quot;, &amp;ldquo;for-loop&amp;rdquo;, &amp;ldquo;array&amp;rdquo;, &amp;ldquo;function&amp;rdquo;, &amp;ldquo;pointer&amp;quot;等结构，这些结构很低阶而且很难抽象形如
Customer Relationship Management (CRM) 系统或者电脑足球游戏。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>简而言之，传统的面向过程的编程语言将数据结构和算法单元分开了。&lt;/p>
&lt;h3 id="12-面向对象的编程语言" data-numberify>1.2 面向对象的编程语言&lt;a class="anchor ms-1" href="#12-面向对象的编程语言">&lt;/a>&lt;/h3>
&lt;p>&lt;picture>&lt;img class="img-fluid mx-auto d-block" alt="" src="https://iliubang.cn/images/2018-02-13/OOP_Objects.png#center?v=7fdc4e1b5785be32c88d453deb32ca63" loading="lazy" width="538" height="351" />
&lt;/picture>
&lt;/p>
&lt;p>面向对象的编程语言就是被设计来克服这些问题的。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>OOP 的基础单元是类。类将静态属性和动态行为封装在一起，同时指定一些公开的接口来供人使用。由于相比于函数，类有很好的封装性，所以很容易重用。换句话说，类将数据和算法结合在了一起。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>面向对象的编程语言为解决现实问题的高阶抽象提供了保证。面向过程的编程语言迫使人们把注意力放在计算机结构（如：内存，位，字节，数组）上，而不是放在要解决的问题本身。面向对象的编程语言
能够让我们更专注于问题本身，使用程序对象来表示和抽象问题中的各种实体。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>举个例子，假设你要写一个足球游戏，很难用面向过程的语言建立模型。但是使用 OOP，可以很容易将现实事物同程序之间建立模型：&lt;/p>
&lt;ul>
&lt;li>Player：属性包含 name, number, location 等待，操作有 run, jump, kick-the-ball&amp;hellip;&lt;/li>
&lt;li>Ball:&lt;/li>
&lt;li>Reference:&lt;/li>
&lt;li>Field:&lt;/li>
&lt;li>Audience:&lt;/li>
&lt;li>Weather:&lt;/li>
&lt;/ul>
&lt;p>最重要的是，这其中的一些类（例如：Ball 和 Audience）可以在其他程序中复用。&lt;/p></description></item><item><title>PHP7虚拟机</title><link>https://iliubang.cn/posts/php/2017-11-29-php7%E8%99%9A%E6%8B%9F%E6%9C%BA/</link><pubDate>2017-11-29</pubDate><guid>https://iliubang.cn/posts/php/2017-11-29-php7%E8%99%9A%E6%8B%9F%E6%9C%BA/</guid><description>&lt;p>原文地址&lt;a href="http://nikic.github.io/2017/04/14/PHP-7-Virtual-machine.html" target="_blank" rel="noopener noreferrer">http://nikic.github.io/2017/04/14/PHP-7-Virtual-machine.html&lt;i class="fas fa-external-link-square-alt ms-1">&lt;/i>&lt;/a>&lt;/p>
&lt;p>写这篇文章的目的是基于 php7，阐述 Zend Virtual Machine 的内部实现。这不是一篇综合描述，我将尽可能地覆盖到所有重要的部分和细节。&lt;/p>
&lt;p>本文的描述对象是 php7.2 版本，但是几乎所有的特性都已经应用在了 php7.0/7.1 中了。然而，它们同 php5.x 系列 VM 的不同之处同样也很重要，我会很有耐心的同步描述。&lt;/p>
&lt;p>这篇文章主要是从指令的角度来阐述，只有在末尾花了少量篇幅描述了 C 语言实现 VM 的细节。但是在文章开始之前，我想先提供一些实现 VM 的主要代码文件：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/php/php-src/blob/master/Zend/zend_vm_def.h" target="_blank" rel="noopener noreferrer">zend_vm_def.h&lt;i class="fas fa-external-link-square-alt ms-1">&lt;/i>&lt;/a>: VM 定义文件&lt;/li>
&lt;li>&lt;a href="https://github.com/php/php-src/blob/master/Zend/zend_vm_execute.h" target="_blank" rel="noopener noreferrer">zend_vm_execute.h&lt;i class="fas fa-external-link-square-alt ms-1">&lt;/i>&lt;/a>: 生成的 VM&lt;/li>
&lt;li>&lt;a href="https://github.com/php/php-src/blob/master/Zend/zend_vm_gen.php" target="_blank" rel="noopener noreferrer">zend_vm_gen.php&lt;i class="fas fa-external-link-square-alt ms-1">&lt;/i>&lt;/a>: VM 生成脚本&lt;/li>
&lt;li>&lt;a href="https://github.com/php/php-src/blob/master/Zend/zend_execute.c" target="_blank" rel="noopener noreferrer">zend_execute.c&lt;i class="fas fa-external-link-square-alt ms-1">&lt;/i>&lt;/a>: 大多数直接支持的代码&lt;/li>
&lt;/ul>
&lt;h2 id="opcodes" data-numberify>Opcodes&lt;a class="anchor ms-1" href="#opcodes">&lt;/a>&lt;/h2>
&lt;p>首先我们来聊聊 opcode。&amp;ldquo;Opcode&amp;quot;是用来表示整个 VM 指令集（包括操作数）的，但是也可能仅仅就是指“真实的”操作码，这些操作码是一个很小的整数用来区分不同的指令类型。其具体的含义需要结合代码的上下文才能清楚。在程式码中，指令通常被称作&amp;quot;oplines&amp;rdquo;。&lt;/p>
&lt;p>下面是&lt;code>zend_op&lt;/code>的结构&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> _zend_op {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>handler;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> znode_op op1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> znode_op op2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> znode_op result;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">uint32_t&lt;/span> extended_value;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">uint32_t&lt;/span> lineno;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zend_uchar opcode;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zend_uchar op1_type;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zend_uchar op2_type;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zend_uchar result_type;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>由此看来，opcodes 本质上就是一个“三地址码”格式的指令。有一个&lt;code>opcode&lt;/code>代表指令的类型，有两个输入操作数&lt;code>op1&lt;/code>和&lt;code>op2&lt;/code>和一个输出操作数&lt;code>result&lt;/code>。&lt;/p></description></item><item><title>PHP和线程</title><link>https://iliubang.cn/posts/php/2017-10-12-php%E5%92%8C%E7%BA%BF%E7%A8%8B/</link><pubDate>2017-10-12</pubDate><guid>https://iliubang.cn/posts/php/2017-10-12-php%E5%92%8C%E7%BA%BF%E7%A8%8B/</guid><description>&lt;p>原文地址&lt;a href="http://blog.jpauli.tech/2017/01/12/threads-and-php.html" target="_blank" rel="noopener noreferrer">http://blog.jpauli.tech/2017/01/12/threads-and-php.html&lt;i class="fas fa-external-link-square-alt ms-1">&lt;/i>&lt;/a>&lt;/p>
&lt;h2 id="前言" data-numberify>前言&lt;a class="anchor ms-1" href="#前言">&lt;/a>&lt;/h2>
&lt;p>PHP 和线程，单凭这简短的几个字，就足以写一本书。像往常一样，我们不会这么做，但是会给出一定程度上跟这个话题相关的信息与细节。让我们从一些人在谈论这个话题时通常感到的困惑开始，PHP 不是一种线程语言，
PHP 的内核没有使用线程，而且 PHP 天生也不允许用户层代码通过任何方式使用多线程作为并发机制。&lt;/p>
&lt;p>因此 PHP 跟其他一些技术有很大的区别，例如 Java。Java 不仅自身使用了大量的线程，它还允许用户通过编程来是用线程。然而，PHP 不适用线程是有它的原因的。&lt;/p>
&lt;p>PHP 内核没有使用线程，主要是为了简化开发。当你读到下一节的时候，你就会了解到线程并不是一个能使任何程序都能更快运行的魔法技术。是不是听起来很像是在推销不是吗？但是我们不是推销，而是谈论技术，而且
我们很清楚我们在说什么。因此 PHP 引擎目前没有使用多线程，也许将来会使用。但是使用多线程在编程上会引发很多问题，例如程序运行结果不是你所期待的等等。主要的困难是跨平坦的多线程编程，其次就是资源共享和
锁的管理，再次就是并不是所有的程序都能够被转化成多线程程序。PHP 的设计主要在 2000 前后，在那个时候，多线程编程并不是很广泛和成熟，PHP 引擎开发工程师决定创造一个完全没有线程的单片机引擎（当然他们也没有
足够的能力去驾驭一个稳定的跨平台的多线程引擎）。&lt;/p>
&lt;p>PHP 用户层代码也不允许使用线程，因为那不是 PHP 期待你的代码运行的方式。PHP 是一个&amp;quot;发送并忘记(fire-and-forget)&amp;ldquo;型的语言，你应该尽可能快的处理完请求，然后释放，然后接着处理下一个请求。PHP 被设计作为一种
胶水语言：你不用处理可能使用到线程的复杂任务，而是访问快速而且已经准备好的资源，将它们粘合到一起，然后再返回给用户。通过 PHP，无论什么可能花费比通常时间多的时间的任务，都不能用 PHP 来处理。这就是为什么
在 PHP 中我们通常使用基于消息队列的系统(Gearman, AMQP, ActiveMQ 等等)来异步处理一些耗时任务。正如 Unix 看待事物的方式：“开发小而完备的工具，然后将他们连接在一起”。因此 PHP 的设计不是允许大规模的并行，而是
其他专门的技术&amp;ndash;是用正确的工具来解决特定的问题。&lt;/p>
&lt;h2 id="线程的简介" data-numberify>线程的简介&lt;a class="anchor ms-1" href="#线程的简介">&lt;/a>&lt;/h2>
&lt;p>让我们来快速的介绍下线程。注意，我们不会阐述太多细节的东西，对于你想深入了解关于线程的任何细节，都可以在相关书籍和站点上找到。&lt;/p>
&lt;p>线程是进程中的轻量的事务处理单元，注意，一个进程可以产生多个线程，一个线程必须有且只能属于一个进程。进程是操作系统中的基本工作处理单元。在多 CPU 的机器上，不同的 CPU 将会平行工作，这样对于计算能力的提升会
有很大的好处。如果进程 A 和 B 都准备被执行，而且两个 CPU（或者两个 CPU 核心）也都有空闲的负载，那么进程 A 和 B 将会同时被执行。因此，计算机将能高效的在一个单位时间内同时进行多个运算，我们称之为“并行”(parallelism)。&lt;/p></description></item><item><title>理解c语言中的声明</title><link>https://iliubang.cn/posts/sp/2017-09-12-%E7%90%86%E8%A7%A3c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%A3%B0%E6%98%8E/</link><pubDate>2017-09-12</pubDate><guid>https://iliubang.cn/posts/sp/2017-09-12-%E7%90%86%E8%A7%A3c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%A3%B0%E6%98%8E/</guid><description>&lt;p>在阅读优秀的 c 语言开源程式的时候，我们经常会看到各种复杂的声明，顿时会让我们怀疑人生，怀疑自己是否真的看得懂 c 语言。然而冷静三秒钟，透过现象看本质，发现牛人写的代码并不是“天书”，
也是很好懂的，关键是要冷静和耐心去阅读。&lt;/p>
&lt;h2 id="从c-traps-and-pitfallshttpwwwliterateprogrammingcomctrapspdf中的一个例子说起" data-numberify>从中的一个例子说起&lt;a class="anchor ms-1" href="#从c-traps-and-pitfallshttpwwwliterateprogrammingcomctrapspdf中的一个例子说起">&lt;/a>&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>)())&lt;span style="color:#ae81ff">0&lt;/span>)()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>下面我们来一步步分析：&lt;/p>
&lt;p>我们知道变量的声明方式为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> a;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>函数的声明方式为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">fn&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>指针的声明方式为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">*&lt;/span>a &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>函数指针的声明方式为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>fn)(); &lt;span style="color:#75715e">//fn 是一个指向返回int型的函数的指针
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>函数指针的调用方式：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#a6e22e">int&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>fn_type)();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">fn&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fn_type a &lt;span style="color:#f92672">=&lt;/span> fn;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">a&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//或者
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, (&lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#a6e22e">a&lt;/span>());
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最简单的类型转换：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>p &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)p;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 c 语言中，去掉变量名，就是变量类型：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>fn)();&lt;span style="color:#75715e">//fn 是一个指向返回int型的函数的指针
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>)(); &lt;span style="color:#75715e">//表示指向返回int型的函数的指针类型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 还可以用typedef
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#a6e22e">int&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>fn_type)(); &lt;span style="color:#75715e">// fn_type 就是指向返回int型的函数指针类型
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>回到上面的声明，我们先分析里边的部分&lt;code>(void(*)())0&lt;/code>，很显然&lt;code>void (*)()&lt;/code>是一个指向返回 void 类型的函数的指针类型，可以简化为&lt;code>typedef void (*fn_ptr)(); (fn_ptr)0&lt;/code>，
这样写是不是一下子明了了许多，原来是把&lt;code>0&lt;/code>强制类型转换成了&lt;code>fn_ptr&lt;/code>类型，也就是把&lt;code>0&lt;/code>转成了一个指向返回&lt;code>void&lt;/code>的函数的指针类型。这样的话，原式可以等价为&lt;code>((* fn_ptr )0)()&lt;/code>，
实际上就是一个先转型，后调用的过程，即先把 0 转成函数指针，然后再调用函数。&lt;/p></description></item><item><title>PHP扩展开发之迭代器</title><link>https://iliubang.cn/posts/php/2017-08-28-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8/</link><pubDate>2017-08-28</pubDate><guid>https://iliubang.cn/posts/php/2017-08-28-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid><description>&lt;h2 id="preface" data-numberify>preface&lt;a class="anchor ms-1" href="#preface">&lt;/a>&lt;/h2>
&lt;p>在之前的文章中，我们已经实现了一些 object handlers 来将我们的 ArrayBuffer 整合到 php 中。但是美中不足的是，我们的 ArrayBufferView 并不支持迭代器操作。也就是它不能像 php 中的数组那样使用&lt;code>foreach&lt;/code>来遍历。
那么，我们接下来就来看看迭代器在内核中是如何实现的，并且给我们的 ArrayBufferView 也增加一个迭代器。&lt;/p>
&lt;h2 id="get_iterator-handler" data-numberify>get_iterator handler&lt;a class="anchor ms-1" href="#get_iterator-handler">&lt;/a>&lt;/h2>
&lt;p>内核中的迭代器跟用户端的&lt;code>IteratorAggregate&lt;/code>接口功能是一样的。一个具有迭代功能的类都有一个&lt;code>get_iterator&lt;/code>处理器，它会返回一个&lt;code>zend_object_iterator *&lt;/code>类型的结构，该结构定义如下（位于 phpsrc/Zend/zend_iterators.h 中）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> _zend_object_iterator {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>data;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zend_object_iterator_funcs &lt;span style="color:#f92672">*&lt;/span>funcs;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ulong index; &lt;span style="color:#75715e">/* private to fe_reset/fe_fetch opcodes */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中的&lt;code>index&lt;/code>成员就是内核中用以实现&lt;code>foreach&lt;/code>的，它的值会在每次迭代后增加。&lt;code>funcs&lt;/code>成员包含了不同的迭代操作：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> _zend_object_iterator_funcs {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* release all resources associated with this iterator instance */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>dtor)(zend_object_iterator &lt;span style="color:#f92672">*&lt;/span>iter TSRMLS_DC);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* check for end of iteration (FAILURE or SUCCESS if data is valid) */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>valid)(zend_object_iterator &lt;span style="color:#f92672">*&lt;/span>iter TSRMLS_DC);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* fetch the item data for the current element */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>get_current_data)(zend_object_iterator &lt;span style="color:#f92672">*&lt;/span>iter, zval &lt;span style="color:#f92672">***&lt;/span>data TSRMLS_DC);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* fetch the key for the current element (optional, may be NULL). The key
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * should be written into the provided zval* using the ZVAL_* macros. If
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * this handler is not provided auto-incrementing integer keys will be
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * used. */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>get_current_key)(zend_object_iterator &lt;span style="color:#f92672">*&lt;/span>iter, zval &lt;span style="color:#f92672">*&lt;/span>key TSRMLS_DC);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* step forwards to next element */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>move_forward)(zend_object_iterator &lt;span style="color:#f92672">*&lt;/span>iter TSRMLS_DC);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* rewind to start of data (optional, may be NULL) */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>rewind)(zend_object_iterator &lt;span style="color:#f92672">*&lt;/span>iter TSRMLS_DC);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* invalidate current value/key (optional, may be NULL) */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>invalidate_current)(zend_object_iterator &lt;span style="color:#f92672">*&lt;/span>iter TSRMLS_DC);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} zend_object_iterator_funcs;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这些处理器跟&lt;code>Iterator&lt;/code>接口中的抽象方法类似，只不过名字不同罢了。唯一没有对应用户端接口的是&lt;code>invalidate_current&lt;/code>，它可以被用来销毁当前的&lt;code>key/value&lt;/code>。
然而这个操作几乎不会被用到，通常&lt;code>foreach&lt;/code>也不会取调用它。&lt;/p></description></item><item><title>PHP扩展开发之对象处理器(Object Handlers)</title><link>https://iliubang.cn/posts/php/2017-08-27-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%A4%84%E7%90%86%E5%99%A8/</link><pubDate>2017-08-27</pubDate><guid>https://iliubang.cn/posts/php/2017-08-27-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%A4%84%E7%90%86%E5%99%A8/</guid><description>&lt;h2 id="object-handlers" data-numberify>Object Handlers&lt;a class="anchor ms-1" href="#object-handlers">&lt;/a>&lt;/h2>
&lt;p>在前面的博文中，已经介绍过一些 object handlers 了，也特别介绍了如何通过指定 handlers 来创建一个自定义的结构和使用&lt;code>clone_obj&lt;/code>来对自定义的结构进行克隆操作。
然而，这只是开始：在 php 中，几乎所有的对象操作，都可以通过 object handlers 来实现，而且所有的魔术方法和魔术接口在内核中都是实现了对应的 object handler。此外，
一些 handlers 并没有开放给用户端的 php，例如，内部类可以自定义类的比较操作，而使用 php 代码是无法实现的。&lt;/p>
&lt;p>由于 php 中有很多不同的 object handlers，这里只挑几个来讨论，其它的只给出简单的说明。&lt;/p>
&lt;h2 id="概述" data-numberify>概述&lt;a class="anchor ms-1" href="#概述">&lt;/a>&lt;/h2>
&lt;p>下面列举出 php 中主要的 26 个(php5.6 中为 28 个)object handlers（位于 phpsrc/Zend/zend_object_handlers.h），并给出简要的说明。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>zval &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">read_property&lt;/span>(zval &lt;span style="color:#f92672">*&lt;/span>object, zval &lt;span style="color:#f92672">*&lt;/span>member, &lt;span style="color:#66d9ef">int&lt;/span> type, &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> _zend_literal &lt;span style="color:#f92672">*&lt;/span>key TSRMLS_DC)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">write_property&lt;/span>(zval &lt;span style="color:#f92672">*&lt;/span>object, zval &lt;span style="color:#f92672">*&lt;/span>member, zval &lt;span style="color:#f92672">*&lt;/span>value, &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> _zend_literal &lt;span style="color:#f92672">*&lt;/span>key TSRMLS_DC)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">has_property&lt;/span>(zval &lt;span style="color:#f92672">*&lt;/span>object, zval &lt;span style="color:#f92672">*&lt;/span>member, &lt;span style="color:#66d9ef">int&lt;/span> has_set_exists, &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> _zend_literal &lt;span style="color:#f92672">*&lt;/span>key TSRMLS_DC)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">unset_property&lt;/span>(zval &lt;span style="color:#f92672">*&lt;/span>object, zval &lt;span style="color:#f92672">*&lt;/span>member, &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> _zend_literal &lt;span style="color:#f92672">*&lt;/span>key TSRMLS_DC)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>zval &lt;span style="color:#f92672">**&lt;/span>&lt;span style="color:#a6e22e">get_property_ptr_ptr&lt;/span>(zval &lt;span style="color:#f92672">*&lt;/span>object, zval &lt;span style="color:#f92672">*&lt;/span>member, &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> _zend_literal &lt;span style="color:#f92672">*&lt;/span>key TSRMLS_DC)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上述 handlers 分别表示&lt;code>__get&lt;/code>，&lt;code>__set&lt;/code>，&lt;code>__isset&lt;/code>，&lt;code>__unset&lt;/code>方法。&lt;code>get_property_ptr_ptr&lt;/code>等同于&lt;code>__get&lt;/code>返回一个引用类型。&lt;code>zend_literal *key&lt;/code>作为这些函数的参数
起到优化作用，例如它包含了一些将属性名进行 hash 计算的结果。&lt;/p></description></item><item><title>PHP扩展开发之打造一个简易的ArrayBuffer</title><link>https://iliubang.cn/posts/php/2017-08-25-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E6%89%93%E9%80%A0%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84arraybuffer/</link><pubDate>2017-08-25</pubDate><guid>https://iliubang.cn/posts/php/2017-08-25-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E6%89%93%E9%80%A0%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84arraybuffer/</guid><description>&lt;h2 id="arraybuffer-简介" data-numberify>ArrayBuffer 简介&lt;a class="anchor ms-1" href="#arraybuffer-简介">&lt;/a>&lt;/h2>
&lt;p>ArrayBuffer 又叫二进制数组，是一个用来表示通用的，固定长度的二进制数据缓冲区。你不能直接操纵 ArrayBuffer 的内容，
而是创建一个表示特定格式的 buffer 的类型化数组对象（也叫做数据视图对象）来对 buffer 的内容进行读写操作。&lt;/p>
&lt;p>我最早了解 ArrayBuffer 是从 JavaScript 开始的，具体的用法和 api 可以参考&lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" target="_blank" rel="noopener noreferrer">JavaScript 标准库－－ArrayBuffer&lt;i class="fas fa-external-link-square-alt ms-1">&lt;/i>&lt;/a>&lt;/p>
&lt;p>那么接下来，我们就给 PHP 扩展一个简单的 ArrayBuffer，顺便巩固一下&lt;a href="https://iliubang.github.io/c/2017/08/24/php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%98%E5%82%A8/" target="_blank" rel="noopener noreferrer">php 扩展开发之自定义对象的存储&lt;i class="fas fa-external-link-square-alt ms-1">&lt;/i>&lt;/a>。&lt;/p>
&lt;h2 id="定义-arraybuffer-的数据结构和相关-handlers" data-numberify>定义 ArrayBuffer 的数据结构和相关 handlers&lt;a class="anchor ms-1" href="#定义-arraybuffer-的数据结构和相关-handlers">&lt;/a>&lt;/h2>
&lt;p>&lt;code>ArrayBuffer&lt;/code>是一个非常简单的对象，它只需要申明并存储一个&lt;code>buffer&lt;/code>和它的长度即可：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> _buffer_object {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zend_object std;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>buffer;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">size_t&lt;/span> length;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} buffer_object;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来我们来实现它的&lt;code>create&lt;/code>和&lt;code>free&lt;/code> handlers，有了前面的基础，这个实现也是及其简单的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">linger_array_buffer_free_object_storage&lt;/span>(buffer_object &lt;span style="color:#f92672">*&lt;/span>intern TSRMLS_DC)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">zend_object_std_dtor&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>intern&lt;span style="color:#f92672">-&amp;gt;&lt;/span>std TSRMLS_CC);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">linger_efree&lt;/span>(intern&lt;span style="color:#f92672">-&amp;gt;&lt;/span>buffer);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>zend_object_value &lt;span style="color:#a6e22e">linger_array_buffer_create_object&lt;/span>(zend_class_entry &lt;span style="color:#f92672">*&lt;/span>class_type TSRMLS_DC)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zend_object_value retval;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> buffer_object &lt;span style="color:#f92672">*&lt;/span>intern &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">emalloc&lt;/span>(&lt;span style="color:#66d9ef">sizeof&lt;/span>(buffer_object));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">memset&lt;/span>(intern, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(buffer_object));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">zend_object_std_init&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>intern&lt;span style="color:#f92672">-&amp;gt;&lt;/span>std, class_type TSRMLS_CC);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">object_properties_init&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>intern&lt;span style="color:#f92672">-&amp;gt;&lt;/span>std, class_type);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> retval.handle &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">zend_objects_store_put&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> intern,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#66d9ef">zend_objects_store_dtor_t&lt;/span>) zend_objects_destroy_object,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#66d9ef">zend_objects_free_object_storage_t&lt;/span>) linger_array_buffer_free_object_storage,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NULL
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TSRMLS_CC
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> );
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> retval.handlers &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>linger_array_buffer_handlers;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> retval;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>从上面的代码中可以看到，我们并没有在&lt;code>create_object&lt;/code>中申请&lt;code>buffer&lt;/code>的空间，而这步操作将会在&lt;code>__construct&lt;/code>中来实现，因为&lt;code>buffer&lt;/code>的长度会作为构造函数的参数传递过来。&lt;/p></description></item><item><title>PHP扩展开发之自定义对象的存储</title><link>https://iliubang.cn/posts/php/2017-08-24-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%98%E5%82%A8/</link><pubDate>2017-08-24</pubDate><guid>https://iliubang.cn/posts/php/2017-08-24-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%98%E5%82%A8/</guid><description>&lt;h2 id="前言" data-numberify>前言&lt;a class="anchor ms-1" href="#前言">&lt;/a>&lt;/h2>
&lt;p>对于 php 扩展开发，很多人可能已经不那么陌生了，zend 引擎为了们提供了非常丰富了函数和 macro，来帮助我们很快速的创建一个标准的 php 类，然而，当我们在使用自定义的数据结构(struct)，
并想把我们自己定义的数据结构封装成 php 的类的时候可能就会有些困惑，因为我们都知道 php 中的所有变量都是通过 zval 来存储的，而我们自定义的数据结构要怎样才能和 zval 实现完美的对接呢？
以前我通常采用的一种方式就是使用 zend 引擎提供的资源类型，因为资源类型的封装中包含了通用的数据类型，而且有很丰富的函数来操作资源，所以使用起来很简单也很方便。然而，强大的 zend
引擎真的没有其他方式扩展数据结构了吗？当然不是！下面就来介绍一个更加优雅的方式。要弄明白，首要要搞清 php 内核是如何创建对象的。&lt;/p>
&lt;h2 id="如何创建一个对象" data-numberify>如何创建一个对象&lt;a class="anchor ms-1" href="#如何创建一个对象">&lt;/a>&lt;/h2>
&lt;p>我们首先来探讨下如何创建一个 PHP 对象。为此我们将会用到&lt;code>object_and_properties_init&lt;/code>之类的一些宏。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 创建一个SomeClass类型的对象，并且把properties_hashtable中的变量作为其属性值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>zval &lt;span style="color:#f92672">*&lt;/span>obj;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MAKE_STD_ZVAL&lt;/span>(obj);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">object_and_properties_init&lt;/span>(obj, class_entry_of_SomeClass, properties_hashtable);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 创建一个没有属性的对象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>zval &lt;span style="color:#f92672">*&lt;/span>obj;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MAKE_STD_ZVAL&lt;/span>(obj);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">object_init_ex&lt;/span>(obj, class_entry_of_SomeClass);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// = object_and_properties_init(obj, class_entry_of_SomeClass, NULL)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 创建一个stdClass的对象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>zval &lt;span style="color:#f92672">*&lt;/span>obj;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MAKE_STD_ZVAL&lt;/span>(obj);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">object_init&lt;/span>(obj);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// = object_init_ex(obj, NULL) = object_and_properties_init(obj, NULL, NULL);
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在上面的例子中，最后一种情况下，当你创建一个&lt;code>stdClass&lt;/code>的对象后，通常将会给它添加属性。这时如果使用
&lt;code>zend_update_property&lt;/code>之类的函数，是不起作用的，取而代之的是&lt;code>add_property&lt;/code>宏函数：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">add_property_long&lt;/span>(obj, &lt;span style="color:#e6db74">&amp;#34;id&amp;#34;&lt;/span>, id);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">add_property_string&lt;/span>(obj, &lt;span style="color:#e6db74">&amp;#34;name&amp;#34;&lt;/span>, name, &lt;span style="color:#ae81ff">1&lt;/span>); &lt;span style="color:#75715e">// 1 表示使用字符串的副本
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">add_property_bool&lt;/span>(obj, &lt;span style="color:#e6db74">&amp;#34;isAdmin&amp;#34;&lt;/span>, is_admin);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 同样有_null(), _double(), _stringl(), _resource()和_zval()
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>那么当一个对象被创建的时候到底发生了什么呢？想知道真相，就需要去阅读&lt;code>_object_and_properties_init&lt;/code>函数的源码（位于 phpsrc/Zend/zend_API.c 中）：&lt;/p></description></item><item><title>数据结构之hashtable</title><link>https://iliubang.cn/posts/ds/2017-08-22-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8Bhashtable/</link><pubDate>2017-08-22</pubDate><guid>https://iliubang.cn/posts/ds/2017-08-22-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8Bhashtable/</guid><description>&lt;h2 id="hashtable" data-numberify>hashtable&lt;a class="anchor ms-1" href="#hashtable">&lt;/a>&lt;/h2>
&lt;p>哈希表又叫散列表，是实现字典操作的中有效数据结构。通常来说，一个 hash table 包含了一个数据，其中的数据通过 index 来访问。
而 hash table 的基本原理就是通过 hash 函数建立起所有可能的 index 与其对应的位置的联系。一个 hash 函数接收一个 key，返回其 hash code，
key 的类型是可变的，而 hash code 是一个整型。&lt;/p>
&lt;p>由于计算一个 hash 值和通过 index 访问一个数据都是常量级的时间复杂度，所以我们可以通过这中特性实现常量级时间复杂度的查找。
如果一个 hash 函数能够保证不会有两个不同的 key 生成相同的 hash 值，那么这样的 hash table 就被称为是直接定址。然而，这只是一想法而已，
实际上这种 hash table 在现实中却是不常用的。&lt;/p>
&lt;h3 id="chained-hash-table" data-numberify>Chained Hash Table&lt;a class="anchor ms-1" href="#chained-hash-table">&lt;/a>&lt;/h3>
&lt;p>链式 hash 表从本质上来讲，就是一个存放了一组链表的数组。每个链表可以看做是一个槽，我们把元素通过 hash 函数找到一个 hash 值，然后把元素的值
放入到数组中与改 hash 值对应的槽中。&lt;/p>
&lt;p>&lt;picture>&lt;img class="img-fluid mx-auto d-block" alt="chained hashtable" src="https://iliubang.cn/images/2017-08-23/chained_hashtable.png#center?v=7fdc4e1b5785be32c88d453deb32ca63" loading="lazy" width="320" height="267" />
&lt;/picture>
&lt;/p>
&lt;h4 id="collision-resolution" data-numberify>Collision Resolution&lt;a class="anchor ms-1" href="#collision-resolution">&lt;/a>&lt;/h4>
&lt;p>当有两个 key 被 hash 到了同一个位置，就会产生冲突。链式 hash 表有一种简单的冲突解决办法：当冲突产生时，元素被简单的放在同一个槽里。这样做可能带来的问题就是，
如果在同一个位置上出现很多冲突，这个槽就会变得越来越长，这样当我们访问这个槽中的元素的时候，所花的时间也就会越来越长。&lt;/p></description></item><item><title>c语言之struct</title><link>https://iliubang.cn/posts/sp/2017-08-21-c%E8%AF%AD%E8%A8%80%E4%B9%8Bstruct/</link><pubDate>2017-08-21</pubDate><guid>https://iliubang.cn/posts/sp/2017-08-21-c%E8%AF%AD%E8%A8%80%E4%B9%8Bstruct/</guid><description>&lt;h2 id="struct" data-numberify>struct&lt;a class="anchor ms-1" href="#struct">&lt;/a>&lt;/h2>
&lt;blockquote>
&lt;p>在 c 语言中，结构体(struct)是一种复合数据类型，用来将一系列相同或不同类型的变量聚集在同一个内存区间内并赋予同一个名字，使得通过一个指针就能访问集合中的所有成员。结构体中可以包含许多简单或符合数据类型，因此从内存分配上看，有点类似数组，而从变量组织上看，又类似于面向对象编程语言中的类。&lt;/p>
&lt;/blockquote>
&lt;h3 id="定义-struct" data-numberify>定义 struct&lt;a class="anchor ms-1" href="#定义-struct">&lt;/a>&lt;/h3>
&lt;p>定义一个 struct 非常简单，使用&lt;code>struct&lt;/code>关键字即可。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> student {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> age;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;h3 id="struct-的初始化" data-numberify>struct 的初始化&lt;a class="anchor ms-1" href="#struct-的初始化">&lt;/a>&lt;/h3>
&lt;p>通常有四种常用的 struct 初始化方式。&lt;/p>
&lt;p>１．定义并初始化&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>ext;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>filetype;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} extensions[] &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#e6db74">&amp;#34;gif&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;image/gif&amp;#34;&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#e6db74">&amp;#34;jpg&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;image/jpg&amp;#34;&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>２．按照成员声明的顺序初始化&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> Person {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> age;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> Person zhangsan &lt;span style="color:#f92672">=&lt;/span> {&lt;span style="color:#e6db74">&amp;#34;张三&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">24&lt;/span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>本质上，这种方式跟第一种是一样的。&lt;/p>
&lt;p>３．指定初始化，成员顺序可以不定，Linux Kernel 中多采用这种方式。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> Student {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span> c;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> score;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> Student zhangsan &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;张三&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .c &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;B&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .score &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">92&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>４．指定初始化，成员顺序可以不定。&lt;/p></description></item><item><title>Java Native Interface（二）</title><link>https://iliubang.cn/posts/java/2017-03-20-java_native_interface%E4%BA%8C/</link><pubDate>2017-03-20</pubDate><guid>https://iliubang.cn/posts/java/2017-03-20-java_native_interface%E4%BA%8C/</guid><description>&lt;h2 id="1jni-基础" data-numberify>1、JNI 基础&lt;a class="anchor ms-1" href="#1jni-基础">&lt;/a>&lt;/h2>
&lt;p>JNI 中定义了一下类型来对应到相应的 Java 的数据类型:&lt;/p>
&lt;p>&lt;strong>1. Java 基本数据类型:&lt;/strong> &lt;code>jint&lt;/code>,&lt;code>jbyte&lt;/code>,&lt;code>jshort&lt;/code>,&lt;code>jlong&lt;/code>,&lt;code>jfloat&lt;/code>,&lt;code>jdouble&lt;/code>,&lt;code>jchar&lt;/code>,&lt;code>jboolean&lt;/code>分别对应 Java 中的&lt;code>int&lt;/code>,&lt;code>byte&lt;/code>,&lt;code>short&lt;/code>,&lt;code>long&lt;/code>,&lt;code>float&lt;/code>,&lt;code>double&lt;/code>,&lt;code>char&lt;/code>和&lt;code>boolean&lt;/code>。&lt;/p>
&lt;p>&lt;strong>2. Java 引用类型：&lt;/strong>
&lt;code>jobject&lt;/code>对应&lt;code>java.lang.object&lt;/code>。同时也定义了下列子类型：&lt;/p>
&lt;ul>
&lt;li>&lt;code>jclass&lt;/code>对应&lt;code>java.lang.Class&lt;/code>&lt;/li>
&lt;li>&lt;code>jstring&lt;/code>对应&lt;code>java.lang.String&lt;/code>&lt;/li>
&lt;li>&lt;code>jthrowable&lt;/code>对应&lt;code>java.lang.Throwable&lt;/code>&lt;/li>
&lt;li>&lt;code>jarray&lt;/code>对应 Java 中的数组。Java 中的数组由 8 种基本数据类型和一个&lt;code>Object&lt;/code>类型派生二来，所以 JNI 中也存在&lt;code>jintArray&lt;/code>,&lt;code>jbyteArray&lt;/code>,&lt;code>jshortArray&lt;/code>,&lt;code>jlongArray&lt;/code>,&lt;code>jfloatArray&lt;/code>,&lt;code>jdoubleArray&lt;/code>,
&lt;code>jcharArray&lt;/code>,&lt;code>jbooleanArray&lt;/code>和&lt;code>jobjectArray&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>native 函数接收和返回上述的 JNI 类型数据。如果 native 函数需要操作它自己的数据类型(如 c 语言中的 int, char *)，那么就需要在 JNI 类型和本地类型之间做相应的转换。&lt;/p>
&lt;p>简而言之，native 函数的编写流程大致为：&lt;/p>
&lt;ol>
&lt;li>通过 Java 程序接收 JNI 类型的参数&lt;/li>
&lt;li>将接收的 JNI 类型转换成本地类型&lt;/li>
&lt;li>完成相应的操作&lt;/li>
&lt;li>创建一个需要返回的 JNI 类型的对象，然后将返回的数据 copy 到要返回的对象中&lt;/li>
&lt;li>返回&lt;/li>
&lt;/ol>
&lt;p>从上述流程可以看出，编写 JNI 程序主要的挑战在于数据类型之间的转换，然而 JNI 中提供了很多转换函数来帮助我们完成相应的操作。&lt;/p>
&lt;p>JNI 是一个 c 语言的接口，c 语言并不支持 OOP 的特性(严格的说，OOP 是一种理念，这里只是从语言本身来说 c 语言不支持面向对象，实际上用 c 语言也可以写出面向对象风格的程序！)，所以他们之间并不是真的通过对象来传递。&lt;/p></description></item><item><title>Java Native Interface（三）</title><link>https://iliubang.cn/posts/java/2017-03-20-java_native_interface%E4%B8%89/</link><pubDate>2017-03-20</pubDate><guid>https://iliubang.cn/posts/java/2017-03-20-java_native_interface%E4%B8%89/</guid><description>&lt;p>前面系统研究了 JNI 的相关操作，下面就来小试牛刀，做一个实际的练习。&lt;/p>
&lt;p>记得去年我曾经用 C 语言写过一个 PHP 的 md5 扩展函数，那么今天就花一点点时间用 JNI 来实现一遍吧。&lt;/p>
&lt;p>不过这里可要提前声明了，虽然是实现 md5 函数，但是这里并不会从头写 md5 算法，而是投机取巧使用到了 linux 内核提供的&lt;code>crypto&lt;/code>库。&lt;/p>
&lt;p>废话不多说，首先来写一个 Java 类&lt;/p>
&lt;p>MyString.java&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyString&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">loadLibrary&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;mymd5&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String value;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">native&lt;/span> String &lt;span style="color:#a6e22e">md5&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">MyString&lt;/span>(String value) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">value&lt;/span> &lt;span style="color:#f92672">=&lt;/span> value;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后生成头文件，并实现 c 代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;jni.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;openssl/md5.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;string.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>JNIEXPORT jstring JNICALL &lt;span style="color:#a6e22e">Java_MyString_md5&lt;/span>(JNIEnv &lt;span style="color:#f92672">*&lt;/span>env, jobject obj) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jclass thisClass &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>&lt;span style="color:#a6e22e">GetObjectClass&lt;/span>(env, obj);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jfieldID fidValue &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>&lt;span style="color:#a6e22e">GetFieldID&lt;/span>(env, thisClass, &lt;span style="color:#e6db74">&amp;#34;value&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Ljava/lang/String;&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (NULL &lt;span style="color:#f92672">==&lt;/span> fidValue) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> NULL;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jstring value &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>&lt;span style="color:#a6e22e">GetObjectField&lt;/span>(env, obj, fidValue);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>data &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>&lt;span style="color:#a6e22e">GetStringUTFChars&lt;/span>(env, value, NULL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MD5_CTX ctx;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> md[&lt;span style="color:#ae81ff">16&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span> buf[&lt;span style="color:#ae81ff">33&lt;/span>]&lt;span style="color:#f92672">=&lt;/span> {&lt;span style="color:#e6db74">&amp;#39;\0&amp;#39;&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span> tmp[&lt;span style="color:#ae81ff">3&lt;/span>]&lt;span style="color:#f92672">=&lt;/span> {&lt;span style="color:#e6db74">&amp;#39;\0&amp;#39;&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">MD5_Init&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>ctx);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">MD5_Update&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>ctx,data,&lt;span style="color:#a6e22e">strlen&lt;/span>((&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)data));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">MD5_Final&lt;/span>(md,&lt;span style="color:#f92672">&amp;amp;&lt;/span>ctx);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>( i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>; i&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">16&lt;/span>; i&lt;span style="color:#f92672">++&lt;/span> ) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">sprintf&lt;/span>(tmp,&lt;span style="color:#e6db74">&amp;#34;%02X&amp;#34;&lt;/span>,md[i]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">strcat&lt;/span>(buf,tmp);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> value &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>env)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>&lt;span style="color:#a6e22e">NewStringUTF&lt;/span>(env, buf);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> value;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>至此代码平淡无奇，也没什么好解释的，不过需要注意的是编译成动态链接库的部分，由于这里依赖到了其他的动态链接库，所以编译参数需要使用&lt;code>-L{path} -l{libname}&lt;/code>来显示的指明依赖库的路径和库名&lt;/p></description></item><item><title>Java Native Interface（一）</title><link>https://iliubang.cn/posts/java/2017-03-17-java_native_interface%E4%B8%80/</link><pubDate>2017-03-17</pubDate><guid>https://iliubang.cn/posts/java/2017-03-17-java_native_interface%E4%B8%80/</guid><description>&lt;p>最近在整理学习笔记的时候发现了去年年中记录的 JNI 学习笔记，由于存放在了为知笔记中，而如今为知笔记已经不再免费，于是想到了将其重新整理一遍，一来可以巩固所学，二来能将其迁移到本地&lt;/p>
&lt;h2 id="1-简介" data-numberify>1 简介&lt;a class="anchor ms-1" href="#1-简介">&lt;/a>&lt;/h2>
&lt;p>有时候，使用 native code(c/c++)来克服 Java 中的内存管理和性能的局限性是很有必要的。Java 支持 native codes，被称作 Java Native Interface(JNI)。&lt;/p>
&lt;p>JNI 非常难，毕竟它牵涉到了两种编程语言。假设聪明的你对 Java 和 C/C++以及 GCC 编译器已经有所了解。那么下面就一起来一步步学习 JNI 吧。&lt;/p>
&lt;h2 id="2-开始" data-numberify>2 开始&lt;a class="anchor ms-1" href="#2-开始">&lt;/a>&lt;/h2>
&lt;h3 id="21-用-c-语言实现第一个-jni-程序" data-numberify>2.1 用 c 语言实现第一个 JNI 程序&lt;a class="anchor ms-1" href="#21-用-c-语言实现第一个-jni-程序">&lt;/a>&lt;/h3>
&lt;p>&lt;strong>Step1:&lt;/strong> 创建一个名字为 JNITest.java 的文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">JNITest&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">load&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/home/ubuntu/workspace/java/jni/mynativelib.so&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//申明一个无参的native方法，而且返回空&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">native&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">greet&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//测试&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> JNITest test &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> JNITest();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> test.&lt;span style="color:#a6e22e">greet&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>首先用静态代码块加载本地动态链接库&amp;quot;mynativelib.so&amp;quot;。对于静态代码块，我相信写过 Java 的你应该非常清楚，它只会在类被加载的时候执行一次。这个动态链接库会被添加到 Java 的 library path（保存在 Java 系统变量 java.library.path）中，如果加载失败，就会抛出&lt;code>UnsatisfiedLinkError&lt;/code>异常。也可以使用 JVM 启动参数来加载该动态链接库到 Java 的 library path 当中：&lt;/p></description></item><item><title>彻底掌握malloc</title><link>https://iliubang.cn/posts/sp/2017-03-17-%E5%BD%BB%E5%BA%95%E6%8E%8C%E6%8F%A1malloc/</link><pubDate>2017-03-17</pubDate><guid>https://iliubang.cn/posts/sp/2017-03-17-%E5%BD%BB%E5%BA%95%E6%8E%8C%E6%8F%A1malloc/</guid><description>&lt;p>说明：参考文献地址 &lt;a href="http://www.inf.udec.cl/~leo/Malloc_tutorial.pdf" target="_blank" rel="noopener noreferrer">A Malloc Tutorial&lt;i class="fas fa-external-link-square-alt ms-1">&lt;/i>&lt;/a>&lt;/p>
&lt;h2 id="1-简介" data-numberify>1 简介&lt;a class="anchor ms-1" href="#1-简介">&lt;/a>&lt;/h2>
&lt;p>&lt;code>malloc&lt;/code>是干什么的？如果你连这个名字都没听过，那么你应该先去了解 Unix 环境下的 c 语言开发，然后再来阅读。对一个程序员而言，&lt;code>malloc&lt;/code>是一个在 c 语言中用来分配内存的函数，但是大多数人并不知道它背后真正的原理，甚至有些人认为&lt;code>malloc&lt;/code>是 c 语言的关键字或者认为它是系统调用。事实上，&lt;code>malloc&lt;/code>是一个再简单不过的函数而已，而且只需要很少的操作系统相关知识就可以让我们彻底理解它的原理。&lt;/p>
&lt;p>下面来一步步的实现一个简单的&lt;code>malloc&lt;/code>函数，从而帮助我们理解其背后运作的原理。因为仅仅作为说明原理之用，所以这里实现的&lt;code>malloc&lt;/code>不会太高效，但是足以说明原理。&lt;/p>
&lt;p>什么是 malloc&lt;/p>
&lt;p>&lt;code>malloc(3)&lt;/code>是一个用来分配内存块的标准的 c 语言库函数。它遵循以下规则：&lt;/p>
&lt;ul>
&lt;li>&lt;code>malloc&lt;/code>至少分配所需字节数的内存；&lt;/li>
&lt;li>&lt;code>malloc&lt;/code>返回其所分配内存空间(程序可以成功读写的空间)的指针；&lt;/li>
&lt;li>一块内存一旦被&lt;code>malloc&lt;/code>分配，其他&lt;code>malloc&lt;/code>调用不能再分配该内存块的任何部分，除非指向该内存块的指针被释放掉；&lt;/li>
&lt;li>&lt;code>malloc&lt;/code>应该是可控的：他必须能够很快完成分配并返回；&lt;/li>
&lt;li>&lt;code>malloc&lt;/code>同时应该提供重新分配内存块大小和释放内存的功能&lt;/li>
&lt;/ul>
&lt;p>&lt;code>malloc&lt;/code>函数必须遵循以下原型：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">malloc&lt;/span>(&lt;span style="color:#66d9ef">size_t&lt;/span> size);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中&lt;code>size&lt;/code>是所需要的内存大小。如果失败（没有足够的内存空间可以分配），应该返回&lt;code>NULL&lt;/code>。&lt;/p>
&lt;h2 id="2-堆brk-和-sbrk-系统调用" data-numberify>2 堆，brk 和 sbrk 系统调用&lt;a class="anchor ms-1" href="#2-堆brk-和-sbrk-系统调用">&lt;/a>&lt;/h2>
&lt;p>在开始实现第一个&lt;code>malloc&lt;/code>函数之前，需要了解内存在大多数多任务操作系统中是如何管理的。这里我们只是做出一个抽象的解释，从大体上去帮助理解，至于很多细节，它们都依赖操作系统原理和硬件相关的知识。&lt;/p>
&lt;h3 id="21-进程的内存" data-numberify>2.1 进程的内存&lt;a class="anchor ms-1" href="#21-进程的内存">&lt;/a>&lt;/h3>
&lt;p>每个进程都有自己的虚拟地址空间被 MMU（Memory Management Unit, 内存管理单元）(和内核)动态的转换到物理内存地址空间。这部分空间被划分成了几个部分，我们需要了解的是至少有一部分空间存放代码，一个用来存放局部变量的栈，一部分用来存放常量和全局变量的空间，以及程序的无组织空间我们称之为堆。&lt;/p>
&lt;p>堆是一个连续的（依据虚拟地址而言）内存空间，它有三个边界：一个起始点，一个最大限度边界（通过 sys/ressource.h 中的 getrlimit(2)函数和 setrlimit(2)函数来管理）和一个被称为&lt;code>break&lt;/code>的结束点。&lt;code>break&lt;/code>标记了隐射内存空间的结束，也就是说，虚拟地址空间部分对应着真实的内存空间。下图表示内存组织结构&lt;/p>
&lt;p>&lt;picture>&lt;img class="img-fluid mx-auto d-block" alt="heap" src="https://iliubang.cn/images/2017-03-17/heap.png#center?v=7fdc4e1b5785be32c88d453deb32ca63" loading="lazy" width="512" height="114" />
&lt;/picture>
&lt;/p>
&lt;p>要想实现一个&lt;code>malloc&lt;/code>函数，我们需要知道堆的起始点和 break 的位置，然后我们来移动 break。要做到这些，就需要用到两个系统调用，&lt;code>brk&lt;/code>和&lt;code>sbrk&lt;/code>。&lt;/p>
&lt;h3 id="22-brk2和-sbrk2" data-numberify>2.2 brk(2)和 sbrk(2)&lt;a class="anchor ms-1" href="#22-brk2和-sbrk2">&lt;/a>&lt;/h3>
&lt;p>我们可以在这些系统调用的文档中看到相关描述：&lt;/p></description></item><item><title>基于c语言的编程语言开发</title><link>https://iliubang.cn/posts/compiler/2017-03-15-%E5%9F%BA%E4%BA%8Ec%E8%AF%AD%E8%A8%80%E7%9A%84%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91/</link><pubDate>2017-03-15</pubDate><guid>https://iliubang.cn/posts/compiler/2017-03-15-%E5%9F%BA%E4%BA%8Ec%E8%AF%AD%E8%A8%80%E7%9A%84%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91/</guid><description>&lt;h2 id="preface" data-numberify>Preface&lt;a class="anchor ms-1" href="#preface">&lt;/a>&lt;/h2>
&lt;p>当今世道，各种高级语言百花齐放。然而会有人发出这样的疑问&amp;ndash;计算机真的能够识别这么多语言吗？稍微有点常识的人都知道，这显然是不可能滴！在计算机的世界里，他们能够直接识别的只有机器语言。然而，由于机器语言对人类不够友好，所以人们才发明了汇编，c，Java&amp;hellip;许许多多的人类易读的编程语言，所以我个人对编程语言的理解一直是其实他们就是机器语言的语法糖，而编程语言的创造过程，就是定义一种合理的，没有二义性的语法规则，然后就是通过直接或间接的方式实现该语法到机器语言的转换过程。既然是这样的话，那么我们就很容易想到，计算机语言是一个自我完善的过程：首先我们定了一种非常简单的 x1(这里只是用来举例说明，有没有 x 语言有待考证)语言，然后用机器语言实现了这个非常简单的 x1 语言的编译器，创造了 x1 语言，实现了非常简单的新特性，然后我们再用 x1 语言(相对于机器语言较高级)实现了另一些新的特性的 x2 语言的编译器，创造了 x2 语言，&amp;hellip;，如此下去，人们创造了汇编语言，从而创造了 c 语言，接着创造了世界上最好的语言 PHP(不知道是不是真的，反正大家都习惯这么说)。
在各种高级语言越来越强大的今天，我们可能很难再会去接触最原始的东西，高度封装确实提高了生产力，降低了学习成本，但是也使得现代程序员将太多精力花在了各种说明书上，而不清楚其本质。
毕业一年多，工作了一年多，对于计算机编程有了自己的看法，不再像在大学的时候认识的那样肤浅，反而觉得大学中学习的知识才是真正的干货，不禁感叹曾经浪费掉了大好光阴。好在陶渊明有词云：“悟已往之不谏，知来者之可追”。
闲暇之余，扒开 PHP(这里之所以是 PHP 并不因为他是世界上最好的语言，只是因为我目前从事的是 PHP 开发的工作而已)源码，了解了其内部构造和实现原理，百看不一练。今天就初步学习 yacc/lex 了，记录在我的博客中，以便以后翻阅巩固。&lt;/p>
&lt;h2 id="过程简述" data-numberify>过程简述&lt;a class="anchor ms-1" href="#过程简述">&lt;/a>&lt;/h2>
&lt;p>一般来说编程语言的解释执行过程如下：&lt;/p>
&lt;p>&lt;strong>ONE&lt;/strong>. 词法分析
将源代码拆分成若干 Token 的过程&lt;/p>
&lt;p>&lt;strong>TWO&lt;/strong>.语法分析
将 Token 构建成 Syntax Tree 的过程&lt;/p>
&lt;p>&lt;strong>THREE&lt;/strong>.生成执行码
生成可执行文件&lt;/p>
&lt;h2 id="yaccyet-another-compiler-compiler" data-numberify>yacc（Yet Another Compiler Compiler）&lt;a class="anchor ms-1" href="#yaccyet-another-compiler-compiler">&lt;/a>&lt;/h2>
&lt;p>下面是 wikipedia 中对 yacc 的描述&lt;/p>
&lt;blockquote>
&lt;p>Yacc is a computer program for the Unix operating system. It is a Look Ahead Left-to-Right (LALR) parser generator, generating a parser, the part of a compiler that tries to make syntactic sense of the source code, specifically a LALR parser, based on an analytic grammar written in a notation similar to Backus–Naur Form (BNF). Yacc itself used to be available as the default parser generator on most Unix systems, though it has since been supplanted as the default by more recent, largely compatible, programs.&lt;/p></description></item><item><title>PHP扩展开发之call_user_func原理和回调函数的实现</title><link>https://iliubang.cn/posts/php/2017-03-09-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8Bcall-user-func%E5%8E%9F%E7%90%86%E5%92%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/</link><pubDate>2017-03-09</pubDate><guid>https://iliubang.cn/posts/php/2017-03-09-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8Bcall-user-func%E5%8E%9F%E7%90%86%E5%92%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid><description>&lt;h2 id="函数调用" data-numberify>函数调用&lt;a class="anchor ms-1" href="#函数调用">&lt;/a>&lt;/h2>
&lt;p>很多时候，我们需要通过函数名来调用函数，并传递参数，或者把匿名函数作为函数的参数传递，实现回调。当我们在遇到这样的需求的时候，用 php 代码实现起来肯定是非常容易和简单的。但是，当我们在用 c 语言编写 php 扩展的时候，如何来实现这样的功能呢？下面就一起来深入了解 php 内核，看看如何实现。&lt;/p>
&lt;p>在 Zend 引擎中，给我们提供了&lt;code>zend_call_function&lt;/code>,&lt;code>call_user_function&lt;/code>以及&lt;code>call_user_function_ex&lt;/code>函数来帮助我们实现函数调用。在&lt;code>zend_API.h&lt;/code>文件中，我们可以看到如下函数原型的声明：&lt;/p>
&lt;!-- more -->
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>ZEND_API &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">zend_call_function&lt;/span>(zend_fcall_info &lt;span style="color:#f92672">*&lt;/span>fci, zend_fcall_info_cache &lt;span style="color:#f92672">*&lt;/span>fci_cache TSRMLS_DC);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ZEND_API &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">call_user_function&lt;/span>(HashTable &lt;span style="color:#f92672">*&lt;/span>function_table, zval &lt;span style="color:#f92672">**&lt;/span>object_pp, zval &lt;span style="color:#f92672">*&lt;/span>function_name, zval &lt;span style="color:#f92672">*&lt;/span>retval_ptr, zend_uint param_count, zval &lt;span style="color:#f92672">*&lt;/span>params[] TSRMLS_DC);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ZEND_API &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">call_user_function_ex&lt;/span>(HashTable &lt;span style="color:#f92672">*&lt;/span>function_table, zval &lt;span style="color:#f92672">**&lt;/span>object_pp, zval &lt;span style="color:#f92672">*&lt;/span>function_name, zval &lt;span style="color:#f92672">**&lt;/span>retval_ptr_ptr, zend_uint param_count, zval &lt;span style="color:#f92672">**&lt;/span>params[], &lt;span style="color:#66d9ef">int&lt;/span> no_separation, HashTable &lt;span style="color:#f92672">*&lt;/span>symbol_table TSRMLS_DC);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>从函数的参数上来看，显然&lt;code>zend_call_function&lt;/code>需要的参数很少，而其他两个都需要一堆参数，所以，我们可能会想，达到相同的效果为什么参数上有如此大的区别，于是带着这个疑问我们来解刨&lt;code>zend_fcall_info&lt;/code>结构体。同样在&lt;code>zend_API.h&lt;/code>中会看到如下结构体的定义：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> _zend_fcall_info {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">size_t&lt;/span> size;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HashTable &lt;span style="color:#f92672">*&lt;/span>function_table; &lt;span style="color:#75715e">//函数表
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> zval &lt;span style="color:#f92672">*&lt;/span>function_name; &lt;span style="color:#75715e">//函数，可以是函数名，也可以直接是匿名函数本身
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> HashTable &lt;span style="color:#f92672">*&lt;/span>symbol_table; &lt;span style="color:#75715e">//符号表
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> zval &lt;span style="color:#f92672">**&lt;/span>retval_ptr_ptr; &lt;span style="color:#75715e">//返回值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> zend_uint param_count; &lt;span style="color:#75715e">//参数个数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> zval &lt;span style="color:#f92672">***&lt;/span>params; &lt;span style="color:#75715e">//参数，数组
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> zval &lt;span style="color:#f92672">*&lt;/span>object_ptr; &lt;span style="color:#75715e">//调用对象方法时候需要传调用的对象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> zend_bool no_separation;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} zend_fcall_info;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>不难发现，原来是把相关字段封装到了结构体中了，所以显得参数数量少，实际上该有的都有。&lt;/p>
&lt;p>对于&lt;code>call_user_function&lt;/code>中相关参数含义的解释，这里就不强行翻译了，引用官方的一段话，虽然是英文，但是我相信聪明的你也肯定能看懂的！&lt;/p>
&lt;blockquote>
&lt;p>User functions can be called with the function call_user_function_ex(). It requires a hash value for the function table you want to access, a pointer to an object (if you want to call a method), the function name, return value, number of arguments, argument array, and a flag indicating whether you want to perform zval separation.
Note that you don&amp;rsquo;t have to specify both function_table and object; either will do. If you want to call a method, you have to supply the object that contains this method, in which case call_user_function()automatically sets the function table to this object&amp;rsquo;s function table. Otherwise, you only need to specify function_table and can set object to NULL.
Next is the parameter count as integer and an array containing all necessary parameters. The last argument specifies whether the function should perform zval separation - this should always be set to 0. If set to 1, the function consumes less memory but fails if any of the parameters need separation.&lt;/p></description></item><item><title>关于</title><link>https://iliubang.cn/about/</link><pubDate>2017-01-01</pubDate><guid>https://iliubang.cn/about/</guid><description/></item><item><title>Offline</title><link>https://iliubang.cn/offline/</link><pubDate>0001-01-01</pubDate><guid>https://iliubang.cn/offline/</guid><description/></item></channel></rss>