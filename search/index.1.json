[{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"Programming","url":"/blog/categories/programming/"}],"content":" False Positive Rate $m$: 表示BloomFilter bit array的长度;\n$k$: 表示hash函数个数;\n$n$: 表示插入元素的个数;\n假设hash函数以等概率选择bit array的下标，那么经过$k$个hash函数之后，某个bit位未被设置为1的概率为:\n$$ (1 - \\frac{1}{m})^k $$\n在插入$n$个元素之后，某个bit位仍然没有被设置为1的概率为:\n$$ (1 - \\frac{1}{m})^{kn} $$\n因此在插入$n$个元素之后，某个bit位被设置为1的概率为:\n$$ p = 1 - (1 - \\frac{1}{m})^{kn} $$\n对于一个不存在于集合中的元素，如果要出现误判，那么意味着经过$k$个hash函数之后，生成的下标所在的bit位 都是1，其概率为:\n$$ \\epsilon = p^k = (1 - (1 - \\frac{1}{m})^{kn})^k $$\n接着来用欧拉公式来对上面的式子进行简化，已知欧拉公式可表示为:\n$$ \\lim_{m \\to \\infty}(1 + \\frac{z}{m})^m = e^z $$\n令$z = -1$\n$$ \\lim_{m \\to \\infty}(1 - \\frac{1}{m})^m = e^{-1} $$\n当$m$足够大的时候，有\n$$ (1 - \\frac{1}{m})^{kn} = ((1 - \\frac{1}{m})^m)^{\\frac{kn}{m}} \\approx e^{-\\frac{kn}{m}} $$\n代入上面的$\\epsilon$可得:\n$$ \\epsilon = (1 - (1 - \\frac{1}{m})^{kn})^k \\approx (1 - e^{-\\frac{kn}{m}})^k $$\n计算最优$k$ 当$\\epsilon$最小的时候，$k$为最优，因此需要对$\\epsilon$关于$k$求导，找到极小值。\n令$f = (1 - e^{\\frac{-kn}{m}})^k$，等式两边取对数 $g = \\ln{f} = k \\cdot \\ln{(1 - e^{\\frac{-kn}{m}})}$，对$g$关于$k$求导:\n$$ \\frac{dg}{dk} = k^\\prime\\cdot\\ln{(1 - e^{\\frac{-kn}{m}})} + k \\cdot\\ln^\\prime{(1 - e^{\\frac{-kn}{m}})} $$\n$$ \\iff \\frac{dg}{dk} = \\ln{(1 - e^{\\frac{-kn}{m}})} + k\\cdot\\frac{(1 - e^{\\frac{-kn}{m}})^\\prime}{1 - e^{\\frac{-kn}{m}}} $$\n$$ \\iff \\frac{dg}{dk} = \\ln{(1 - e^{\\frac{-kn}{m}})} + \\frac{kn}{m}\\cdot\\frac{e^{\\frac{-kn}{m}}}{1 - e^{\\frac{-kn}{m}}} $$\n要找到最小的$\\epsilon$，使得$k$的值为最优（在不考虑$k$为整数的情况下），则需要找到极值点，也就是令$\\frac{dg}{dk} = 0$,得到\n$$ \\ln{(1 - e^{\\frac{-kn}{m}})} + \\frac{kn}{m}\\cdot\\frac{e^{\\frac{-kn}{m}}}{1 - e^{\\frac{-kn}{m}}} = 0 $$\n$$ \\iff - \\ln{(1 - e^{\\frac{-kn}{m}})} = \\frac{kn}{m}\\cdot\\frac{e^{\\frac{-kn}{m}}}{1 - e^{\\frac{-kn}{m}}} $$\n对等式两边做整理得\n$$ e^{- \\ln{(1 - e^{\\frac{-kn}{m}})}} = e^{\\frac{kn}{m}\\cdot\\frac{e^{\\frac{-kn}{m}}}{1 - e^{\\frac{-kn}{m}}}} $$\n$$ \\iff \\frac{1}{(1 - e^{\\frac{-kn}{m}})} = e^{\\frac{kn}{m}\\cdot\\frac{e^{\\frac{-kn}{m}}}{1 - e^{\\frac{-kn}{m}}}} $$\n进一步简化等式，令$x = e^{\\frac{-kn}{m}}$可得\n$$ \\frac{1}{1 - x} = (\\frac{1}{x})^{\\frac{x}{1 - x}} $$\n$$ \\iff (1 - x)^{-1} = x^{-\\frac{x}{1-x}} \\iff (1 - x) = x^{\\frac{x}{1 - x}} $$\n对等式两边取对数\n$$ \\ln{(1 - x)} = \\ln{x^{\\frac{x}{1 - x}}} \\iff \\ln{(1 - x)} = \\frac{x}{1 - x}\\ln(x) \\iff (1 - x) \\cdot \\ln(1 - x) = x \\cdot \\ln(x) $$\n显然可得$x = \\frac{1}{2}$，又因为$x = e^{\\frac{-kn}{m}}$，所以\n$$ e^{\\frac{-kn}{m}} = \\frac{1}{2} \\iff \\ln{e^{\\frac{-kn}{m}}} = \\ln\\frac{1}{2} \\iff -\\frac{kn}{m} = \\ln(2^{-1}) \\iff \\frac{kn}{m} = \\ln(2) $$\n最终可得$k = \\frac{m}{n}\\ln(2)$\n计算最优$m$ 已知$\\epsilon \\approx (1 - e^{\\frac{-kn}{m}})^k$，将$k = \\frac{m}{n}\\ln(2)$代入可得\n$$ \\epsilon \\approx (1 - e^{-\\ln{(2)}})^{\\frac{m}{n}\\ln2} = (1 - \\frac{1}{2})^{\\frac{m}{n}\\ln2} $$\n$$ \\iff \\ln{(\\epsilon)} \\approx \\frac{m}{n}\\ln2\\cdot\\ln{\\frac{1}{2}} = -\\frac{m}{n}\\cdot\\ln{(2)}^2 $$\n最终可得\n$$ m \\approx = -\\frac{n\\ln{(\\epsilon)}}{\\ln{(2)}^2} \\approx -2.08n\\ln{(\\epsilon)} $$\n参考文档 Bloom Filter Euler\u0026rsquo;s formula ","date":"January 1, 2025","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/storage/2025-01-01-bloomfilter%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%E6%8E%A8%E5%AF%BC/","series":[],"smallImg":"","tags":[{"title":"Storage","url":"/blog/tags/storage/"}],"timestamp":1735689600,"title":"BloomFilter中的数学推导"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"Programming","url":"/blog/categories/programming/"}],"content":" libFuzzer 简介 LLVM libFuzzer 是 LLVM 生态系统中的一个fuzzy test工具，用于自动化地发现软件程序中的漏洞和错误。它通过生成大量的随机输入数据并观察程序的行为来进行fuzzy test。 libFuzzer 是一个基于内存的fuzzy test引擎，使用 LLVM 的插桩技术和代码优化功能来提高测试效率和覆盖率。\n以下是 libFuzzer 的一些功能特点：\n自动化fuzzy test：libFuzzer 提供了一种自动化的fuzzy test方法，可以生成大量的随机输入数据，并在每个输入上运行目标函数进行测试。它通过观察程序的崩溃、断言失败、未定义行为等反馈来发现潜在的问题。 内存安全性：libFuzzer 通过使用 AddressSanitizer (ASan) 和 UndefinedBehaviorSanitizer (UBSan) 等工具来确保fuzzy test过程中的内存安全性。这有助于检测和报告内存错误、缓冲区溢出、使用已释放内存等问题。 代码覆盖率分析：libFuzzer 使用 LLVM 提供的代码覆盖率分析技术，帮助确定已经执行过的代码路径和未执行的代码区域。这有助于评估测试的质量和覆盖范围，并帮助发现潜在的漏洞。 快速收敛：libFuzzer 使用一种称为 \u0026ldquo;回退\u0026rdquo;（Backoff）的策略，以更快地收敛到程序中的漏洞。它会根据测试结果调整输入数据的变异程度，使得能够更快地发现问题并生成更有潜力的测试用例。 灵活性和可定制性：libFuzzer 提供了多种选项和配置参数，使用户能够根据自己的需求进行定制。例如，可以设置最大测试时间、内存消耗限制、覆盖率报告等。 多线程支持：libFuzzer 支持多线程执行，可以利用多核处理器并行进行fuzzy test，加快测试速度。 示例 下面是一个使用 libFuzzer 的简单示例\n首先我们有一个 test_fuzzy.cpp:\n1#include \u0026lt;cstddef\u0026gt; 2#include \u0026lt;cstdint\u0026gt; 3 4void DoSomethingWithData(const uint8_t* data, std::size_t size) { 5 int* p = nullptr; 6 if (size \u0026lt; 10) return; 7 if (data[0] == \u0026#39;h\u0026#39; \u0026amp;\u0026amp; data[1] == \u0026#39;e\u0026#39; \u0026amp;\u0026amp; data[2] == \u0026#39;l\u0026#39; \u0026amp;\u0026amp; data[3] == \u0026#39;l\u0026#39; \u0026amp;\u0026amp; data[4] == \u0026#39;0\u0026#39;) { 8 *p = 42; 9 } 10 return; 11} 12 13extern \u0026#34;C\u0026#34; int LLVMFuzzerTestOneInput(const uint8_t* data, std::size_t size) { 14 DoSomethingWithData(data, size); 15 return 0; 16} 使用 clang++进行编译：\n1/opt/homebrew/Cellar/llvm/16.0.3/bin/clang++ -g -fsanitize=address,fuzzer test_fuzzy.cpp -o test_fuzzy 然后直接运行：\n1./test_fuzzy 程序崩溃，并输出：\n1test_fuzzy(7057,0x1fb911b40) malloc: nano zone abandoned due to inability to reserve vm space. 2INFO: Running with entropic power schedule (0xFF, 100). 3INFO: Seed: 3129959573 4INFO: Loaded 1 modules (9 inline 8-bit counters): 9 [0x104488000, 0x104488009), 5INFO: Loaded 1 PC tables (9 PCs): 9 [0x104488010,0x1044880a0), 6INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytes 7INFO: A corpus is not provided, starting from an empty corpus 8#2\tINITED cov: 3 ft: 3 corp: 1/1b exec/s: 0 rss: 44Mb 9#726\tNEW cov: 4 ft: 4 corp: 2/11b lim: 11 exec/s: 0 rss: 45Mb L: 10/10 MS: 4 ChangeBit-ShuffleBytes-InsertByte-InsertRepeatedBytes- 10#11087\tNEW cov: 5 ft: 5 corp: 3/21b lim: 110 exec/s: 0 rss: 45Mb L: 10/10 MS: 1 ChangeByte- 11#29565\tNEW cov: 6 ft: 6 corp: 4/31b lim: 293 exec/s: 0 rss: 47Mb L: 10/10 MS: 3 CMP-ChangeBinInt-ChangeBit- DE: \u0026#34;%\\000\\000\\000\u0026#34;- 12#63786\tNEW cov: 7 ft: 7 corp: 5/41b lim: 625 exec/s: 0 rss: 50Mb L: 10/10 MS: 1 CMP- DE: \u0026#34;l\\000\u0026#34;- 13#64830\tNEW cov: 8 ft: 8 corp: 6/64b lim: 634 exec/s: 0 rss: 50Mb L: 23/23 MS: 4 EraseBytes-CrossOver-CrossOver-PersAutoDict- DE: \u0026#34;l\\000\u0026#34;- 14#65066\tREDUCE cov: 8 ft: 8 corp: 6/63b lim: 634 exec/s: 0 rss: 50Mb L: 22/22 MS: 1 EraseBytes- 15#65069\tREDUCE cov: 8 ft: 8 corp: 6/53b lim: 634 exec/s: 0 rss: 50Mb L: 12/12 MS: 3 ShuffleBytes-ChangeBinInt-EraseBytes- 16#66665\tREDUCE cov: 8 ft: 8 corp: 6/51b lim: 643 exec/s: 0 rss: 50Mb L: 10/10 MS: 1 EraseBytes- 17AddressSanitizer:DEADLYSIGNAL 18================================================================= 19==7057==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000000 (pc 0x000104447fa8 bp 0x00016b9ba330 sp 0x00016b9ba260 T0) 20==7057==The signal is caused by a WRITE memory access. 21==7057==Hint: address points to the zero page. 22 #0 0x104447fa8 in DoSomethingWithData(unsigned char const*, unsigned long) test_fuzzy.cpp:8 23 #1 0x104447ff4 in LLVMFuzzerTestOneInput test_fuzzy.cpp:14 24 #2 0x10445fc94 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) FuzzerLoop.cpp:617 25 #3 0x10445f588 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long, bool, fuzzer::InputInfo*, bool, bool*) FuzzerLoop.cpp:519 26 #4 0x104460c60 in fuzzer::Fuzzer::MutateAndTestOne() FuzzerLoop.cpp:763 27 #5 0x104461aa4 in fuzzer::Fuzzer::Loop(std::__1::vector\u0026lt;fuzzer::SizedFile, std::__1::allocator\u0026lt;fuzzer::SizedFile\u0026gt;\u0026gt;\u0026amp;) FuzzerLoop.cpp:908 28 #6 0x104450e4c in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) FuzzerDriver.cpp:912 29 #7 0x10447dc80 in main FuzzerMain.cpp:20 30 #8 0x1a014bf24 (\u0026lt;unknown module\u0026gt;) 31 #9 0xb0c7ffffffffffc (\u0026lt;unknown module\u0026gt;) 32 33==7057==Register values: 34 x[0] = 0x000000000000006f x[1] = 0x000000000000006f x[2] = 0x0000000000000000 x[3] = 0x0000000104488009 35 x[4] = 0x00000001044b9c80 x[5] = 0x0000000000000001 x[6] = 0x000000016b1c0000 x[7] = 0x0000000000000001 36 x[8] = 0x000000000000002a x[9] = 0x0000000000000000 x[10] = 0x0000000104488000 x[11] = 0x0000000000000000 37x[12] = 0x00000000000010c0 x[13] = 0x0000000000000000 x[14] = 0x0000000000000001 x[15] = 0x0000000000000000 38x[16] = 0x00000001a04d23d0 x[17] = 0x0000000200438e00 x[18] = 0x0000000000000000 x[19] = 0x0000618000000080 39x[20] = 0x000060200025b5f0 x[21] = 0x000000000000000d x[22] = 0x0000621000000100 x[23] = 0x0000000104488400 40x[24] = 0x0000000104488200 x[25] = 0x00000001044bbff8 x[26] = 0x00000001044bc000 x[27] = 0x0000000104488000 41x[28] = 0x0000000000000000 fp = 0x000000016b9ba330 lr = 0x0000000104447f0c sp = 0x000000016b9ba260 42AddressSanitizer can not provide additional info. 43SUMMARY: AddressSanitizer: SEGV test_fuzzy.cpp:8 in DoSomethingWithData(unsigned char const*, unsigned long) 44==7057==ABORTING 45MS: 3 CMP-InsertByte-CMP- DE: \u0026#34;\\012\\000\\000\\000\u0026#34;-\u0026#34;o\\000\u0026#34;-; base unit: 428b50c9cb33d129aaf98b190836a5052a1859a8 460x68,0x65,0x6c,0x6c,0x6f,0x0,0xa,0xff,0xa,0x0,0x0,0xa,0x0, 47hello\\000\\012\\377\\012\\000\\000\\012\\000 48artifact_prefix=\u0026#39;./\u0026#39;; Test unit written to ./crash-a27ccd37d9bf8363d556137baf72042fd37165dc 49Base64: aGVsbG8ACv8KAAAKAA== 50zsh: abort ./test_fuzzy 在输出的最后，我们可以看到 artifact_prefix='./'; Test unit written to ./crash-a27ccd37d9bf8363d556137baf72042fd37165dc，将造成崩溃的测试用例写入到文件 ./crash-a27ccd37d9bf8363d556137baf72042fd37165dc中了。 我们可以直接查看这个用例的输入：\n1cat ./crash-a27ccd37d9bf8363d556137baf72042fd37165dc 2hello 当然，输出的信息中，也指出了程序崩溃的原因和代码行数，结合错误的 case，我们很容易能够复现和修复问题。\n","date":"May 23, 2023","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/cpp/2023-05-23-%E4%BD%BF%E7%94%A8llvm%E7%9A%84libfuzzer%E8%BF%9B%E8%A1%8Cfuzzy-test/","series":[],"smallImg":"","tags":[{"title":"C++","url":"/blog/tags/c++/"}],"timestamp":1684800000,"title":"使用LLVM的libFuzzer进行fuzzy test"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"LeetCode","url":"/blog/categories/leetcode/"}],"content":" 题目描述 给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。 计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。 你可以认为每种硬币的数量是无限的。\n题解 定义状态： $dp[i]$表示用所给的面值的硬币凑成金额$i$所需的最少的硬币个数。\n设计状态转移方程： $$ \\forall coin \\in coins, 当 i \\geqslant coin，且 dp[i - coin] \\neq -1 时, dp[i] = std::min(dp[i], dp[i - coin] + 1) $$\n初始化： 对于 amount 为 0 的情况，所需的硬币数也为 0，因此：$dp[0] = 0$\n递推求解： 这里我们使用了一个小技巧，默认将$dp$的值都填充为INT_MAX，这样就可以避免对-1这个负数做特殊的判断和处理，相当于我们用INT_MAX 来代理了-1。\n1#include \u0026lt;vector\u0026gt; 2#include \u0026lt;climits\u0026gt; 3 4class Solution { 5public: 6 int coinChange(const std::vector\u0026lt;int\u0026gt;\u0026amp; coins, int amount) { 7 std::vector\u0026lt;int\u0026gt; dp(amount + 1, INT_MAX); 8 dp[0] = 0; 9 for (int i = 1; i \u0026lt;= amount; ++i) { 10 for (int coin : coins) { 11 if (coin \u0026lt;= i \u0026amp;\u0026amp; dp[i - coin] != INT_MAX) { 12 dp[i] = std::min(dp[i], dp[i - coin] + 1); 13 } 14 } 15 } 16 return dp[amount] == INT_MAX ? -1 : dp[amount]; 17 } 18}; ","date":"April 19, 2023","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/leetcode/dp/exercises/322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/","series":[{"title":"LeetCode","url":"/blog/series/leetcode/"}],"smallImg":"","tags":[{"title":"DP","url":"/blog/tags/dp/"},{"title":"NP","url":"/blog/tags/np/"}],"timestamp":1681904631,"title":"322.零钱兑换"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"LeetCode","url":"/blog/categories/leetcode/"}],"content":" 题目描述 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n题解 这道题是一个非常典型而且很简单的动态规划题目。我们可以根据动态规划题目解题的一般思路来分析：\n定义状态： $dp[i]$表示爬到第$i$级楼梯的不同方法数。由于每次可以选择爬 $1$ 级或者 $2$ 级楼梯， 所以爬到第 $i$ 级楼梯的方法数等于爬到第 $i-1$ 级楼梯和第 $i-2$ 级楼梯的方法数之和。 根据这个关系，我们可以使用动态规划的方式从 $1$ 级楼梯开始逐步计算到第 $n$ 级楼梯的方法数，最终返回 $dp[n]$即为结果。\n设计状态转移方程： $$dp[i] = dp[i - 1] + dp[i - 2]$$\n初始化： 由题目可知，$dp[0] = 0$; $dp[1] = 1$，这里需要特别注意的是，$dp[2] \\ne dp[0] + dp[1]$，而是$dp[2] = 2$，所以$dp[2]$也应该作为初始值\n递推求解： 1#include \u0026lt;vector\u0026gt; 2 3class Solution { 4public: 5 int climbStairs(int n) { 6 if (n \u0026lt;= 2) return n; 7 std::vector\u0026lt;int\u0026gt; dp(n + 1); 8 dp[1] = 1; 9 dp[2] = 2; 10 for (int i = 3; i \u0026lt;= n; ++i) { 11 dp[i] = dp[i - 1] + dp[i - 2]; 12 } 13 return dp[n]; 14 } 15}; 记忆优化： 从上面代码可以很容易发现，我们得出$dp[i]$只需要用到$dp[i - 1]$和$dp[i -2]$，其他的元素其实都用不到，所以上面的代码可以优化为：\n1#include \u0026lt;vector\u0026gt; 2 3class Solution { 4public: 5 int climbStairs(int n) { 6 if (n \u0026lt;= 2) return n; 7 int pp = 1; 8 int p = 2; 9 int c = 0; 10 for (int i = 3; i \u0026lt;= n; ++i) { 11 c = pp + p; 12 pp = p; 13 p = c; 14 } 15 return c; 16 } 17}; ","date":"April 19, 2023","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/leetcode/dp/exercises/70.%E7%88%AC%E6%A5%BC%E6%A2%AF/","series":[{"title":"LeetCode","url":"/blog/series/leetcode/"}],"smallImg":"","tags":[{"title":"DP","url":"/blog/tags/dp/"},{"title":"NP","url":"/blog/tags/np/"}],"timestamp":1681833737,"title":"70.爬楼梯"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"LeetCode","url":"/blog/categories/leetcode/"}],"content":" 题目描述 给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。\n题解 由题可知，数组nums非空，所以分割后的两个子集也必然非空，由于都是正整数，所以nums中元素之和必然为偶数。\n这道题是典型的 01 背包问题，假设$dp[i][j]$表示nums中前$i$个元素是否包含和为$j$的子集，那么：\n当nums[i] = j的时候，dp[i][j] = true 当nums[i] \u0026gt; j的时候，dp[i][j] = dp[i - 1][j] 当nums[i] \u0026lt; j的时候，dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]] 1#include \u0026lt;vector\u0026gt; 2#include \u0026lt;numeric\u0026gt; 3 4class Solution { 5public: 6 bool canPartition(const std::vector\u0026lt;int\u0026gt;\u0026amp; nums) { 7 int size = nums.size(); 8 int sum = std::accumulate(nums.begin(), nums.end(), 0); 9 if (size == 1 || (sum \u0026amp; 1) == 1) return false; 10 int target = sum / 2; 11 std::vector\u0026lt;std::vector\u0026lt;bool\u0026gt;\u0026gt; dp(size + 1, std::vector\u0026lt;bool\u0026gt;(target + 1)); 12 for (int i = 1; i \u0026lt;= size; ++i) { 13 for (int j = 1; j \u0026lt;= target; ++j) { 14 int num = nums[i - 1]; 15 if (num == j) dp[i][j] = true; 16 else if (num \u0026gt; j) dp[i][j] = dp[i - 1][j]; 17 else dp[i][j] = dp[i - 1][j] | dp[i - 1][j - num]; 18 } 19 } 20 return dp[size][target]; 21 } 22}; ","date":"April 16, 2023","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/leetcode/dp/exercises/416/","series":[{"title":"LeetCode","url":"/blog/series/leetcode/"}],"smallImg":"","tags":[{"title":"DP","url":"/blog/tags/dp/"},{"title":"NP","url":"/blog/tags/np/"}],"timestamp":1681659994,"title":"416.分割等和子集"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"LeetCode","url":"/blog/categories/leetcode/"}],"content":" 题目描述 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 实现 MinStack 类: MinStack() 初始化 void push(int val) 将元素推入堆栈 void pop() 删除堆栈顶部的元素 int pop() 获取堆栈顶部的元素 int getMin() 获取堆栈中的最小元素\n题解： 这道题首先要满足堆栈的特性 LIFO，其次是能够在常数时间内获取当前栈中最小的元素，因此我们可以用堆栈保存 个二元组，二元组的第一个元素是存入栈中的值，第二个元素是当前元素作为栈顶元素的时候，栈中的最小值。有 了这个思路，代码实现起来就很简单了。\n1class MinStack { 2public: 3 MinStack() = default; 4 5 void push(int val) { 6 stack_.emplace(val, std::min(val, getMin())); 7 } 8 9 void pop() { 10 stack_.pop(); 11 } 12 13 void top() { 14 return stack_.top().first; 15 } 16 17 int getMin() { 18 if (stack_.empty()) return INT_MAX; 19 return stack_.top().second; 20 } 21private: 22 std::stack\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt; stack_; 23}; ","date":"December 6, 2022","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/leetcode/stack/exercises/155/","series":[{"title":"LeetCode","url":"/blog/series/leetcode/"}],"smallImg":"","tags":[{"title":"Stack","url":"/blog/tags/stack/"}],"timestamp":1670284800,"title":"155.最小栈"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"LeetCode","url":"/blog/categories/leetcode/"}],"content":" 题目描述 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 求在该柱状图中，能够勾勒出来的矩形的最大面积。\n解法一：暴力求解 主要思路是，遍历每个柱子，然后往柱子左右两边寻找比当前柱子矮的位置，从而计算出，以当前柱子为高度，所能围成的最大面积。 然后将这些面积中最大的值返回即可。暴力求解的时间复杂度为O(n^2)\n不过我尝试过各种暴力求解，在 leetcode 中提交后都会超时。\n1class Solution { 2public: 3 int largestRectangleInHistogram(const std::vector\u0026lt;int\u0026gt;\u0026amp; inputs) { 4 std::size_t n = inputs.size(); 5 int max_area = 0; 6 for (int i = 0; i \u0026lt; n; ++i) { 7 int min_height = INT_MAX; 8 for (int j = i; j \u0026lt; n; ++j) { 9 min_height = std::min(min_height, inputs[j]); 10 max_area = std::max(max_area, min_height * (j - i + 1)); 11 } 12 } 13 return max_area; 14 } 15}; 解法二：单调栈 1class Solution { 2public: 3 int largestRectangleInHistogram(const std::vector\u0026lt;int\u0026gt;\u0026amp; inputs) { 4 int n = inputs.size(); 5 std::stack\u0026lt;int\u0026gt; stk; 6 int ret = 0; 7 for (int i = 0; i \u0026lt; n; ++i) { 8 while (!stk.empty() \u0026amp;\u0026amp; inputs[stk.top()] \u0026gt; inputs[i]) { 9 int w = i; 10 int h = inputs[stk.top()]; 11 stk.pop(); 12 if (!stk.empty()) { 13 w = i - stk.top() - 1; 14 } 15 ret = std::max(ret, w * h); 16 } 17 stk.push(i); 18 } 19 while (!stk.empty()) { 20 int w = n; 21 int h = inputs[stk.top()]; 22 stk.pop(); 23 if (!stk.empty()) { 24 w = n - stk.top() - 1; 25 } 26 ret = std::max(ret, w * h); 27 } 28 29 return ret; 30 } 31}; ","date":"December 6, 2022","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/leetcode/stack/exercises/84/","series":[{"title":"LeetCode","url":"/blog/series/leetcode/"}],"smallImg":"","tags":[{"title":"Stack","url":"/blog/tags/stack/"}],"timestamp":1670284800,"title":"84. 柱状图中最大的矩形"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"LeetCode","url":"/blog/categories/leetcode/"}],"content":" 题目描述 给你一个链表的头节点 head ，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。 如果链表中存在环 ，则返回 true 。 否则，返回 false 。\n解法一：hash 法 hash 法是我们在判断重复元素类问题中最常用的方法。针对链表是否有环来说，我们可以遍历链表，并用std::set 存放遍历过的元素，判断是否存在重复元素，如果存在则表示有环，如果遍历结束且不存在重复，则没有环。\n1class Solution { 2public: 3 bool hasCycle(ListNode* head) { 4 std::set\u0026lt;ListNode*\u0026gt; set; 5 ListNode* cur = head; 6 while (cur) { 7 if (set.count(cur) \u0026gt; 0) return true; 8 set.insert(cur); 9 cur = cur-\u0026gt;next; 10 } 11 return false; 12 } 13}; 解法二：快慢指针 快慢指针就是用两个指针，一个一次移动一个位置，另一个一次移动两个位置，如果链表存在环，那么快的指针一定会 在某个地方和慢的指针重合，这个思路虽然很简单，但是具体的编码还是要多练习，不然也容易出错。\n1class Solution { 2public: 3 bool hasCycle(ListNode* head) { 4 if (!head) return false; 5 ListNode* slow = head; 6 ListNode* fast = head-\u0026gt;next; 7 while (fast) { 8 if (fast == slow) return true; 9 if (!fast-\u0026gt;next) return false; 10 slow = slow-\u0026gt;next; 11 fast = fast-\u0026gt;next-\u0026gt;next; 12 } 13 return false; 14 } 15}; ","date":"November 30, 2022","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/leetcode/linkedlist/exercises/141/","series":[{"title":"LeetCode","url":"/blog/series/leetcode/"}],"smallImg":"","tags":[{"title":"LinkedList","url":"/blog/tags/linkedlist/"}],"timestamp":1669766400,"title":"141.环形链表"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"LeetCode","url":"/blog/categories/leetcode/"}],"content":" 题目描述 给定一个只包括 \u0026lsquo;(\u0026rsquo;，\u0026rsquo;)\u0026rsquo;，\u0026rsquo;{\u0026rsquo;，\u0026rsquo;}\u0026rsquo;，\u0026rsquo;[\u0026rsquo;，\u0026rsquo;]\u0026rsquo; 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 每个右括号都有一个对应的相同类型的左括号。\n解法一：stack 这道题目是典型的堆栈数据结构的应用，虽然思路很清晰，代码也很简单，但是要注意逻辑的严谨性。尤其是在判断 栈顶元素是否匹配之前，要先判断栈是否为空。\n1class Solution { 2public: 3 bool isValid(const std::string\u0026amp; s) { 4 std::stack\u0026lt;char\u0026gt; st; 5 for (int i = 0; i \u0026lt; s.length(); ++i) { 6 char c = s[i]; 7 if (c == \u0026#39;(\u0026#39; || c == \u0026#39;{\u0026#39; || c == \u0026#39;[\u0026#39;) { 8 st.push(c); 9 } else { 10 if (st.empty()) return false; 11 if (c == \u0026#39;)\u0026#39; \u0026amp;\u0026amp; st.top() != \u0026#39;(\u0026#39;) return false; 12 if (c == \u0026#39;}\u0026#39; \u0026amp;\u0026amp; st.top() != \u0026#39;{\u0026#39;) return false; 13 if (c == \u0026#39;]\u0026#39; \u0026amp;\u0026amp; st.top() != \u0026#39;[\u0026#39;) return false; 14 st.pop(); 15 } 16 } 17 return st.empty(); 18 } 19}; ","date":"November 30, 2022","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/leetcode/stack/exercises/20/","series":[{"title":"LeetCode","url":"/blog/series/leetcode/"}],"smallImg":"","tags":[{"title":"Stack","url":"/blog/tags/stack/"}],"timestamp":1669766400,"title":"20.有效的括号"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"LeetCode","url":"/blog/categories/leetcode/"}],"content":" 题目描述 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。\n解法一：迭代 迭代法应该是我们最容易想到的常规方法，也比较符合人的思维逻辑。其核心思想就是通过两个指针移动，来 一个一个的修改链表的指向方向。\n1class Solution { 2public: 3 ListNode* reverseList(ListNode* head) { 4 if (!head || !head-\u0026gt;next) return head; 5 ListNode* prev = nullptr; 6 ListNode* cur = head; 7 while (cur) { 8 ListNode* tmp = cur-\u0026gt;next; 9 cur-\u0026gt;next = prev; 10 prev = cur; 11 cur = tmp; 12 } 13 return prev; 14 } 15}; 解法二：递归 第二个方法就是使用递归，递归这种方法虽然不太容易能够想到，但是代码却很简洁。\n1class Solution { 2public: 3 ListNode* reverseList(ListNode* head) { 4 if (!head || !head-\u0026gt;next) return head; 5 ListNode* newHead = reverseList(head-\u0026gt;next); 6 head-\u0026gt;next-\u0026gt;next = head; 7 head-\u0026gt;next = nullptr; 8 return newHead; 9 } 10}; ","date":"November 30, 2022","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/leetcode/linkedlist/exercises/206/","series":[{"title":"LeetCode","url":"/blog/series/leetcode/"}],"smallImg":"","tags":[{"title":"LinkedList","url":"/blog/tags/linkedlist/"}],"timestamp":1669766400,"title":"206.反转链表"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"LeetCode","url":"/blog/categories/leetcode/"}],"content":" 题目描述 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。\n实现 MyStack 类：\nvoid push(int x) 将元素 x 压入栈顶。 int pop() 移除并返回栈顶元素。 int top() 返回栈顶元素。 boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。 注意：\n你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。\n题解 队列是 FIFO 的，而堆栈是 LIFO，要想用队列模拟堆栈，就需要在取出元素的时候，将一个队列中的除了最后一个元素的其他移动到另一个队列中，然后返回最后一个元素即可。\n1class MyStack { 2public: 3 MyStack() = default; 4 5 int push(int x) { 6 auto\u0026amp; q = q1_.size() \u0026gt; 0 : q1_ ? q2_; 7 q.push(x); 8 } 9 10 int pop() { 11 std::queue\u0026lt;int\u0026gt;\u0026amp; i = q1_.size() \u0026gt; 0 ? q1_ : q2_; 12 std::queue\u0026lt;int\u0026gt;\u0026amp; o = q1_.size() \u0026gt; 0 ? q2_ : q1_; 13 14 while (i.size() \u0026gt; 1) { 15 o.push(i.front()); 16 i.pop(); 17 } 18 int ret = i.front(); 19 i.pop(); 20 return ret; 21 } 22 23 int top() { 24 std::queue\u0026lt;int\u0026gt;\u0026amp; i = q1_.size() \u0026gt; 0 ? q1_ : q2_; 25 std::queue\u0026lt;int\u0026gt;\u0026amp; o = q1_.size() \u0026gt; 0 ? q2_ : q1_; 26 27 while (i.size() \u0026gt; 1) { 28 o.push(i.front()); 29 i.pop(); 30 } 31 int ret = i.front(); 32 i.pop(); 33 o.push(ret); 34 return ret; 35 } 36 37 bool empty() { 38 return q1_.empty() \u0026amp;\u0026amp; q2_.empty(); 39 } 40private: 41 std::queue\u0026lt;int\u0026gt; q1_; 42 std::queue\u0026lt;int\u0026gt; q2_; 43}; ","date":"November 30, 2022","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/leetcode/queue/exercises/225/","series":[{"title":"LeetCode","url":"/blog/series/leetcode/"}],"smallImg":"","tags":[{"title":"Queue","url":"/blog/tags/queue/"}],"timestamp":1669766400,"title":"225.用队列实现栈"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"LeetCode","url":"/blog/categories/leetcode/"}],"content":" 题目描述 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）： 实现 MyQueue 类：\nvoid push(int x) 将元素 x 推到队列的末尾 int pop() 从队列的开头移除并返回元素 int peek() 返回队列开头的元素 boolean empty() 如果队列为空，返回 true ；否则，返回 false 说明： 你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\n题解 堆栈的特性是 LIFO，而队列则是 FIFO，因此想要用堆栈实现队列，需要用两个堆栈的 LIFO 叠加效果，来实现 FIFO。\n1class MyQueue { 2public: 3 MyQueue() = default; 4 5 void push(int x) { 6 while (!output_.empty()) { 7 input_.push(output_.top()); 8 output_.pop(); 9 } 10 input_.push(x); 11 } 12 13 int pop() { 14 while (!input_.empty()) { 15 output_.push(input_.top()); 16 input_.pop(); 17 } 18 int ret = output_.top(); 19 output_.pop(); 20 return ret; 21 } 22 23 int peek() { 24 while (!input_.empty()) { 25 output_.push(input_.top()); 26 input_.pop(); 27 } 28 return output_.top(); 29 } 30 31 bool empty() { 32 return input_.empty() \u0026amp;\u0026amp; output_.empty(); 33 } 34private: 35 std::stack\u0026lt;int\u0026gt; input_; 36 std::stack\u0026lt;int\u0026gt; output_; 37}; ","date":"November 30, 2022","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/leetcode/stack/exercises/232/","series":[{"title":"LeetCode","url":"/blog/series/leetcode/"}],"smallImg":"","tags":[{"title":"Stack","url":"/blog/tags/stack/"}],"timestamp":1669766400,"title":"232.用栈实现队列"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"LeetCode","url":"/blog/categories/leetcode/"}],"content":" 题目描述 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。\n方法一：递归 这道题，最最简洁的方法应该就是使用递归了。主要思路是，每两个一组，进行交换，然后递归执行。\n1class Solution { 2public: 3 LinkedList* swapPairs(LinkedList* head) { 4 if (!head || !head-\u0026gt;next) return head; 5 // 当前组下的新的head 6 LinkedList* newHead = head-\u0026gt;next; 7 head-\u0026gt;next = swapPairs(newHead-\u0026gt;next); 8 newHead-\u0026gt;next = head; 9 return newHead; 10 } 11}; ","date":"November 30, 2022","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/leetcode/linkedlist/exercises/24/","series":[{"title":"LeetCode","url":"/blog/series/leetcode/"}],"smallImg":"","tags":[{"title":"LinkedList","url":"/blog/tags/linkedlist/"}],"timestamp":1669766400,"title":"24.两两交换链表中的节点"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"Programming","url":"/blog/categories/programming/"}],"content":" Ref: https://www.tangramvision.com/blog/c-rust-generics-and-specialization\n泛型入门：输入的类型 C++和 Rust 中的泛型都是一种将其他类型作为其定义的一部分的类型。泛型是通过在类型定义中指定占位符的一种方式，然后可以 使用更具体的类型来替换，例如在 C++中可以这定义一个泛型类型：\n1template\u0026lt;typename T\u0026gt; 2struct MyArray { 3 T* raw_array; 4 std::size_t size; 5}; 对于这个泛型结构而言，MyArray\u0026lt;int\u0026gt;和MyArray\u0026lt;std::string\u0026gt;是不同的类型。我们可以通过指定具体的T类型，来复用MyArray这个泛型结构体。这里的MyArray\u0026lt;T\u0026gt;就像一个“模板”一样。 泛型不仅仅局限于结构体，我们同样也能写出泛型函数：\n1template\u0026lt;typename T\u0026gt; 2T timestwo(T number) { 3 return number + number; 4} 上面我们定义了一个非常简单的函数，用来将数值加倍。同理，用具体类型实例化的timestwo\u0026lt;int\u0026gt;和timestwo\u0026lt;double\u0026gt;也不是同一个函数。\n而要在 Rust 中实现上面的函数，可能稍微复杂一点：\n1use std::ops::Add; 2 3fn timestwo\u0026lt;T\u0026gt;(number: T) -\u0026gt; \u0026lt;T as Add\u0026gt;::Output 4where 5 T: Add + Copy, 6{ 7 number + number 8} 很显然，上面 Rust 版本和 C++版本的实现相比看上去多了很多额外的语法。其中主要的区别是我们调用了特征边界检查，也就是T: Add + Copy， 或者用更通俗的话来说，T类型必须实现Add和Copy 特征(trait)。\n特征(traits) Rust 中使用trait作为我们在程序中与类型交互的方式。trait是与实现trait的类型相关联的一组属性、函数或者类型。例如 Add 是一个允许执行添加操作的接口。它表示一个类型具有“添加”到其他类型的特征。其定义大致如下：\n1pub trait Add\u0026lt;Rhs = Self\u0026gt; { 2 type Output; 3 4 fn add(self, rhs: Rhs) -\u0026gt; Self::Output; 5} 上面这个 trait 有两个属性：\n关联类型Output，用于定义add函数的返回类型； add函数，将自身添加到rhs. Rust 在编写泛型的时候用下面的方式来定义 traits 的实现，就像一开始我们提供的示例那样：\n1use std::ops::Add; 2 3fn timestwo\u0026lt;T\u0026gt;(number: T) -\u0026gt; \u0026lt;T as Add\u0026gt;::Output 4where 5 T: Add + Copy, 6{ 7 number + number; 8} where 语句用于限定，泛型参数T必须是实现了Add和Copy traits 的类型。\n类型替换(Type Substitution) 我们至此依然没有解释为什么 Rust 的示例比 C++的要冗长的多。现在对 traits 有了一定的了解，我们开始来了解类型替换，主要包含：\n什么是类型替换 什么时候触发类型替换 什么情况下的类型替换失败会被视为错误 替换就是将泛型中的T占位符填充成实际类型的过程。当我们在 C++中表示timestwo\u0026lt;int\u0026gt;的时候，我们将模板类型参数T替换成实际类型int。 而 C++和 Rust 在泛型中的主要区别体现在上述 2 和 3 方面：什么时候触发类型替换和什么情况下的类型替换失败会被视为错误。\n替换顺序和失败 在 C++中，替换发生在 function/struct等最终类型 check 之前。所以在我们前面的例子中，如果我们不引入任何替换，C++基本上不会关心 模板是什么或者我们如何使用模板。例如：\n1#include \u0026lt;iostream\u0026gt; 2 3template\u0026lt;typename T\u0026gt; 4T timestwo(T number) { 5 return number + number; 6} 7 8int main(int argc, char* argv[]) { 9 std::cout \u0026lt;\u0026lt; \u0026#34;Hello world\\n\u0026#34;; 10} 除非模板本身定义有语法问题，否则 C++不会关心timestwo是否对所有类型都有意义。直到发生了类型替换，才会做类型检查。所以将一些不相关的类型 插入到timestwo函数中可能也不会出现任何问题。\n有趣的是，C++有时候也可以替换一些预期之外的类型，例如std::string和std::filesystem::path都实现了operator+操作符，因此这些类型都允许 做加法操作（从技术上来说，这里的+是 append 的意思，而不是数字的求和）。这就意味着，timestwo对这些类型也有效，即使我们仅仅期望T为数字类型。\n有时这会导致一些混乱，因为模板适用于不太合适的类型。正如上面的例子中看到的，Rust 中可以通过添加一些特征绑定类避免这种情况。这样我们就只能传递 数字类型。而在 C++中，如果不使用高级特性的话，很难实现这一点。\nC++的示例只会在当我们使用一个错不支持operator+操作符的类型实例化timestwo模板的时候失败。即使其他所有类型对这个模板而言都是错误的，它只需要对于 正在使用这个模板的类型是正确的就行。\n1// Okay, int 支持 \u0026#39;+\u0026#39; 操作符 2int a = 2; 3int b = timestwo(a); 4 5// Foo 没有实现 \u0026#39;+\u0026#39; 操作符 6struct Foo { 7 int a; 8 float b; 9}; 10 11Foo c = Foo{1, 2.0}; 12 13// 错误不会出现在这里，而是出现在`timestwo`的定义中 14// 因为类型检查出现在泛型替换之后 15Foo d = timestwo(c); 所以只要我们不在模板中使用不支持我们期望的特征的类型，C++编译器就不会有任何错误或异常提示。\n与之相对，Rust 采取了截然不同的处理方式。类型检查发生在模板替换之前。这也就是说，我们的泛型必须对任何可以被替换的类型有效，然后才允许我们做模板类型替换。 这也就是为什么 Rust 的示例代码不能像 C++那样写：\n1// 会发生编译错误，因为这个模板不适用于所有的类型 2fn timestwo\u0026lt;T\u0026gt;(number: T) -\u0026gt; T { 3 number + number; 4} 5 6fn main() { 7 println!(\u0026#34;Hello world!\u0026#34;); 8} 如果我们按照上面的方式编写 Rust 代码，那么我们无法保证每一种可能的T类型都能够被添加到自身，因我我们无法知道number + number是否对所有类型都是合法的。 例如：timestwo\u0026lt;bool\u0026gt;就不是合法的，因为bool类型在 Rust 中不能做+操作。\n这也就是 Rust 中使用 traits 的原因——通过在模板类型参数T上指定特征边界，我们限定了泛型需要具有的特征范围。所以尽管我们没有在 Rust 中使用timestwo\u0026lt;string\u0026gt;，但是如果timestwo的定义没有添加限定条件的话，它一样是非法的。\n利与弊 前面我们详细描述了 Rust 和 C++泛型之间的主要区别，即 Rust 对模板的正确性有更加严格的保证，必须在模板定义的时候指定模板所适用类型的所有特征。 而 C++在定义模板的时候并不要求能够适用于所有类型，只是在模板实例化的时候才会做相应的检查。\n这是一个很微妙的区别，但是它却能产生很大的影响。C++中的泛型不能保证适用于所有类型，也没有真正明确的方法来实现一个模板，一旦它被成功编译， 就能适用于任何类型，我们总是能用一些新的类型破坏模板。在 C++中，越是复杂的泛型，使用起来越是要小心。\n虽然利用现代 C++的一些特性，如 SFINAE 或 C++20 的 Concepts，我们也能大致了解 Rust 中的 traits 是如何实现的， 并且能够近似保证对实现\"Concepts\"的所有类型都有效。但是和 Rust 仍然不太一样。C++模板在编译出错的时候抛出的错误信息让人很难理解。 相比之下，Rust 能够保证泛型的可持续构建，并且在构建的过程中，对可接受的类型都能良好工作。但是这也为我们编码带来了额外的负担——我们需要 保证我们使用到的所有的属性都在特征范围之内，否则编译器就会报错。如果我们需要大量的特征边界，那么这些特征边界将会变得很长，而且很难处理。 有时候，将看起来很容易理解的属性编码为 traits 的时候，实践起来却很不容易理解。\n此外，C++的模板编译错误是发生在模板实例化的时候，而 Rust 在定义模板的时候就导入了所有的相关特征，因此编译器在生成特定的实例之前已经拥有了 类型检查定义所需要的所有信息。在 Rust 中，如果你尝试在泛型函数中使用特征边界未指定的功能，那么在泛型函数的主体中会抛出相应的错误。如果你 尝试将类型不符合泛型特征边界所允许的类型使用到泛型函数，那么会在错误信息中明确指明传入的类型缺少哪种特征。C++在模板实例化的时候生成错误 ，也就是说如果缺少输入类型的属性，将在函数模板的主体中显示错误。对于使用中的每种不正确的输入类型，都会出现错误。此外 C++模板在不同编译 单元中重复出现，因此在编译器输出中出现多次同样的模板替换错误也并不罕见。\n当然，如果你对 C++非常熟悉的话，可能会觉得这点差异也无足轻重。\n特化(Specialization) C++和 Rust 之间的另一个很大的区别是泛型的特化。泛型特化就是我们定义模板针对某些特殊类型执行特殊逻辑的过程。在这种定义中，模板针对具体的 类型的定义与泛型共存。C++中一个典型的例子是std::vector，std::vector\u0026lt;T\u0026gt;的内部实现行为与std::vector\u0026lt;bool\u0026gt;不同，甚至针对这一特化有专门的文档：https://en.cppreference.com/w/cpp/container/vector_bool\nC++和 Rust 的差异让我们不得不去思考，在有特化的地方如何进行代码转换。在 C++中，是支持泛型特化的，但是这使得代码中某些类型的属性检查变得 更加复杂。相反，Rust 不支持特化。下面让我们通过一些例子来看看特化是如何实现的。\nC++ 特化 在 C++中，我们通常会像下面这样定义一个通用的Image类型：\n1template\u0026lt;typename Pixel\u0026gt; 2struct Image { 3 std::vector\u0026lt;Pixel\u0026gt; pixels; 4 std::size_t width; 5 std::size_t height; 6}; 这个类适用于多种像素类型，特别是像单像素、RGB 像素、BGRA 像素等。但是如果我们想使用交织像素（例如 YUV422），其中多个像素值被分组在一起， 使得矢量像素的一个元素不一定表示一个像素，我们将很难直接使用上面的定义。相反，假如我们有一些像 YUV422 的表示形式 UYVY，我们可以在上面的 模板定义后附加下面的特化：\n1struct UYVY {}; 2 3template\u0026lt;\u0026gt; 4struct Image\u0026lt;UYVY\u0026gt; { 5 // U, V, and Y sub-pixels are just single bytes. 6 // 7 // So we store the whole interleaved buffer without transforming it 8 // or changing from YUV422 to YUV444, or RGB8, or something else. 9 // 10 // Then, when we index into this vector (with a member function or 11 // otherwise), we just need to remember the interleaved pattern but 12 // _ONLY_ for this specialization. 13 std::vector\u0026lt;unsigned char\u0026gt; pixels; 14 std::size_t width; 15 std::size_t height; 16}; 正如我们所看到的，在 C++中添加模板特化是很简单的。C++为泛型特化制定了一系列规则，在模板实例化时，尽可能选择最具体的定义。在上面的例子 中template\u0026lt;\u0026gt;比template\u0026lt;T\u0026gt;更具体，因为它拥有更少的泛型类型。\n而缺点是，我们需要为每个特例版本实现一套独立的逻辑，当然这个也很显然，特例就是通用的例外情况。但是如果特例定义很多的话，这将是一项艰巨的 工作。\nRust 特化 Rust 无法像 C++那样在编写代码时为泛型定义特化的实现。 回到上面的Image的例子，我们显然不能像 C++中的std::vector\u0026lt;bool\u0026gt;或者Image\u0026lt;UYVY\u0026gt;那样为特定的类型做 特定的实现。在 Rust 中，traits 允许我们根据某些接口对类型进行分组，并且允许我们具有不同特征边界的相同泛型。 因此，我们可以将像素分为两组：\n非交织的像素类型：RGB, BGRA 等 交织的像素类型：UYVY, YUYV 等 我们可以像下面这样来改造我们的代码：\n1pub struct Rgb { 2 r: u8, 3 g: u8, 4 b: u8, 5} 6 7pub struct Bgra { 8 r: u8, 9 g: u8, 10 b: u8, 11 a: u8, 12} 13 14pub struct Uyvy {} 15 16pub trait NotInterleaved {} 17impl NotInterleaved for Rgb; 18impl NotInterleaved for Bgra; 19 20pub trait Interleaved {} 21impl Interleaved for Uyvy; 22 23pub struct Image\u0026lt;Pixel\u0026gt; 24where 25 Pixel: NotInterleaved, 26{ 27 pixels: Vec\u0026lt;Pixel\u0026gt;, 28 width: usize, 29 height: usize, 30} 31 32pub struct Image\u0026lt;Pixel\u0026gt; 33where 34 Pixel: Interleaved, 35{ 36 pixels: Vec\u0026lt;u8\u0026gt;, 37 width: usize, 38 height: usize, 39} 但是这样写代码并不是太理想，因为这些 traits 对我们来说没有太大的意义。我们每次给Image\u0026lt;P\u0026gt;添加某种功能，都要 指定是针对Interleaved还是NotInterleaved。这在某种程度上也丧失了使用泛型的优点。\n那么就没有更加优雅的方式来改进吗？当然有！假如我们只是为了适配 RGB、BGRA 和 UYVY 像素类型，我们可以尝试像下面 这样使用 traits 和泛型来抽象我们的代码：\n1pub struct ContiguousPixelImage\u0026lt;Pixel\u0026gt; { 2 pixels: Vec\u0026lt;Pixel\u0026gt;, 3 width: usize, 4 height: usize, 5} 6 7pub struct UyvyImage { 8 pixels: Vec\u0026lt;u8\u0026gt;, 9 width: usize, 10 height: usize, 11} 12 13// Instead of trying to make a template that does everything, we make serveral 14// separate types from a template and group them via a trait instead. 15pub trait Image { 16 // All image operations / types /functions in here 17} 18 19impl\u0026lt;P\u0026gt; Image for ContiguousPixelImage\u0026lt;P\u0026gt; { 20 // ... 21} 22 23impl Image for UyvyImage { 24 // ... 25} 这里并没有将泛型指定为一个单一的类型，而是用不同的名字定义了不同的类型。我们依然需要为不同的像素类型提供 不同的定义，但是可以将通用的部分抽象到一个 trait 中来统一处理。\n","date":"November 12, 2022","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/rust/2022-11-13-rust%E5%92%8Cc++%E5%AF%B9%E6%AF%94%E4%B9%8B%E6%B3%9B%E5%9E%8B%E5%92%8C%E7%89%B9%E4%BE%8B%E5%8C%96/","series":[],"smallImg":"","tags":[{"title":"Rust","url":"/blog/tags/rust/"}],"timestamp":1668211200,"title":"Rust和C++: 泛型和特例化"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"LeetCode","url":"/blog/categories/leetcode/"}],"content":" 题目描述 给你一个 m x n 的矩阵 board ，由若干字符 \u0026lsquo;X\u0026rsquo; 和 \u0026lsquo;O\u0026rsquo; ，找到所有被 \u0026lsquo;X\u0026rsquo; 围绕的区域，并将这些区域里所有的 \u0026lsquo;O\u0026rsquo; 用 \u0026lsquo;X\u0026rsquo; 填充。\n解法一：并查集 这道题通常会用DFS来解，但是也可以用并查集解：首先我们将四条边上的\u0026rsquo;O\u0026rsquo;合并成一个连通分量，然后再将圈内的所有相邻的 \u0026lsquo;O\u0026rsquo;连接起来，最后遍历整个表，将所有为\u0026rsquo;O\u0026rsquo;且不与四条边上的\u0026rsquo;O\u0026rsquo;所在的连通分量相连的节点设置为\u0026rsquo;X\u0026rsquo;即可。\n1#include \u0026lt;vector\u0026gt; 2#include \u0026lt;unordered_map\u0026gt; 3 4class UnionFind { 5public: 6 UnionFind(int num) { 7 for (int i = 0; i \u0026lt; num; ++i) { 8 parent_.push_back(i); 9 } 10 } 11 12 void unite(int p, int q) { 13 int pRoot = find(p); 14 int qRoot = find(q); 15 if (pRoot == qRoot) { 16 return; 17 } 18 parent_[pRoot] = qRoot; 19 } 20 21 bool connected(int p, int q) { 22 return find(p) == find(q); 23 } 24 25 int find(int p) { 26 if (p != parent_[p]) { 27 parent_[p] = find(parent_[p]); 28 } 29 return parent_[p]; 30 } 31 32private: 33 std::vector\u0026lt;int\u0026gt; parent_; 34}; 35 36class Solution { 37public: 38 void solve(std::vector\u0026lt;std::vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board) { 39 int m = board.size(); 40 int n = board[0].size(); 41 UnionFind uf(m * n + 1); 42 int dummy = m * n; 43 // 先将四条边上为\u0026#39;O\u0026#39;的节点连接起来 44 for (int i = 0; i \u0026lt; m; ++i) { 45 if (board[i][0] == \u0026#39;O\u0026#39;) { 46 uf.unite(dummy, i * n); 47 } 48 if (board[i][n - 1] == \u0026#39;O\u0026#39;) { 49 uf.unite(dummy, i * n + n - 1); 50 } 51 } 52 for (int j = 0; j \u0026lt; n; ++j) { 53 if (board[0][j] == \u0026#39;O\u0026#39;) { 54 uf.unite(dummy, j); 55 } 56 if (board[m - 1][j] == \u0026#39;O\u0026#39;) { 57 uf.unite(dummy, (m - 1) * n + j); 58 } 59 } 60 // 再将内部相邻的\u0026#39;O\u0026#39;连接起来 61 // 上 下 左 右 62 std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; 63 for (int i = 1; i \u0026lt; m - 1; ++i) { 64 for (int j = 1; j \u0026lt; n - 1; ++j) { 65 if (board[i][j] == \u0026#39;X\u0026#39;) continue; 66 for (const auto\u0026amp; dir : directions) { 67 if (board[i + dir[0]][j + dir[1]] == \u0026#39;X\u0026#39;) continue; 68 uf.unite(n * i + j, n * (i + dir[0]) + j + dir[1]); 69 } 70 } 71 } 72 73 // 最后将所有不与dummy连通的\u0026#39;O\u0026#39;设置为\u0026#39;X\u0026#39;即可 74 for (int i = 1; i \u0026lt; m; ++i) { 75 for (int j = 1; j \u0026lt; n; ++j) { 76 if (board[i][j] == \u0026#39;O\u0026#39; \u0026amp;\u0026amp; !uf.connected(dummy, n * i + j)) { 77 board[i][j] = \u0026#39;X\u0026#39;; 78 } 79 } 80 } 81 } 82}; ","date":"November 7, 2022","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/leetcode/union-find/exercises/130/","series":[{"title":"LeetCode","url":"/blog/series/leetcode/"}],"smallImg":"","tags":[{"title":"UnionFind","url":"/blog/tags/unionfind/"}],"timestamp":1667822160,"title":"130.被围绕的区域"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"LeetCode","url":"/blog/categories/leetcode/"}],"content":" 题目描述 给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程equations[i]的长度为 4，并采用两种不同的形式之一：\u0026quot;a==b\u0026quot; 或 \u0026quot;a!=b\u0026quot;。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。 只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。\n题解 这一道题，显然是用并查集来解决，思路很简单，由于相等具有传递性，可以认为，一开始所有的字母变量都是独立的 集合，通过等式传递性，可以将这些相等的字母合并到同一个集合，最后看不等式中，是否存在连通的字母，如果存在 则表示等式方程不满足条件。\n1#include \u0026lt;vector\u0026gt; 2#include \u0026lt;unordered_map\u0026gt; 3 4class UnionFind { 5public: 6 UnionFind(int num) { 7 for (int i = 0; i \u0026lt; num; ++i) { 8 parent_.push_back(i); 9 } 10 } 11 12 void unite(int p, int q) { 13 int pRoot = find(p); 14 int qRoot = find(q); 15 if (pRoot == qRoot) { 16 return; 17 } 18 parent_[pRoot] = qRoot; 19 } 20 21 int find(int p) { 22 if (p != parent_[p]) { 23 parent_[p] = find(parent_[p]); 24 } 25 return parent_[p]; 26 } 27 28private: 29 std::vector\u0026lt;int\u0026gt; parent_; 30}; 31 32class Solution { 33public: 34 bool equationsPossible(const std::vector\u0026lt;std::string\u0026gt;\u0026amp; equations) { 35 // 26个小写字母 36 UnionFind uf(26); 37 for (const auto\u0026amp; e : equations) { 38 if (e[1] == \u0026#39;!\u0026#39;) { 39 continue; 40 } 41 uf.unite(e[0] - \u0026#39;a\u0026#39;, e[3] - \u0026#39;a\u0026#39;); 42 } 43 for (const auto\u0026amp; e : equations) { 44 if (e[1] == \u0026#39;=\u0026#39;) { 45 continue; 46 } 47 if (uf.find(e[0] - \u0026#39;a\u0026#39;) == uf.find(e[3] - \u0026#39;a\u0026#39;)) { 48 return false; 49 } 50 } 51 return true; 52 } 53}; ","date":"November 6, 2022","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/leetcode/union-find/exercises/990/","series":[{"title":"LeetCode","url":"/blog/series/leetcode/"}],"smallImg":"","tags":[{"title":"UnionFind","url":"/blog/tags/unionfind/"}],"timestamp":1667743885,"title":"990.等式方程的可满足性"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"LeetCode","url":"/blog/categories/leetcode/"}],"content":" 题目描述 给定一个未排序的整数数nums，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。 请你设计并实现时间复杂度O(n)的算法解决此问题。\n解法一：并查集 这道题目可以用并查集来解决。初始状态下数组中的每个元素都是一个独立的集合，然后遍历数组，将当前元素相邻的 元素合并到一个集合，最后返回所有集合中元素个数最多的数量。这里要注意去重。\n1#include \u0026lt;vector\u0026gt; 2#include \u0026lt;unordered_map\u0026gt; 3 4class UnionFind { 5public: 6 UnionFind(int num) { 7 for (int i = 0; i \u0026lt; num; ++i) { 8 parent_.push_back(i); 9 size_.push_back(1); 10 } 11 } 12 13 void unite(int p, int q) { 14 int pRoot = find(p); 15 int qRoot = find(q); 16 if (pRoot == qRoot) { 17 return; 18 } 19 parent_[pRoot] = qRoot; 20 size_[qRoot] += size_[pRoot]; 21 } 22 23 int find(int p) { 24 if (p != parent_[p]) { 25 parent_[p] = find(parent_[p]); 26 } 27 return parent_[p]; 28 } 29 30 int maxConnectedSize() { 31 int ret = 0; 32 for (int i = 0; i \u0026lt; parent_.size(); ++i) { 33 if (parent_[i] == i) { 34 ret = std::max(ret, size_[i]); 35 } 36 } 37 return ret; 38 } 39 40private: 41 std::vector\u0026lt;int\u0026gt; parent_; 42 std::vector\u0026lt;int\u0026gt; size_; 43}; 44 45class Solution { 46public: 47 int longestConsecutive(std::vector\u0026lt;int\u0026gt;\u0026amp; nums) { 48 49 // 用于记录元素和下标的对应关系，同时也用来去重 50 std::unordered_map map; 51 52 // 构造一个并查集实例，以下标来表示nums中的一个数字 53 // 初始状态下，每个元素都是独立的集合 54 UnionFind uf(nums.size()); 55 56 for (int i = 0; i \u0026lt; nums.size(); ++i) { 57 // 去重 58 if (map.find(nums[i]) != map.end()) { 59 continue; 60 } 61 62 // 将比当前元素小1的元素连接起来 63 if (map.find(nums[i] - 1) != map.end()) { 64 uf.unite(i, map[nums[i] - 1]); 65 } 66 67 // 将比当前元素大1的元素连接起来 68 if (map.find(nums[i] + 1) != map.end()) { 69 uf.unite(i, map[nums[i] + 1]); 70 } 71 72 // 记录元素和下标的对应关系 73 map[nums[i]] = i; 74 } 75 76 // 返回最终所有集合中，元素最多的集合的元素个数 77 return uf.maxConnectedSize(); 78 } 79}; ","date":"November 5, 2022","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/leetcode/union-find/exercises/128/","series":[{"title":"LeetCode","url":"/blog/series/leetcode/"}],"smallImg":"","tags":[{"title":"UnionFind","url":"/blog/tags/unionfind/"}],"timestamp":1667642726,"title":"128.最长连续序列"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"Programming","url":"/blog/categories/programming/"}],"content":" Ref: https://www.tangramvision.com/blog/c-rust-interior-mutability-moving-and-ownership\nC++和 Rust 中的不变性(constness) 值 Rust 和 C++有两个非常相似的概念，即 Rust 中的 mutability/immutability 和 C++中的 constness/non-constness. 在 Rust 中，一个给定的值要么是可变的(mutable)，要么是不可变的(immutable)，正如这些限定符名称所代表的含义，可变的值可以被修改，不可变的值不能被修改。 然而与 C++不同的是，Rust 中不可变的值可以被移动(move)，就像下面的代码实例那样：\n1fn foo() { 2 let x = 1; 3 println!(\u0026#34;{}\u0026#34;, x) 4 let mut x = x; 5 x *= 10; 6 println!(\u0026#34;{}\u0026#34;, x); 7} 在 C++中，给定的值要么是常量(const)，要么是非常量(non-const)。但是 C++中的常量值不能被移动(move)。在 C++中，对一个 const 限定符修饰的值 进行std::move操作，实际上会触发拷贝构造，这一点在\u0026quot;Effective Modern C++\u0026ldquo;这本书中作者也有提到：\n1class Annotation { 2public: 3 explicit Annotation(const std::string text) 4 : value(std::move(text)) //here we want to call string(string\u0026amp;\u0026amp;), 5 //but because text is const, 6 //the return type of std::move(text) is const std::string\u0026amp;\u0026amp; 7 //so we actually called string(const string\u0026amp;) 8 //it is a bug which is very hard to find out 9 {} 10private: 11 std::string value; 12}; 我们也可以自己写一段程序来验证一下：\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026lt;string\u0026gt; 3 4struct Foo { 5 Foo() { std::cout \u0026lt;\u0026lt; \u0026#34;default constructor\u0026#34; \u0026lt;\u0026lt; std::endl; } 6 Foo(const Foo\u0026amp;) { std::cout \u0026lt;\u0026lt; \u0026#34;copy constructor\u0026#34; \u0026lt;\u0026lt; std::endl; } 7 Foo(Foo\u0026amp;\u0026amp;) { std::cout \u0026lt;\u0026lt; \u0026#34;move constructor\u0026#34; \u0026lt;\u0026lt; std::endl; } 8}; 9 10int main(int argc, char* argv[]) { 11 const Foo foo; 12 Foo other = std::move(foo); 13 return 0; 14} 15 16// 执行结果： 17// default constructor 18// copy constructor 引用 引用在 C++和 Rust 中有一些相似。对于这两种语言，引用是一段数据的句柄，它允许程序员在不传递副本的情况下引用该数据。 在这两个语言中，引用都是指针的语法糖。而与指针不同的是，引用或多或少能保证它指向的数据的有效性(至少在创建的时候)。\n错误的使用引用是 C++中错误的主要来源。而在 Rust 中提供了更多的安全保证，可以消除大多数这些错误。例如 C++并不保证 只要引用存在就一定有效，就像下面这段代码这样：\n1int\u0026amp; bad_foo() { 2 int x = 0; 3 return x; 4} 上面这个函数返回了对堆栈上分配的值的引用，当函数返回时，栈帧被释放，那么改引用就失效了。 虽然现代 C++编译器和 linter 会针对类似于上面的简单的 case 做出一些诊断，但是在更复杂的情况下它们也无能为力。 Rust 使用生命周期来保证引用对象的有效性，除非你使用了显示不安全的代码。\n借用 在 Rust 中创建引用的过程被称为借用(borrowing)。在 Rust 中，你只能可变的借用一个可变的值，就像在 C++中一样，通常只能创建 一个非常量值的非常量引用。不同的是，在 Rust 中虽然允许对一个值有多个不可变的借用，但是在同一时刻只能有一个独占的可变借用， 更进一步说，就是当存在一个可变引用的时候，不允许有其他任何引用，无论是可变的还是不可变的。C++中则没有这个限制。\n你可能想知道加上这样的限制到底有啥好处。有的人可能会认为这样做更安全，因为当存在可变引用的时候，不允许其他引用存在。这只能算是部分正确： 这种借用行为确实消除了多线程场景中的竟态条件。然而它也使得跨线程的只读访问之外的任何数据共享都变得不可能，当然 Rust 为我们提供了其他工具 来实现跨线程的 non-trivial 共享和确保其安全性。\nRust 中的借用限制真正做的事情实际上是避免出现任何内存别名(memory aliasing)。当两个指针(或者这里说成引用)指向相同的或者重叠的内存区域时，就会发生内存别名。\n内存别名(Memory Aliasing) 别名是编译器优化的障碍。对内存的读取和写入操作通常是一个给定函数中最慢的部分，可能存在的别名会迫使编译器比代码作者的预期更加频繁的发出加载指令。\n由于 Borrow-Checker 的强制规则，Rust 编译器可以自由的假设不会有内存别名的情况发生。而 C++编译器却不能这么做。一些 C++编译器有一些 flag，用来控制是否开启假设不会出现内存别名， 也有的 C++编译器使用关键字(例如__restrict__)来注释指针，从而将程序员的假设传达给编译器。但是这些终究只是假设而不是承诺，因此可能会在 无意中被违反，从而产生一些未知的 bug 或者未定义行为。\n下面让我们快速看一个顺序读写的示例，该示例向我们展示了由于内存别名而造成了性能问题。下面两个代码片段是分别用 Rust 和 C++实现了功能相同的函数。 C++版本中使用#defien来帮助我们开启编译器的 aliasing assumptions 开关(-DDMAYBE_RESTRICT=__restrict__)。需要特别强调的是，在安全的 Rust 中调用 src 和 dst 重叠的 foo 函数是不可能的：\n1fn foo(src: \u0026amp;[u32], dst: \u0026amp;mut [u32]) { 2 assert_eq!(src.len(), dst.len()); 3 let mut i = 0; 4 while i \u0026lt; src.len() { 5 dst[i] = src[i]; 6 if src[i] % 2 == 0 { 7 i += 1; 8 } else { 9 i += 2; 10 } 11 } 12} 1#ifndef DMAYBE_RESTRICT 2#define DMAYBE_RESTRICT 3#endif 4 5void foo(const uint32_t* DMAYBE_RESTRICT src, uint32_t* DMAYBE_RESTRICT dst, std::size_t len) { 6 std::size_t i = 0; 7 while (i \u0026lt; len) { 8 dst[i] = src[i]; 9 if (src[i] % 2 == 0) { 10 i += 1; 11 } else { 12 i += 2; 13 } 14 } 15} 在 main 函数中，我们分配了一个大小为 100000000 的缓冲区，并填充了测试数据，然后测量调用foo所消耗的时间。 当使用clang++在开启最高优化等级的时候，使用了__restrict__关键字的 C++版本和 rust 版本消耗的时间大致相当。 而不使用__restrict__关键字的 C++版本则需要多消耗一倍的时间。\n那么我们为什么要在一篇讨论 constness 的文章中来探讨性能呢？与 Rust 中 immutability 相对应的 constness 和关于 mutable borrow 的 Borrow-Checker 规则是保证 不会出现内存别名的关键。优点是性能和正确性，但是代价是必须遵守 Borrow-Checker 的规则。\n在 C++中实现相同的事情也是可能的，但是你必须将你的假设告诉编译器。如果你想避免出现 bug，那就必须由你来确保这些假设的正确性。当然你也可以选择不必和 Borrow-Checker 对抗。\nC++和 Rust 中的移动 C++和 Rust 中的移动语义在概念上类似。不同的是他们如何集成到各自的语言当中的。C++在 C++11 才引入移动语义，而 Rust 在诞生之初就集成了 move 语义。\nC++中的移动 在 C++中，移动跟类的特殊成员函数密切相关：构造函数和赋值运算符。构造函数和赋值运算符被重载以接收不同类型的引用。C++根据值的类型来区分不同的引用。 左值引用通常是指对于具名值的引用，并且用一个\u0026rsquo;\u0026amp;\u0026lsquo;符号连接；右值引用通常是对表达式计算的临时结果的引用，并且用\u0026rsquo;\u0026amp;\u0026amp;\u0026lsquo;符号连接。\n这里对值类别的总结过于简单，但是对于本文来说足够了。详细完整的描述可以参考: n3055\n当我们调用这些特殊的成员函数的时候，重载解析过程会根据引用类型匹配合适的重载函数。我们来看下面这个示例：\n1class S { 2public: 3 S() {} // Default Constructor 4 S(const S\u0026amp;) {} // Copy Constructor 5 S(S\u0026amp;\u0026amp;) {} // Move Constructor 6 S\u0026amp; operator=(const S\u0026amp;) {} // Copy Assignment Operator 7 S\u0026amp; operator=(S\u0026amp;\u0026amp;) {} // Move Assignment Operator 8}; 上面这个类同时具有拷贝构造函数和移动构造函数。当我们尝试使用一个已经存在的引用来构造一个新的S的时候，编译器会通过判断 值的类别来决定使用移动构造还是拷贝构造。\n如果引用是函数的返回值或者是通过表达式计算出来的，那么该引用是右值引用，此时会使用移动构造。如果我们仅仅是简单的传递了一个具名变量 那么通常这里是左值引用，会使用拷贝构造：\n1void test() { 2 S s; 3 S s_copied(s); // Copy Constructor 4 S s_moved(make_me_an_S_please()); // Move Constructor, passing a result 5} 那么当我们有一个左值的时候，我们要如何移动呢？答案是使用std::move函数。但是这个函数是怎么实现的呢？莫不是使用了什么技巧来移动对象？当然不是！ 打开std::move的源码我们可以很容易发现这个函数仅仅是做了一个类型转换，其他的什么都没做。它将一个左值引用转换成了一个右值引用:\n1template \u0026lt;class _Tp\u0026gt; 2_LIBCPP_NODISCARD_EXT inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR typename remove_reference\u0026lt;_Tp\u0026gt;::type\u0026amp;\u0026amp; 3move(_Tp\u0026amp;\u0026amp; __t) _NOEXCEPT { 4 typedef _LIBCPP_NODEBUG typename remove_reference\u0026lt;_Tp\u0026gt;::type _Up; 5 return static_cast\u0026lt;_Up\u0026amp;\u0026amp;\u0026gt;(__t); 6} 但是当我们将std::move与构造函数一起使用的时候，就会触发移动构造的调用。\n1void test() { 2 S s; 3 std::move(s); // This has no effect at all 4 S s2; 5 s2 = std::move(s); // move s to s2 by Move Assignment Operator 6} C++中移动语义经常会给程序员带来麻烦。std::move仅仅是将左值引用类型转换成右值引用，然后触发特殊成员函数的右值引用重载版本的调用。 实际上，在 C++中移动只是将一个值传递给这些特殊的重载函数之一，这对移动对象的生命周期并没有影响。在上面的例子中，对象s并不会因为 被移动了而变得不可用或者超出使用范围，也就意味着我们在移动之后仍然可以自由的使用s对象。虽然一些编译器会给出use-after-move的 警告，但是这并不能涵盖到所有的场景。\nC++移动语义的另一个问题就是，它需要程序员自己来编写移动函数。这就意味着可能会写出有 bug 的构造函数，此外我们对移动构造和移动赋值的行为也没有达成共识。 人们普遍认为，这些函数应该以一种高效的形式将资源从一个对象转移到另一个对象，而不应该是拷贝。\n另一个问题是，当我们在处理被移动的vector的时候，如果我们知道这个vector再也不会被使用，那么我们可能会简单的什么都不做。没有人会对这个vector再做任何改变，但是 我们忽略了一点，这个被移动的vector仍然存在，当它超过它的作用域的时候，就会调用析构函数，也就是说，如果我们不清除掉被移动的vector中的元素，那么这些元素可能会触发 double free。这种情况有一个很容易想到的答案，就是将已经被 move 的vector的状态设置为同默认构造(没有任何空间分配)的vector一样的状态，这样就能避免 double free 的问题， 同时也很容易析构。\n然而，并不是所有的情况都那么容易，因为不是所有的对象都是默认可构造的，将被移动的对象在移动完它的资源后设置为一个有效的状态有时是很昂贵的操作。 通常会给一个对象添加一些额外的状态以避免昂贵的重复初始化操作。对于更复杂的对象，通常会在数据成员中添加形如bool _isInitialized或者bool _shouldDestroyX这样的字段 来处理析构函数的条件行为。尽管使用值比使用指针更加自然，但是人们常常将对象用std::unique_ptr包装起来，以此来避免移动的过程中对象被析构。\n最终要的是，没有明确的操作指南。各种来源的建议表明，移动函数应该将被移动的对象设置为“有效，但是不确定的状态”，但是这也太模糊了。\nRust 中的移动 从 Rust 诞生之初开始，移动便是它的组成部分。因此人们可能会觉得 Rust 中的移动更加完整，因为通常情况下程序员不需要定义移动的行为，所以移动在 Rust 中更容易解释。\n移动总是一个字节一个字节的内存拷贝 移动会消耗被移动的对象，一个对象一旦被移动，那么再去访问或引用它就会触发编译器报错 如果一个类型实现了 Copy trait，那么对该类型的对象进行 move 操作仍然是按字节做内存拷贝，但是不再消耗被移动的对象。这种规则应该只适用于简单的类型，它们没有复杂的所有权语义， 例如，例如像整型这样的简单的内置 primitive 类型，但是string就不行，因为它拥有一个在堆上分配的字符串。即使我们想为 string 实现Copy（虽然这是不可能的，以为它内部的Vec不允许Copy）， 那也只是浅的拷贝，这将会违背一个String只有一个所有者的理念。 移动不会造成被移动对象的销毁。在 Rust 中，实现 Drop trait 能够允许我们自定义类型的销毁行为。因此 Rust 中的Drop有点类似于 C++中的非平凡析构函数。 对比 简而言之，主要区别就是 Rust 中有破坏性的 move，而 C++中没有；C++中有特殊的成员函数，但是 Rust 中没有。 就像许多 C++和 Rust 特性的对比那样，你也可以用 Rust 更加刻意和呆板，而 C++具有更高的灵活度来总结。通常情况下，Rust 已经帮我们做了很多， 我们不必再考虑那些繁琐的问题，但是当面对一些边缘 case（定制移动行为可能会有所帮助）的时候就会变得非常困难。而在 C++中，我们有更大 的出现 bug 的可能。另一方面，如果你想构建功能完备，且具备值语义的类型，同时将它们与其他的类型进行组合成一个新的类型，那么你可能没有必要 自己实现移动构造函数，在这种情况下整个过程是很顺利的，但是这个仅仅是因为遵循了规范产生的结果，而不是编译器告诉我们该如何去做。\nC++和 Rust 中的共享所有权 在开始讨论所有权之前，我们先来定义它。所有权有几个方面，这取决于你所使用的技术以及你是否与潜在的外部所有者（例如，给你提供资源的操作系统）对接。 在这个特殊的上下文环境中，所有者仅仅是指对对象生命周期的控制以及该控制何时结束。这里所有权很大程度上取决于谁何时应该删除一个对象。明确的所有权规则 能够避免很多 bug，例如对同一个对象的多次释放，或者对一个已经释放的对象进行引用等。\n在 C++和 Rust 中，一般值对象（非指针和应用）存在于堆栈中，或者作为其他对象的成员，可以认为归属于包含它们的作用域。当然，对象可能会在不同的作用域之间移动， 或者作为函数的返回值返回，但是最终，对象没有移动，而且作用域结束，那么对象的生命周期也就结束了。\n独享所有权(Single-Owner): Box 和 std::unique_ptr 将所有权和作用域分开的主要方式就是将对象放在堆上。在 C++和 Rust 中，都推荐使用智能指针的方式与堆进行对接。它们在这两种语言上的工作方式大致相同，智能指针拥有 分配对象的所有权，并将该对象的生命周期与自身绑定，也就是说谁拥有了智能指针的所有权，也就相当于拥有了其内部对象的所有权。\nC++ 由于 C++和 C 兼容性关系，在 C++中存在很多手动分配堆内存的方式（例如: new, malloc等）。这些方式只为程序员返回了一个指针的所有权，但是指针可能会被复制或者泄露，而编译器 却不会有任何提示。在现代 C++中，手动管理内存不是通用的方式。C++中更推荐使用std::unique_ptr来管理独享所有权的堆内存，尽管它也允许包含一个空指针。\nRust 在 Rust 中，你可以使用Box来存放一个堆上分配的对象。一个 Box 拥有其持有的堆对象的所有权，跟 C++中std::unique_ptr不同的是，Box必须被安全的初始化。Box 还需要一个完全初始化的对象， 首先创建创建对象，然后再将其移动到堆内存中。它不能像 C++中那样，使用std::make_unique直接在堆构造对象。但是编译器通常会通过一些优化来避免不必要的拷贝和栈分配。\n这些智能指针用于独享所有权的情况。std::unique_ptr 禁用了拷贝构造和拷贝赋值。Box没有实现Copy只实现了Clone。这些特殊处理都是为了保证单一的所有者，而拷贝会导致所有者的增加， 从而打破了单一所有者的规则。如果你需要在堆上分配内存，使用Box和std::unique_ptr是非常不错的选择，但是最终它们也有同其他简单值类型一样的所有权语义。\n共享所有权(Shared-Owner): Rc,Arc,和 std::shared_ptr 共享所有权必须发生在堆上。共享所有权通过进行引用计数的智能指针作为媒介。这种智能指针在持有堆内存的同时，也会保存一个对该堆内存引用的计数器。对智能指针执行拷贝（通过克隆，或者拷贝构造） 会为其持有的堆内存增加一个新的所有者，这会触发引用计数器的自增。当一个智能指针超出其所在的作用域的时候，其内部的引用计数器就会自减。如果一个智能指针超出其所在的作用域，并且它是其持有 的堆内存的最后一个所有者，那么就会销毁该堆内存。\nC++ 在 C++中，使用std::shared_ptr来共享堆内存的所有权。它并没有被设计为在避免内存别名和线程安全方面提供太多的功能，而仅仅是保证正确的处理其持有的对象的生命周期，确保对象不会泄露也不会 被多次释放。std::shared_ptr仅仅在处理引用计数的时候提供了线程安全的保证，多个线程能够自由的新增和减少资源的所有者，它内部的引用计数器是原子的，因此能够保证一个对象恰好被释放一次。 但是其持有的资源是非线程安全的，如果要保证数据的线程安全，就需要通过其他方式，例如mutex。\nRust Rust 有两种共享型智能指针，一个是Rc(称为 Reference Count)，用于单线程的应用，另一个是Arc(Atomic Reference Count)，用于多线程环境。在安全的 Rust 中，编译器将会强制要求不会存在可变 内存别名和竟态资源的存在。智能指针也不会给这个规则添加例外。即使在单线程环境下，数据可能有多个所有者，也依然不允许内存别名。这也就意味着不借用其他工具，任何通过共享所有权的超出简单 只读访问的操作都是不可能实现的。\n内部可变性，Cells 的工作原理 到目前为止，我们在 Rust 中遇到了一些自我强加的限制。我们不能对同一个对象进行多个未完成的可变借用，同样的，如果一个对象有多个所有者，我们不能对这个对象进行修改操作，不管是在多线程环境 还是单线程环境中。\n所有的这些限制都是源于 Rust 中关于内存别名的规则。我们需要一种方法突破这些限制，否则将无法实现任何更有趣的事情。人们可以简单的了解一下不安全的代码，当然幸运的是，Rust 也提供了一种安全 的方式绕过这些限制，只需要损失一点性能。\n在 Rust 中，可以使用Cells来绕过这些限制。Cells有一个“内部可变”(Interior Mutability)的属性，当一个对象内部包含这个属性的时候，即使对象本身是不可变的，它也可以可变的被借用。\n不同类型的Cells可以适用于不同的场景。但是它们都是基于UnsafeCell的。UnsafeCell持有一个对象，并做了简单的包装。它提供了一个非常有趣的方法：\n1pub fn get(\u0026amp;self) -\u0026gt; *mut T get方法传入一个不可被借用的self，返回一个可变的指针。从功能上来说，这就是我们获取内部可变性的地方。有趣的是，尽管它的名字带了“不安全”，但是这里并没有使用任何不安全的代码。 在 Rust 中，你可以自由的安全的创建指针，但是解引用是不安全的，这也就意味着，UnsafeCell可以安全的创建，但是不能以任何非平凡(non-trivial)的方式使用。\n所以，事实上你确实需要使用不安全的代码来绕过 Borrow-Checker，但幸运的是标准库已经在其他更高类别的Cell的实现中帮我们处理了不安全的部分。在实际的开发中，我们很少会直接用到UnsafeCell，下面来 看看有哪些可用的Cell类型。\nCell Cell 通过使用拷贝替代借用的方式来避免内存别名。访问Cell内部的值将会返回一个副本，修改这个值需要将修改后的值传递给Cell。大多数Cells的方法都需要其内部的类型是可Copy的。 这种类型的Cell会有额外的拷贝开销，但是由于没有借用，也因此避免了由于避免借用造成的内存别名而造成的开销。这种类型的Cell适用于较小的基本类型。实际上，你可以在RefCell中看到Cell 被用于存放引用计数器。\nRefCell RefCell允许可变和不可变的借用一个内部值。它提供了两个方法来实现这个功能：\n1pub fn borrow(\u0026amp;self) -\u0026gt; Ref\u0026lt;\u0026#39;_, T\u0026gt; 2pub fn borrow_mut(\u0026amp;self) -\u0026gt; RefMut\u0026lt;\u0026#39;_, T\u0026gt; 这些函数返回一个借用内部值的包装，需要注意的是，即使返回的是可变的借用，函数的参数传递的依然是自身的不可变借用。 使用RefCell并没有给别名规则增加一些例外，而是仅仅绕过了 Borrow-Checker 的检查，最终这些内存别名的规则依然会得到 保证。\nRefCell通过引用计数的方式来遵循这些规则。从RefCell借用，将会触发引用计数的增加，反之会递减。如果程序在运行时 尝试以违反别名规则的方式借用，程序将会抛出异常。\nMutex Mutex虽然没有被列在cell模块中，但是它们的功能却是相似的，其内部也使用到了UnsafeCell。 Mutex没有自己维护引用计数，而是是用了底层的同步机制（例如：POSIX Mutex）来确定是否可以借用该值或者阻塞。 我们还可以增加其他类似的同步原语，例如RwLock，它允许跨线程的可变借用。\n使用 在 Rust 中，你必须为你的程序使用正确的工具组合，否则代码都编译不过。如果你想使用共享所有权，在单线程中，可以使用Rc， 编译器会阻止你将Rcs拷贝到别的线程。如果是多线程，就必须使用Arc。Rc和Arc都实现了Borrow，它允许不可变的借用， 但在一般情况下，都不允许可变的借用。\n如果你需要修改共享对象，那么就要用到内部可变性。RefCell允许可变的借用，但是它内部的引用计数不是线程安全的。 它只会在验证借用规则不通过的时候通过抛出 panic，而不是通过同步线程来强制执行同步规则。例如使用Mutex或者RwLock 来保证同一个时刻只有一个线程可以拥有写访问权限。因此RefCell不能与Arc一起使用。\n下面的表格提供了一些常见的场景以及推荐选择使用哪种工具的指南。这些可能不一定适用于所有的场景，但是能够提供一定的参考：\nMutable Access Multi-Thread C++ Rust No No std::shared_ptr\u0026lt;const T\u0026gt; std::rc::Rc\u0026lt;T\u0026gt; Yes No std::shared_ptr\u0026lt;T\u0026gt; std::rc::Rc\u0026lt;std::cell::RefCell\u0026lt;T\u0026gt;\u0026gt; No Yes std::shared_ptr\u0026lt;const T\u0026gt; std::sync:Arc\u0026lt;T\u0026gt; Yes Yes std::shared_ptr\u0026lt;T\u0026gt; + sync std::sync::Arc\u0026lt;std::sync::Mutex\u0026lt;T\u0026gt;\u0026gt; ","date":"November 1, 2022","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/rust/2022-11-01-rust%E5%92%8Cc++%E5%AF%B9%E6%AF%94%E4%B9%8B%E5%8F%AF%E5%8F%98%E6%80%A7%E7%A7%BB%E5%8A%A8%E5%92%8C%E6%89%80%E6%9C%89%E6%9D%83/","series":[],"smallImg":"","tags":[{"title":"Rust","url":"/blog/tags/rust/"}],"timestamp":1667260800,"title":"Rust和C++: 可变性、移动和所有权"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"Programming","url":"/blog/categories/programming/"}],"content":"在C/C++中，我们经常会像下面的代码那样使用一个指向函数的指针，我们称之为函数指针：\n1// demo.c 2#include \u0026lt;stdio.h\u0026gt; 3 4int func(int a) { 5 return a + 1; 6} 7 8int main(int argc, char* argv[]) { 9 int (*f)(int) = func; 10 printf(\u0026#34;%p\\n\u0026#34;, f); 11 return 0; 12} 上面的例子中，我们定义了一个函数func，然后通过函数指针f指向func，接着使用print函数打印指针变量f指向 的地址。代码平淡无奇，接着我们编译代码，然后使用objdump -D demo来查看生成的二进制结构如下：\n10000000100003f34 \u0026lt;_func\u0026gt;: 2100003f34: ff 43 00 d1 sub\tsp, sp, #16 3100003f38: e0 0f 00 b9 str\tw0, [sp, #12] 4100003f3c: e8 0f 40 b9 ldr\tw8, [sp, #12] 5100003f40: 00 05 00 11 add\tw0, w8, #1 6100003f44: ff 43 00 91 add\tsp, sp, #16 7100003f48: c0 03 5f d6 ret 上述结果是我在arm64-apple-darwin21.6.0环境下，使用clang 14.0编译出来的结果，gcc编译的结果稍微有点区别，但是对于本文分析问题影响不大。\n正如我们所看到的，编译后的func函数位于0x102e0bf34地址，让我们记住这个地址，接着往后看。\n接下来我们来运行编译后的二进制文件，很显然它应该输出的是func函数在内存中的地址：\n1./demo 20x102e0bf34 你猜对了，只是尽管函数指针也是指针，它指向的是内存中的一段代码，而不是内存中的数据。\n通常情况下，函数指针作为回调是没有问题的，但是如果考虑到闭包的情况，我们发现函数指针就无能为力了。 因为闭包不仅是一个函数，而且还要能捕获相关的数据，由于函数指针仅仅是指向内存中的一段代码，并没有指向内存中的数据， 所以函数指针无法实现闭包的功能。如果要想实现，就需要做一些改进：\n1typedef void (*func) (void *); 2 3struct closure { 4 func f; 5 void *arg; 6}; 如上，我们定义了一个结构closure，其中包含了两部分，一个指针变量指向一个函数，一个变量保存参数。 也就是说，closure既包含了一段代码，也包含了运行该代码所需要的数据，或者称之为上下文环境，不管它叫什么，总之就是 运行函数所需要的数据。\n这其实就是C++中的std::function所实现的功能。\n在C++中，你无法单纯使用函数指针来指向对象的成员函数，原因就是函数指针无法捕获其上下文(指向对象的指针)。std::function所做的与我们上面定义的closure结构其实没有太多本质的区别。 使用std::function，我们不仅仅可以存储一段代码，还可以存放必要的执行上下文，然后在合适的时候基于该上下文进行函数调用。\n","date":"September 28, 2022","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/cpp/2022-09-28-%E4%B8%BA%E4%BB%80%E4%B9%88c++%E4%B8%AD%E6%9C%89%E4%BA%86%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%8D%B4%E8%BF%98%E9%9C%80%E8%A6%81stdfunction/","series":[],"smallImg":"","tags":[{"title":"C++","url":"/blog/tags/c++/"}],"timestamp":1664323200,"title":"为什么c++中有了函数指针却还需要std::function"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"Programming","url":"/blog/categories/programming/"}],"content":" std::list splice 简介 splice函数通过重新排列链表指针，将一个std::list中的节点转移到另一个std::list中。在元素的转移过程中不会触发元素的拷贝或者移动。因此，调用splice函数之后，元素现有的引用和迭代器都不会失效。\n下面是一个将listA中所有节点附加到listB的一个简单代码示例，转移的过程不会导致listA中元素的引用和迭代器失效:\n1// Note: c++17 required below. (For CTAD(Class template argument deducation)) 2std::list listA{1, 2, 3}; 3std::list listB{4, 5, 6}; 4 5auto it = listA.begin(); // Iterator to 1 6 7// Append listA to listB 8listB.splice(listB.end(), listA); 9 10// All listA elements transferred to listB 11std::cout \u0026lt;\u0026lt; listB.size() \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; listA.size() \u0026lt;\u0026lt; std::endl; // 6 0 12 13// Prints Below: 4 5 6 1 2 3 14for (auto i : listB) { 15 std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 16} 17std::cout \u0026lt;\u0026lt; std::endl; 18 19// Iterator still valid 20std::cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; std::endl; // 1 当然，我们也可以在不使用splice的情况下将一个 list 中的元素转移到另一个 list 中，但是需要将原 list 中的元素删除，并在目标 list 中插入新的元素。删除和新增元素对于较小的对象（例如 int）是可以接受的，但是对于较大的对象来说，由于需要调用拷贝/移动构造和析构函数，所以成本会很高。\nsplice函数有一些重载，用于传输所有节点、或者特定节点或者一系列节点。这些函数可以将节点从一个列表转移到另一个列表，或者修改节点在列表中的位置。除了将一系列节点（并非所有）从一个列表转移到另一个列表这一种情况，其他所有情况下splice函数的时间复杂度均为常数 O(1)。\nsplice 的另一个值得注意的特性是，我们可以将一个节点从列表的一个位置转移到该列表的另一个位置。而后面我们实现 LRU Cache 就是需要使用到这个特性。\n1std::list\u0026lt;std::string\u0026gt; strList{\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;}; 2// Transfers \u0026#34;C\u0026#34; to the front (before \u0026#34;A\u0026#34;) 3strList.splice(strList.begin(), strList, --strList.end()); 4// Prints below: C A B 5for (auto\u0026amp; str : strList) { 6 std::cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 7} LRU Cache Least Recently Used (LRU) Cache，最近最少使用缓存，是一种容量有限的缓存，它会丢弃最近最少使用的元素，以便在容量已满时为新的元素腾出空间。\n接下来我们将要创建一个通用的 KV LRU Cache，他可以添加 KV，也可以通过给定的 K 来检索，以及删除特定的元素。无论是添加元素，检索元素还是删除元素，这些操作的平均时间复杂度都应为常数 O(1)。\n设计 我们通常将缓存等同于哈希表+淘汰策略。虽然看上去有点简单粗暴，但是也不无道理。缓存的实现需要有一个能够加快检索的索引结构，在这里我们可以使用 hashmap 来作为键值对的索引，用于提升检索的时间复杂度。然而 LRU Cache 还有一个隐含的淘汰策略，那就是顺序，根据最近的使用情况来排列元素项，并进行相应的淘汰。 因此，我们将在这里使用两种数据结构来实现：链表和 hashmap。\n链表按照最近使用顺序存储键值对，hashmap 用来构建索引。\n最近使用的元素项是链表的第一个节点，最近最少使用的元素项是链表的最后一个节点。我们在列表前面添加一个新的元素项，如果缓存已满，则删除链表最后一个元素（淘汰最近最少访问的元素）。当一个元素被访问时，他会被转移到链表的前面。\n实现 我们分别使用std::list和std::unordered_map来作为链表和哈希表，实现 LRU Cache:\n1// Note: c++17 required. 2 3template\u0026lt;typename K, typename V, std::size_t Capacity\u0026gt; class LRUCache 4{ 5public: 6 // Assert that Max size is greater than 0 7 static_assert(Capacity \u0026gt; 0); 8 9 // Adds a \u0026lt;key, Val\u0026gt; item, Returns false if key already exists 10 bool put(const K\u0026amp; k, const V\u0026amp; v); 11 12 // Gets the value for a key. 13 // Returns empty std::optional if not found. 14 // The returned item becomes most-recently-used 15 std::optional\u0026lt;V\u0026gt; get(const K\u0026amp; k); 16 17 // Erases an item 18 void erase(const K\u0026amp; k); 19 20 // Utility function. 21 // Calls callback for each {key, value} 22 template\u0026lt;typename C\u0026gt; void forEach(const C\u0026amp; cb) const 23 { 24 for (auto\u0026amp; [k, v] : items) { 25 cb(k, v); 26 } 27 } 28 29private: 30 // std::list stores items (pair\u0026lt;K, V\u0026gt;) in most-recently-used to least-recently-used order 31 std::list\u0026lt;std::pair\u0026lt;K, V\u0026gt;\u0026gt; items; 32 33 // unordered_map acts as an index to the items store above. 34 std::unordered_map\u0026lt;K, typename std::list\u0026lt;std::pair\u0026lt;K, V\u0026gt;\u0026gt;::iterator\u0026gt; index; 35}; put方法用于添加一个键值对。为了简单起见，如果 key 已经存在了，那么他什么都不做，并返回 false。如果缓存已经满了，那么会删除列表中最后一项(LRU)。最后新的键值对总是被添加到列表的最前面，同时索引会更新：\n1template\u0026lt;typename K, typename V, std::size_t Capacity\u0026gt; 2bool LRUCache\u0026lt;K, V, Capacity\u0026gt;::put(const K\u0026amp; k, const V\u0026amp; v) 3{ 4 // Return false if the key already exists 5 if (index.count(k)) { 6 return false; 7 } 8 9 // Check if cache is full 10 if (items.size() == Capacity) { 11 // Delete the LRU item 12 index.erase(items.back().first); // Erase the last item key from the map 13 items.pop_back(); // Evict last item from the list 14 } 15 16 // Insert the new item at front of the list 17 items.emplace_front(k, v); 18 19 // Insert {Key-\u0026gt;item_iterator} in the map 20 index.emplace(k, items.begin()); 21 22 return true; 23} get方法返回给定键的值。这里使用了std::optional，他可以为一个值，也可以为空，这取决于是否找到该项。在返回找到的值之前，通过调用splice函数，将当前查询的项转移到列表的开始位置。这个splice操作具有恒定的时间复杂度，不设及到元素的拷贝或者移动：\n1template\u0026lt;typename K, typename V, std::size_t Capacity\u0026gt; 2std::optional\u0026lt;V\u0026gt; LRUCache\u0026lt;K, V, Capacity\u0026gt;::get(const K\u0026amp; k) 3{ 4 auto itr = index.find(k); 5 if (itr == index.end()) { 6 // empty std::optional 7 return {}; 8 } 9 10 // Use list splice to transfer this item to the first position, 11 // which makes the item most-recently-used. Iterators still stay valid 12 items.splice(items.begin(), items, itr-\u0026gt;second); 13 14 // Return the value in a std::optional 15 return itr-\u0026gt;second-\u0026gt;second; 16} erase方法是最简单的一个，只需要将找到的元素从链表和哈希表中删除即可：\n1template\u0026lt;typename K, typename V, std::size_t Capacity\u0026gt; 2void LRUCache\u0026lt;K, V, Capacity\u0026gt;::erase(const K\u0026amp; k) 3{ 4 auto itr = index.find(k); 5 if (itr == index.end()) { 6 return; 7 } 8 9 // Erase from the list 10 items.erase(itr-\u0026gt;second); 11 12 // Erase from the map 13 index.erase(itr); 14} 测试 我们使用下面的代码来对上面实现的LRUCache进行测试：\n1// Prints all items of an LRUCache in a line 2// Items are printed in MRU -\u0026gt; LRU order 3template\u0026lt;typename C\u0026gt; void printlnCache(const C\u0026amp; cache) 4{ 5 cache.forEach([](auto\u0026amp; k, auto\u0026amp; v) { std::cout \u0026lt;\u0026lt; k \u0026lt;\u0026lt; \u0026#34;=\u0026gt;\u0026#34; \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#34; \u0026#34;; }); 6 std::cout \u0026lt;\u0026lt; std::endl; 7} 8 9int main() 10{ 11 // City -\u0026gt; Population in millions (Max size 3) 12 LRUCache\u0026lt;std::string, double, 3\u0026gt; cache; 13 14 // Add 3 entries 15 cache.put(\u0026#34;London\u0026#34;, 8.4); 16 cache.put(\u0026#34;Toronto\u0026#34;, 2.5); 17 cache.put(\u0026#34;Sydney\u0026#34;, 5.2); 18 19 // Sydney=\u0026gt;5.2 Toronto=\u0026gt;2.5 London=\u0026gt;8.4 20 printlnCache(cache); 21 22 // Make \u0026#34;London\u0026#34; the most recently accessed 23 std::cout \u0026lt;\u0026lt; \u0026#34;London =\u0026gt;\u0026#34; \u0026lt;\u0026lt; cache.get(\u0026#34;London\u0026#34;).value_or(-1) \u0026lt;\u0026lt; std::endl; 24 25 // London=\u0026gt;8.4 Sydney=\u0026gt;5.2 Toronto=\u0026gt;2.5 26 printlnCache(cache); 27 28 // This would remove the LRU item (Toronto) 29 cache.put(\u0026#34;Tokyo\u0026#34;, 9.4); 30 31 // Tokyo=\u0026gt;9.4 London=\u0026gt;8.4 Sydney=\u0026gt;5.2 32 printlnCache(cache); 33 34 return 0; 35} 完整的实现和测试代码可以在godbolt上查看。\n总结 虽然列表的splice功能一直都存在，但是他在同一个列表中修改节点位置的特性通常会被大家所忽略。通过上述的 LRUCache 的实现，我们能够很好的加深对 list 的splice功能的理解和使用，在实际的开发中，灵活使用标准库中提供的方法，能够在简化我们代码的同时，提升程序的效率。要做到这一点就需要我们不断加深对标准库的学习和理解。\n","date":"May 15, 2022","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/cpp/2022-05-15-%E4%BD%BF%E7%94%A8stdlist%E7%9A%84splice%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0lru-cache/","series":[],"smallImg":"","tags":[{"title":"C++","url":"/blog/tags/c++/"},{"title":"C++11","url":"/blog/tags/c++11/"}],"timestamp":1652572800,"title":"使用std::list的splice方法实现LRU Cache"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"Programming","url":"/blog/categories/programming/"}],"content":" 关于 shared_ptr shared_ptr是一种共享所有权的智能指针，它允许我们安全地访问和管理对象的生命周期。shared_ptr的多个实例通过共享控制块结构来控制对象的生命周期。 控制块维护了引用计数(reference count)，弱引用计数(weak count)和其他必要的信息，通过这些信息，控制块能够确定一个对象在内存中是否可以被安全销毁。\n当使用原始指针构造或者初始化一个shared_ptr时，将会创建一个新的控制块。为了确保一个对象仅由一个共享的控制块管理，必须通过复制已存在的shared_ptr对象来创建一个新的shared_ptr实例，例如：\n1void good() 2{ 3 auto p{new int(10)}; // p is int* 4 // create additional shared_ptr from an existing shared_ptr 5 std::shared_ptr\u0026lt;int\u0026gt; sp1{p}; 6 // sp2 shares control block with sp1 7 auto sp2{sp1}; 8} 而使用指向已由shared_ptr管理的对象的原始指针来初始化另一个shared_ptr时，会创建一个新的控制块来管理该对象， 这样同一个对象就同时被多个控制块管理，这会导致 undefined behavior，例如：\n1void bad() 2{ 3 auto p{new int(10);}; 4 std::shared_ptr\u0026lt;int\u0026gt; sp1{p}; 5 std::shared_ptr\u0026lt;int\u0026gt; sp2{p}; // Undefined behavior! 6} 通过原始指针的方式实例化shared_ptr很容易产生同一个原始指针实例化多个shared_ptr这样的编码疏忽，从而造成严重后果。 因此尽量使用std::make_shared或者std::allocate_shared来降低出错的可能性。毕竟除非有人刻意为之，否则我们似乎很难遇到或写出这样的代码：\n1auto sp1 = std::make_shared\u0026lt;int\u0026gt;(); 2std::shared_ptr\u0026lt;int\u0026gt; sp2{sp1.get()}; 但是在某些情况下，shared_ptr管理的对象需要为自己获取shared_ptr，我会在后面的篇幅中重点讲解这种情况。 但是首先需要说明的是，类似于下面这样尝试从自身指针创建shared_ptr的方式是行不通的：\n1struct Egg 2{ 3 std::shared_ptr\u0026lt;Egg\u0026gt; get_self_ptr() 4 { 5 return std::shared_ptr\u0026lt;Egg\u0026gt;(this); 6 } 7}; 8 9void spam() 10{ 11 auto sp1 = std::make_shared\u0026lt;Egg\u0026gt;(); 12 auto sp2 = sp1-\u0026gt;get_self_ptr(); // undefined behavior 13 // sp1 and sp2 have two different control blocks managing same Egg 14} 为了解决这个问题，我们就需要用到std::enable_shared_from_this。public 继承std::enable_shared_from_this 的类可以通过调用shared_from_this()方法来获取自身的shared_ptr，下面是一个简单的例子：\n1struct Thing; 2void some_api(const std::shared_ptr\u0026lt;Thing\u0026gt;\u0026amp; tp); 3 4struct Thing : public std::enable_shared_from_this\u0026lt;Thing\u0026gt; 5{ 6 void method() 7 { 8 some_api(shared_from_this()); 9 } 10}; 11 12void foo() 13{ 14 auto sp = std::make_shared\u0026lt;Thing\u0026gt;(); 15 sp-\u0026gt;method(); 16} 为什么要从 this 创建 shared_ptr 让我们来看一个更有说服力的例子，在这面的例子中，shared_ptr管理的对象需要为自己获取一个shared_ptr。\n一个Processor类异步处理数据并将其保存到数据库。在接收数据时，Processor通过自定义执行器来异步处理数据：\n1class Executor 2{ 3public: 4 void execute(const std::function\u0026lt;void(void)\u0026gt;\u0026amp; task); 5 6private: 7 // ... 8}; 9 10class Processor 11{ 12public: 13 void process_data(const std::string\u0026amp; data); 14 15private: 16 void do_process_and_save(const std::string\u0026amp; data) { 17 // process data 18 // sava data to DB 19 } 20 21private: 22 Executor* executor_; 23}; Processor类从一个Client类接收数据，这个Client持有该Processor的一个shared_ptr实例：\n1class Client 2{ 3public: 4 void some_method() 5 { 6 processor_-\u0026gt;process_data(\u0026#34;xxxxxx\u0026#34;); 7 } 8 9private: 10 std::shared_ptr\u0026lt;Processor\u0026gt; processor_; 11} Executor是一个线程池，它封装了多个线程和一个任务队列，并从队列中执行不同的 task。\n在Processor::process_data中，我们需要将执行过程包装成 task 传递给Executor。在 task 中调用私有方法do_process_and_save， 该方法在将数据保存到数据库之前对数据进行处理。因此，构造 task 的时候，需要捕获对Processor对象本身的引用：\n1void Processor::process_data(const std::string\u0026amp; data) 2{ 3 executor_-\u0026gt;execute([this, data]() { 4 // ... 5 do_process_and_save(data); 6 }); 7} 但是，Client可以出于各种原因随时将shared_ptr丢弃或者重置为其他关联的Processor，这可能会破坏原来的Processor。 因此在执行排队的 lambda 之前或期间，捕获的this指针可能会失效。\n我们可以通过在 lambda 中捕获 this 对象的 shared_ptr 来避免上面的 undefined behavior 的发生。 只要排队的 lambda 持有一个Processor的shared_ptr，Processor就会保持正常的运行状态。然而，我们知道，单纯的像这样创建一个shared_ptr\u0026lt;Processor\u0026gt;(this)是行不通的。 我们需要一种机制，让一个shared_ptr管理对象以某种方式控制它的控制块，从而获取另一个自身的shared_ptr对象。而使用std::enable_shared_from_this就是为了达到了这个目的：\n1class Processor : public std::enable_shared_from_this 2{ 3 // ... 4}; 5 6void Processor::process_data(const std::string\u0026amp; data) 7{ 8 executor_-\u0026gt;execute([self = shared_from_this(), data]() { 9 // ... 10 self-\u0026gt;do_process_and_save(data); 11 }); 12} 为什么要使用 enable_shared_from_this 本质上，为一个已经被shared_ptr管理的指针对象创建额外的shared_ptr实例只能通过从可以访问控制块的 handle 生成。 该 handle 可以是一个shared_ptr，也可以是一个weak_ptr。如果一个对象有这个 handle，那么它就可以为自己创建额外的shared_ptr。 但是shared_ptr 是一个强引用，会影响受管理对象的生命周期。将shared_ptr保存到自身对象将会导致自身永远无法被释放，从而发生内存泄漏:\n1struct Immortal 2{ 3 std::shared_ptr\u0026lt;Immortal\u0026gt; self; 4}; 解决这个问题可以通过weak_ptr来实现。weak_ptr是一种弱引用，它不会影响受管理对象的生命周期，但是在需要时可以用来获取强引用。 如果一个对象持有自身的weak_ptr，那么在需要的时候，就可以获取自身的shared_ptr:\n1class Naive 2{ 3public: 4 static std::shared_ptr\u0026lt;Naive\u0026gt; create() 5 { 6 auto sp = std::shared_ptr\u0026lt;Naive\u0026gt;(new Naive); 7 sp-\u0026gt;weak_self_ = sp; 8 return sp; 9 } 10 11 auto async_method() 12 { 13 return std::async(std::launch::async, [self = weak_self_.lock()]() { 14 self-\u0026gt;do_something(); 15 }); 16 } 17 18 void do_something() 19 { 20 std::this_thread::sleep_for(std::chrono::seconds(1)); 21 } 22 23private: 24 Naive() {} 25 Naive(const Naive\u0026amp;) = delete; 26 const Naive\u0026amp; operator=(const Naive\u0026amp;) = delete; 27 std::weak_ptr\u0026lt;Naive\u0026gt; weak_self_; 28}; 29 30void test() 31{ 32 std::future\u0026lt;void\u0026gt; ft; 33 { 34 auto pn = Naive::create(); 35 ft = pn-\u0026gt;async_method(); 36 } 37 ft.get(); 38} 上面的实现不够完美，因为它有很多限制。我们需要确保在构造Naive类的时候初始化对自身的weak_ptr，因此Naive的构造必须仅通过静态工厂方法来进行约束。 这种解决方案对合理性需求施加了太多的限制，然而这个实现却为标准解决方案std::enable_shared_from_this创建了一个概念框架。\nstd::enable_shared_from_this 的内部实现 std::enable_shared_from_this的典型实现是一个只包含了weak_ptr\u0026lt;T\u0026gt;字段的类，通常这个字段叫做weak_this(clang 中为__weak_this_，gcc 中为_M_weak_this)：\n1template\u0026lt;class T\u0026gt; 2class enable_shared_from_this 3{ 4 mutable weak_ptr\u0026lt;T\u0026gt; weak_this; 5 6public: 7 shared_ptr\u0026lt;T\u0026gt; shared_from_this() 8 { 9 return shared_ptr\u0026lt;T\u0026gt;(weak_this); 10 } 11 12 // const overload 13 shared_ptr\u0026lt;const T\u0026gt; shared_from_this() const 14 { 15 return shared_ptr\u0026lt;const T\u0026gt;(weak_this); 16 } 17 18 // .. more methods and constructors.. 19 // there is weak_from_this() also since c++17 20 21 template \u0026lt;class U\u0026gt; friend class shared_ptr; 22}; std::enable_shared_from_this的核心代码就这么简单，而剩下的魔法代码在shared_ptr的构造函数中实现。 当shared_ptr用T*初始化的时候，如果T是从std::enable_shared_from_this\u0026lt;T\u0026gt; 继承来的，则shared_ptr构造函数会初始化weak_this。 只有当T从std::enable_shared_from_this 公开 继承的时候，才能在编译时使用 trait 类(std::enable_if和std::is_convertible)来启用weak_this的初始化代码。 因此，必须使用public继承std::enable_shared_from_this类，因为shared_ptr构造函数需要通过weak_this来进行初始化，如果不 public 继承，则会在运行时抛出bad_weak_ptr异常。\n关于std::enable_shared_from_this还有一些值得注意的细节：\nweak_ptr被声明为 mutable，因此它也可以被修改为 const 对象 shared_ptr被声明为友元类型，这样它就可以访问私有字段weak_this 下面是另一个简单的例子，用来描述这一切是如何联系在一起的。我们将初始化shared_ptr的代码故意分为两个步骤，以演示嵌入的weak_ptr的创建和初始化的两个阶段：\n1struct Article : public std::enable_shared_from_this\u0026lt;Article\u0026gt; 2{ 3}; 4 5void foo() 6{ 7 // step 1 8 // Enclosed \u0026#39;weak_this\u0026#39; is not associated with any control block. 9 auto pa = new Article; 10 11 // step 2 12 // Enclosed \u0026#39;weak_this\u0026#39; gets initialized with a control block 13 auto spa = std::shared_ptr\u0026lt;Article\u0026gt;(pa); 14} 关于 std::bad_weak_ptr 异常 调用shared_from_this方法有一个限制，就是只能在shared_ptr管理的对象内部调用。 从 c++17 开始，在不受shared_ptr管理的对象内部调用shared_from_this会触发std::bad_weak_ptr异常，而在 c++17 之前，这种操作是 undefined behavior。\n1struct Article : public std::enable_shared_from_this\u0026lt;Article\u0026gt; 2{ 3 void foo() 4 { 5 auto self = shared_from_this(); 6 // ... 7 } 8} 9 10void test() 11{ 12 auto pa = new Article; 13 pa-\u0026gt;foo(); // ! std::bad_weak_ptr 14} 当shared_from_this调用的时候，如果weak_ptr未初始化或者已过期，那么shared_ptr的构造函数就会抛出异常。\n另一个触发抛出std::bad_weak_ptr异常的情况是，当在构造函数中调用shared_from_this的时候，因为当前对象还没构造完，嵌入的weak_this尚未初始化而导致抛出异常。\n触发std::bad_weak_ptr异常的另一个非常微妙而且难以定位排查的情况是，一个类没有使用public继承std::enable_shared_from_this类并且调用了shared_from_this方法。 private 和 protected 继承都会阻止weak_this成员的初始化，这可能会在没有任何编译器警告的情况下被忽略。例如：\n1class Overlooked : std::enable_shared_from_this\u0026lt;Overlooked\u0026gt; 2{ 3public: 4 void foo() 5 { 6 // std::bad_weak_ptr 7 auto self = shared_from_this(); 8 } 9} 有些环境下会禁用或者避免抛出异常，对于这种情况，从 c++17 开始，就有了一种替代shared_from_this的方法。 c++17 将weak_from_this方法添加到std::enable_shared_from_this中，后者返回嵌入的weak_this的副本。 shared_ptr可以安全地从该weak_ptr中获取，而不会导致任何std::bad_weak_ptr异常的发生：\n1class Overlooked : std::enable_shared_from_this\u0026lt;Overlooked\u0026gt; 2{ 3public: 4 void foo() 5 { 6 if (auto self = weak_from_this().lock()) { 7 // ok, use self 8 } else { 9 // ... 10 } 11 } 12} ","date":"May 3, 2022","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/cpp/2022-05-03-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3enable_shared_from_this/","series":[],"smallImg":"","tags":[{"title":"C++11","url":"/blog/tags/c++11/"},{"title":"C++14","url":"/blog/tags/c++14/"},{"title":"C++17","url":"/blog/tags/c++17/"}],"timestamp":1651536000,"title":"深入理解 enable_shared_from_this"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"Programming","url":"/blog/categories/programming/"}],"content":" 前言 c++11 对智能指针做了很大的优化，废弃了 c++98 中的auto_ptr，引入了三种新的智能指针：unique_ptr，shared_ptr，weak_ptr。 本文将针对unique_ptr的一些使用技巧做一些整理和归纳。在正式开始之前，我们首先来回顾一下unique_ptr的特点：一个unique_ptr对象内包含一个原始指针，该unique_ptr对象负责管理原始指针的生命周期。 一个unique_ptr对象始终是其关联的原始指针的唯一拥有者。\n在了解了unique_ptr的特点之后，我们来具体看看日常开发中unique_ptr的一些使用场景和技巧。\n一些场景 本地对象指针 在开发中，我们经常会遇到或者写出类似于下面这样的逻辑：\n1void somefunc() { 2 Object obj = new Object; 3 // ... 4 if (/* event 1 */) { 5 delete obj; 6 return; 7 } 8 9 if (/* event 2 */) { 10 delete obj; 11 return; 12 } 13 delete obj; 14} 对于这样的代码，写起来很麻烦，看上去也及其丑陋。以前我们常用的一种优化手段就是使用goto，而在 c++11 之后，我们有了一种更加优雅简洁的方式，来对上面的代码进行优化，那就是使用unique_ptr:\n1void somefunc() { 2 std::unique_ptr\u0026lt;Object\u0026gt; obj = std::make_unique\u0026lt;Object\u0026gt;(); // need c++14 3 // ... 4 if (/* event 1 */) { 5 return; 6 } 7 8 if (/* event 2 */) { 9 return; 10 } 11} 只需要将本地指针对象用unique_ptr包装起来，后面无需关心指针释放的问题，整体逻辑看上去更加简洁。\n数组 在 c++中，数组的创建和释放是一个很容易出错的地方，因为尽管数组的创建跟其他对象的创建一样使用new操作符，但是数组的释放却不同于普通对象指针的释放，而是使用的delete[]:\n1int *a = new int[10]; 2// ... 3delete[] a; 而有了unique_ptr之后，情况就会变得非常简单：\n1auto a = std::make_unique\u0026lt;int[]\u0026gt;(10); 2// ... 工厂函数 通常工厂函数会创建对象，然后对对象做一些初始化操作，最后将对象返回给调用者，下面是一个简单的工厂函数的实现:\n1Object* factory() { 2 Object* o = new Object; 3 o-\u0026gt;init(); 4 return o; 5} 但是当调用者拿到返回的对象指针后尝尝会困惑自己是否拥有该对象的所有权，是否应该负责该对象的释放。\n解决这个问题的一个比较好的办法是，将构造好的对象包装成unique_ptr返回给调用者，这样相当于明确告诉调用方，把该对象和对象的所有权一起返回：\n1std::unique_ptr\u0026lt;Object\u0026gt; factory() { 2 auto o = std::make_unique\u0026lt;Object\u0026gt;(); 3 o-\u0026gt;init(); 4 return o; 5} 类成员和函数参数 当我们将一个指针做为类成员，或者作为函数参数的时候，由于指针本身的传递没有携带所有权的信息，所以在指针传递的中间环节，我们不知道自己是否拥有该对象的所有权，为了明确这一点，也可以使用unique_ptr做一层包装，明确所有权和对象一起传递。\n只使用指针 考虑下面这种 case，我们只想使用指针，而不需要其所有权，在这种情况下，c++核心指南建议直接传递T*。如果我们假设所有裸指针都是非所有传递的，那这样自然没什么问题。当然我们还有一种办法是通过传递const std::unique_ptr\u0026lt;T\u0026gt;\u0026amp;来实现。这种用法看起来很不可思议，然而在一些著名的开源项目中却真实的存在，例如： https://github.com/opencv/opencv/blob/68d15fc62edad980f1ffa15ee478438335f39cc3/modules/gapi/src/compiler/passes/transformations.cpp#L66\n1// Tries to substitute __single__ pattern with substitute in the given graph 2bool tryToSubstitute(ade::Graph\u0026amp; main, 3 const std::unique_ptr\u0026lt;ade::Graph\u0026gt;\u0026amp; patternG, 4 const cv::GComputation\u0026amp; substitute) 5{ 6 GModel::Graph gm(main); 7 8 // 1. find a pattern in main graph 9 auto match1 = findMatches(*patternG, gm); 10 if (!match1.ok()) { 11 return false; 12 } 13 14 // 2. build substitute graph inside the main graph 15 cv::gimpl::GModelBuilder builder(main); 16 auto expr = cv::util::get\u0026lt;cv::GComputation::Priv::Expr\u0026gt;(substitute.priv().m_shape); 17 const auto\u0026amp; proto_slots = builder.put(expr.m_ins, expr.m_outs); 18 Protocol substituteP; 19 std::tie(substituteP.inputs, substituteP.outputs, substituteP.in_nhs, substituteP.out_nhs) = 20 proto_slots; 21 22 const Protocol\u0026amp; patternP = GModel::Graph(*patternG).metadata().get\u0026lt;Protocol\u0026gt;(); 23 24 // 3. check that pattern and substitute are compatible 25 // FIXME: in theory, we should always have compatible pattern/substitute. if not, we\u0026#39;re in 26 // half-completed state where some transformations are already applied - what can we do 27 // to handle the situation better? -- use transactional API as in fuse_islands pass? 28 checkCompatibility(*patternG, gm, patternP, substituteP); 29 30 // 4. make substitution 31 performSubstitution(gm, patternP, substituteP, match1); 32 33 return true; 34} 在上面的函数中我们可以看到通过 const reference 的方式传递unique_ptr，在函数内部可以像T*那样直接使用，但是不能对指针本身做任何修改。\n更新指针 我们经常会对类似于下面的代码产生困惑：\n1void reset(T** pp) { 2 *pp = new T; 3} 4 5T* p = nullptr; 6reset(\u0026amp;p); 假如p已经被初始化过了，那调用reset(\u0026amp;p)在新建一个新的对象之前，还需要对原来的对象进行释放。\n如果我们将reset函数修改成下面这样：\n1void reset(std::unique_ptr\u0026lt;T\u0026gt;\u0026amp; pp) { 2 pp = std::make_unique\u0026lt;T\u0026gt;(); 3} 情况就变得非常容易了，我们通过传递 non-const reference 的unique_ptr来对指针进行修改，而且不必单独为非空指针做专门的释放操作。\n总结 使用unique_ptr的好处总结起来就是，在传递原始指针的同时，也传递了原始指针的所有权。这样使用者在使用指针的时候，不用对指针的所有权感到困惑以至于不清楚在使用完之后是否需要释放指针对象。\n参考文档 https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines ","date":"April 20, 2022","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/cpp/2022-04-20-c++%E4%B8%ADunique_ptr%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/","series":[],"smallImg":"","tags":[{"title":"C++","url":"/blog/tags/c++/"},{"title":"C++11","url":"/blog/tags/c++11/"},{"title":"C++14","url":"/blog/tags/c++14/"},{"title":"C++17","url":"/blog/tags/c++17/"}],"timestamp":1650412800,"title":"c++ 中 unique_ptr 的一些使用技巧"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"Programming","url":"/blog/categories/programming/"}],"content":" 什么是 Expression Templates Expression Templates 是一种 C++ 模板元编程技术，它通过在编译时构建按需执行的计算表达式，从而生成高效的代码。简单来说，通过 Expression Templates，我们可以实现惰性求值和消除因为中间结果而创建的临时变量。\n一个常规示例 我们构造了一个MyVector类，并且重载了MyVector的+和*操作符，实现两个MyVector中相同下标元素的+和*操作。 对于这样的需求我们很容易写出形如下面代码的一个简单的实现：\n1#include \u0026lt;cassert\u0026gt; 2#include \u0026lt;iostream\u0026gt; 3#include \u0026lt;vector\u0026gt; 4 5template\u0026lt;typename T\u0026gt; class MyVector 6{ 7public: 8 MyVector(const std::size_t n) 9 : vec_(n) 10 {} 11 MyVector(const std::size_t n, const T initvalues) 12 : vec_(n, initvalues) 13 {} 14 15 std::size_t size() const { return vec_.size(); } 16 17 T operator[](const std::size_t i) const 18 { 19 assert(i \u0026lt; size()); 20 return vec_[i]; 21 } 22 23 T\u0026amp; operator[](const std::size_t i) 24 { 25 assert(i \u0026lt; size()); 26 return vec_[i]; 27 } 28 29private: 30 std::vector\u0026lt;T\u0026gt; vec_; 31}; 32 33template\u0026lt;typename T\u0026gt; MyVector\u0026lt;T\u0026gt; operator+(const MyVector\u0026lt;T\u0026gt;\u0026amp; a, const MyVector\u0026lt;T\u0026gt;\u0026amp; b) 34{ 35 assert(a.size() == b.size()); 36 MyVector\u0026lt;T\u0026gt; result(a.size()); 37 for (std::size_t i = 0; i \u0026lt; a.size(); ++i) { 38 result[i] = a[i] + b[i]; 39 } 40 return result; 41} 42 43template\u0026lt;typename T\u0026gt; MyVector\u0026lt;T\u0026gt; operator*(const MyVector\u0026lt;T\u0026gt;\u0026amp; a, const MyVector\u0026lt;T\u0026gt;\u0026amp; b) 44{ 45 assert(a.size() == b.size()); 46 MyVector\u0026lt;T\u0026gt; result(a.size()); 47 for (std::size_t i = 0; i \u0026lt; a.size(); ++i) { 48 result[i] = a[i] * b[i]; 49 } 50 return result; 51} 52 53template\u0026lt;typename T\u0026gt; std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const MyVector\u0026lt;T\u0026gt;\u0026amp; vec) 54{ 55 std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 56 for (std::size_t i = 0; i \u0026lt; vec.size(); ++i) { 57 os \u0026lt;\u0026lt; vec[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; 58 } 59 os \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 60 return os; 61} 62 63int main(int argc, char* argv[]) 64{ 65 MyVector\u0026lt;double\u0026gt; x(10, 5.4); 66 MyVector\u0026lt;double\u0026gt; y(10, 10.3); 67 auto ret = x + x + y * y; 68 std::cout \u0026lt;\u0026lt; ret \u0026lt;\u0026lt; std::endl; 69 return 0; 70} 这个实现平淡无奇，相信每个人都能随手写出来。在godbolt上编译成汇编来分析：\n我们能发现，对于x + x + y * y这行代码，执行的过程为:\ntemp1 = x + x temp2 = y * y temp3 = temp1 + temp2 优化后的版本 在上面的版本中，虽然实现起来很简单，但是会造成一些额外的临时变量。是的，这是我们不能容忍的。于是我们需要探索出一个如下图所示的更好的实现：\n在这个优化的版本中，不需要为表达式result[i] = x[i] + x[i] + y[i] * y[i]创建临时变量，赋值操作会直接触发运算的执行。\n1#include \u0026lt;cassert\u0026gt; 2#include \u0026lt;iostream\u0026gt; 3#include \u0026lt;vector\u0026gt; 4 5template\u0026lt;typename T, typename Cont = std::vector\u0026lt;T\u0026gt;\u0026gt; class MyVector 6{ 7public: 8 MyVector(const std::size_t n) 9 : vec_(n) 10 {} 11 MyVector(const std::size_t n, const T initvalues) 12 : vec_(n, initvalues) 13 {} 14 15 MyVector(const Cont\u0026amp; other) 16 : vec_(other) 17 {} 18 19 template\u0026lt;typename T2, typename R2\u0026gt; MyVector\u0026amp; operator=(const MyVector\u0026lt;T2, R2\u0026gt;\u0026amp; other) 20 { 21 assert(size() == other.size()); 22 for (std::size_t i = 0; i \u0026lt; size(); ++i) vec_[i] = other[i]; 23 return *this; 24 } 25 26 std::size_t size() const { return vec_.size(); } 27 T operator[](const std::size_t i) const { return vec_[i]; } 28 T\u0026amp; operator[](const std::size_t i) { return vec_[i]; } 29 const Cont\u0026amp; data() const { return vec_; } 30 Cont\u0026amp; data() { return vec_; } 31 32private: 33 Cont vec_; 34}; 35 36template\u0026lt;typename T, typename Op1, typename Op2\u0026gt; class MyVectorAdd 37{ 38public: 39 MyVectorAdd(const Op1\u0026amp; a, const Op2\u0026amp; b) 40 : op1_(a) 41 , op2_(b) 42 {} 43 44 T operator[](const std::size_t i) const { return op1_[i] + op2_[i]; } 45 std::size_t size() const { return op1_.size(); } 46 47private: 48 const Op1\u0026amp; op1_; 49 const Op2\u0026amp; op2_; 50}; 51 52template\u0026lt;typename T, typename Op1, typename Op2\u0026gt; class MyVectorMul 53{ 54public: 55 MyVectorMul(const Op1\u0026amp; a, const Op2\u0026amp; b) 56 : op1_(a) 57 , op2_(b) 58 {} 59 60 T operator[](const std::size_t i) const { return op1_[i] * op2_[i]; } 61 std::size_t size() const { return op1_.size(); } 62 63private: 64 const Op1\u0026amp; op1_; 65 const Op2\u0026amp; op2_; 66}; 67 68template\u0026lt;typename T, typename R1, typename R2\u0026gt; 69MyVector\u0026lt;T, MyVectorAdd\u0026lt;T, R1, R2\u0026gt;\u0026gt; operator+(const MyVector\u0026lt;T, R1\u0026gt;\u0026amp; a, const MyVector\u0026lt;T, R2\u0026gt;\u0026amp; b) 70{ 71 return MyVector\u0026lt;T, MyVectorAdd\u0026lt;T, R1, R2\u0026gt;\u0026gt;(MyVectorAdd\u0026lt;T, R1, R2\u0026gt;(a.data(), b.data())); 72} 73 74template\u0026lt;typename T, typename R1, typename R2\u0026gt; 75MyVector\u0026lt;T, MyVectorMul\u0026lt;T, R1, R2\u0026gt;\u0026gt; operator*(const MyVector\u0026lt;T, R1\u0026gt;\u0026amp; a, const MyVector\u0026lt;T, R2\u0026gt;\u0026amp; b) 76{ 77 return MyVector\u0026lt;T, MyVectorMul\u0026lt;T, R1, R2\u0026gt;\u0026gt;(MyVectorMul\u0026lt;T, R1, R2\u0026gt;(a.data(), b.data())); 78} 79 80template\u0026lt;typename T\u0026gt; std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const MyVector\u0026lt;T\u0026gt;\u0026amp; vec) 81{ 82 os \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 83 for (std::size_t i = 0; i \u0026lt; vec.size(); ++i) os \u0026lt;\u0026lt; vec[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; 84 os \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 85 return os; 86} 87 88int main(int argc, char* argv[]) 89{ 90 MyVector\u0026lt;double\u0026gt; x(10, 5.4); 91 MyVector\u0026lt;double\u0026gt; y(10, 10.3); 92 MyVector\u0026lt;double\u0026gt; result(10); 93 result = x + x + y * y; 94 std::cout \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl; 95 return 0; 96} 对于这个实现，同样在godbold中进行分析：\n汇编代码片段中表达式虽然很长，但是仔细看还是能看清它的结构。下面是一个简化版的代码生成图，用来说明模板的生成过程：\n参考文档 https://www.modernescpp.com/index.php/avoiding-temporaries-with-expression-templates\n","date":"April 6, 2022","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/cpp/2022-04-06-expression-templates/","series":[],"smallImg":"","tags":[{"title":"C++","url":"/blog/tags/c++/"},{"title":"Template","url":"/blog/tags/template/"}],"timestamp":1649203200,"title":"Expression Templates"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"Programming","url":"/blog/categories/programming/"}],"content":" 动态多态 (Dynamic Polymorphism) 在 c++中为了实现多态，使用了一种动态绑定的技术，这个技术的核心就是虚函数表(virtual table)。下面就简单的说明一下基于虚表的动态绑定的原理，从而更好的与静态多态做比较。\n在 c++中，每个包含虚函数的类都有一个虚表。我们来看下面这个类：\n1// demo.cpp 2class A 3{ 4public: 5 virtual void vfunc1(); 6 virtual void vfunc2(); 7 void func1(); 8 void func2(); 9 10private: 11 int m_data1, m_data2; 12}; 我们可以借助编译器来查看上述类的对象布局：\n1# 使用llvm编译工具 2clang -Xclang -fdump-record-layouts -stdlib=libc++ -c demo.cpp # 查看对象布局 3clang -Xclang -fdump-vtable-layouts -stdlib=libc++ -c demo.cpp # 查看虚表布局 4 5# 使用gcc编译工具 6g++ -fdump-lang-class demo.cpp 这里为了便于分析，使用 clang 打印的结果来具体说明：\n1// clang -Xclang -fdump-record-layouts -stdlib=libc++ -c demo.cpp 2*** Dumping AST Record Layout 3 0 | class A 4 0 | (A vtable pointer) 5 8 | int m_data1 6 12 | int m_data2 7 | [sizeof=16, dsize=16, align=8, 8 | nvsize=16, nvalign=8] 9 10// clang -Xclang -fdump-vtable-layouts -stdlib=libc++ -c demo.cpp 11Original map 12Vtable for \u0026#39;A\u0026#39; (4 entries). 13 0 | offset_to_top (0) 14 1 | A RTTI 15 -- (A, 0) vtable address -- 16 2 | void A::vfunc1() 17 3 | void A::vfunc2() 18 19VTable indices for \u0026#39;A\u0026#39; (2 entries). 20 0 | void A::vfunc1() 21 1 | void A::vfunc2() 根据对象布局可以简单画出class A的对象布局图：\noffset_to_top(0)：表示这个虚表地址距离对象顶部地址的偏移量，这里是 0，表示该虚表位于对象最顶端 RTTI 指针：Run-Time Type Identification，通过运行时类型信息程序能够使用基类的指针或引用来检查这些指针或引用所指的对象的实际派生类型 RTTI 下面就是虚函数表指针真正指向的地址，存储了类里面所有的虚函数 花了这么大力气，来讲解了类的对象布局和虚表，其实是为了给接下来类的继承和动态多态的实现做铺垫。我们在上面类的基础上，写实现一个派生类：\n1class B : public A 2{ 3 void vfunc1() {} 4}; 然后再通过工具打印出类的对象布局：\n1// clang -Xclang -fdump-record-layouts -stdlib=libc++ -c demo.cpp 2*** Dumping AST Record Layout 3 0 | class A 4 0 | (A vtable pointer) 5 8 | int m_data1 6 12 | int m_data2 7 | [sizeof=16, dsize=16, align=8, 8 | nvsize=16, nvalign=8] 9 10*** Dumping AST Record Layout 11 0 | class B 12 0 | class A (primary base) 13 0 | (A vtable pointer) 14 8 | int m_data1 15 12 | int m_data2 16 | [sizeof=16, dsize=16, align=8, 17 | nvsize=16, nvalign=8] 18 19// clang -Xclang -fdump-vtable-layouts -stdlib=libc++ -c demo.cpp 20Original map 21 void B::vfunc1() -\u0026gt; void A::vfunc1() 22Vtable for \u0026#39;B\u0026#39; (4 entries). 23 0 | offset_to_top (0) 24 1 | B RTTI 25 -- (A, 0) vtable address -- 26 -- (B, 0) vtable address -- 27 2 | void B::vfunc1() 28 3 | void A::vfunc2() 29 30VTable indices for \u0026#39;B\u0026#39; (1 entries). 31 0 | void B::vfunc1() 32 33Original map 34 void B::vfunc1() -\u0026gt; void A::vfunc1() 35Vtable for \u0026#39;A\u0026#39; (4 entries). 36 0 | offset_to_top (0) 37 1 | A RTTI 38 -- (A, 0) vtable address -- 39 2 | void A::vfunc1() 40 3 | void A::vfunc2() 41 42VTable indices for \u0026#39;A\u0026#39; (2 entries). 43 0 | void A::vfunc1() 44 1 | void A::vfunc2() 从上面的对象布局可以看出，子类 B 由于继承了 A，也拥有了虚表，并且 B 的虚表地址和父类 A 的虚表地址是相同的。 同时 B 和 A 一样，都占 16 个字节，前 8 个字节保存虚表指针，两个虚函数指针各占 4 个字节。而不同的是，由于子类 B 覆盖了vfunc1，所以 B 的虚函数表中变成了void B::vfunc1()。\n基于上面的继承示例，我们可以很容易写出多态的代码 —— 父类引用指向子类对象：\n1A* b = new B; 2b-\u0026gt;vfunc1(); 3b-\u0026gt;vfunc2(); 用A类类型指向B类的对象，在调用的时候，会根据b的 RTTI 来获取b的实际类型为B，然后调用vfunc1和vfunc2的时候会通过B的虚表指针来找到vfunc1和vfunc2的具体位置。 因此，采用此类多态的调用，会增加一些额外的开销:\n原因 时间开销 空间开销 RTTI 几次整形比较和一次取址操作（可能还会有 1、2 次整形加法） 每个类多出一个 type_info 对象（包括类型 ID 和类名称） 虚函数 一次整形加法和一次指针间接引用 每个类一个虚表，每个对象一个（通常情况下是一个）虚表指针，每个虚表指针占 8 字节 静态多态 (Static Polymorphism) 所谓静态多态，就是在程序在编译期就确定了对象类型和调用的函数地址，并生成对应的代码。 而 C++中常用来实现静态多态的方式就是 Curiously recurring template pattern 简称 CRTP。 CRTP 是 c++模板编程中的惯用模式，其主要特点是把派生类作为基类的模板参数。 翻译成代码就是:\n1template\u0026lt;class T\u0026gt; 2class Base 3{ 4 // methods within Base can use template to access members of Derived 5}; 6class Derived : public Base\u0026lt;Derived\u0026gt; 7{ 8 // ... 9}; 下面我们通过一段代码来分析如何使用 CRTP 实现静态多态：\n1#include \u0026lt;iostream\u0026gt; 2 3template\u0026lt;typename Derived\u0026gt; struct Base 4{ 5 void interface() 6 { 7 static_cast\u0026lt;Derived*\u0026gt;(this)-\u0026gt;implementation(); 8 } 9 void implementation() 10 { 11 std::cout \u0026lt;\u0026lt; \u0026#34;Implementation Base\u0026#34; \u0026lt;\u0026lt; std::endl; 12 } 13}; 14 15struct Derived1 : Base\u0026lt;Derived1\u0026gt; 16{ 17 void implementation() { std::cout \u0026lt;\u0026lt; \u0026#34;Implementation Derived1\u0026#34; \u0026lt;\u0026lt; std::endl; } 18}; 19 20struct Derived2 : Base\u0026lt;Derived2\u0026gt; 21{ 22 void implementation() { std::cout \u0026lt;\u0026lt; \u0026#34;Implementation Derived2\u0026#34; \u0026lt;\u0026lt; std::endl; } 23}; 24 25struct Derived3 : Base\u0026lt;Derived3\u0026gt; 26{}; 27 28template\u0026lt;typename T\u0026gt; 29void execute(T\u0026amp; base) 30{ 31 base.interface(); 32} 33 34int main() 35{ 36 Derived1 d1; 37 execute(d1); 38 Derived2 d2; 39 execute(d2); 40 Derived3 d3; 41 execute(d3); 42 std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 43} 程序运行的结果是：\n1Implementation Derived1 2Implementation Derived2 3Implementation Base 这里通过execute模板函数来执行静态多态，调用参数base的interface方法。Base::interface方法是 CRTP 机制的关键， 它通过static_cast\u0026lt;Derived*\u0026gt;(this)-\u0026gt;implementation()来调用子类的implementation方法。由于Derived1和Derived2都 实现了自己的implementation方法，所以这里使用的是他们实现，而Derived3没有实现自己的implementation方法，所以 Base::implementation就充当了默认实现。这个例子没有使用任何虚函数，就实现了多态的效果。同样地，使用编译器打印对象布局：\n1*** Dumping AST Record Layout 2 0 | struct Base\u0026lt;struct Derived1\u0026gt; (empty) 3 | [sizeof=1, dsize=1, align=1, 4 | nvsize=1, nvalign=1] 5 6*** Dumping AST Record Layout 7 0 | struct Derived1 (empty) 8 0 | struct Base\u0026lt;struct Derived1\u0026gt; (base) (empty) 9 | [sizeof=1, dsize=1, align=1, 10 | nvsize=1, nvalign=1] 11 12*** Dumping AST Record Layout 13 0 | struct Base\u0026lt;struct Derived2\u0026gt; (empty) 14 | [sizeof=1, dsize=1, align=1, 15 | nvsize=1, nvalign=1] 16 17*** Dumping AST Record Layout 18 0 | struct Derived2 (empty) 19 0 | struct Base\u0026lt;struct Derived2\u0026gt; (base) (empty) 20 | [sizeof=1, dsize=1, align=1, 21 | nvsize=1, nvalign=1] 22 23*** Dumping AST Record Layout 24 0 | struct Base\u0026lt;struct Derived3\u0026gt; (empty) 25 | [sizeof=1, dsize=1, align=1, 26 | nvsize=1, nvalign=1] 27 28*** Dumping AST Record Layout 29 0 | struct Derived3 (empty) 30 0 | struct Base\u0026lt;struct Derived3\u0026gt; (base) (empty) 31 | [sizeof=1, dsize=1, align=1, 32 | nvsize=1, nvalign=1] 我们不难发现，对象中不包含任何虚表。\n动态多态和静态多态的对比 动态多态发生在运行时，而静态多态发生在编译时。动态多态通常在运行时需要一个指针间接寻址，因此会有额外的性能开销，而静态多态的对象类型和函数是在编译时确定的，因此不会产生额外的性能开销。同时静态多态也不需要为每个类创建虚表，因此在空间上也不会像动态多态那样产生额外的消耗。\n","date":"March 23, 2022","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/cpp/2022-03-23-c++%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81%E5%92%8C%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81/","series":[],"smallImg":"","tags":[{"title":"C++","url":"/blog/tags/c++/"}],"timestamp":1647993600,"title":"c++中的动态多态和静态多态"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"Programming","url":"/blog/categories/programming/"}],"content":"constexpr 是 c++11 引入的关键字，用于编译时常量和常量表达式。而 c++17 将这一特性做了增强，引入了 constexpr if ， 使得编译器在编译时(compile time)能够做分支判断，从而有条件的编译代码。\n下面可以通过一个简单的例子来看看constexpr if的用法：\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026lt;type_traits\u0026gt; 3 4template\u0026lt;typename T\u0026gt; auto getValue(T t) 5{ 6 if constexpr (std::is_pointer\u0026lt;T\u0026gt;::value) { 7 return *t; 8 } else { 9 return t; 10 } 11} 12 13int main(int argc, char* argv[]) 14{ 15 int a = 10; 16 int* b = \u0026amp;a; 17 getValue(a); 18 getValue(b); 19 return 0; 20} 其实和普通的条件判断区别不大，只不过constexpr if中的条件是常量表达式，可以在编译时确定条件表达式的结果，从而选择编译对应的分支代码。 我们可以将上述代码编译成汇编来进一步分析：\n1auto getValue\u0026lt;int\u0026gt;(int): 2 push rbp 3 mov rbp, rsp 4 mov DWORD PTR [rbp-4], edi 5 mov eax, DWORD PTR [rbp-4] 6 pop rbp 7 ret 8auto getValue\u0026lt;int*\u0026gt;(int*): 9 push rbp 10 mov rbp, rsp 11 mov QWORD PTR [rbp-8], rdi 12 mov rax, QWORD PTR [rbp-8] 13 mov eax, DWORD PTR [rax] 14 pop rbp 15 ret 16...... 这里可以看到，生成的getValue\u0026lt;int\u0026gt;和getValue\u0026lt;int*\u0026gt;两个版本的函数分别保留了对应类型的分支逻辑，而没有了条件判断。\n至此我们对constexpr if的用法有了初步的认知，下面来通过元编程来加深对其的理解。\nconstexpr if 在元编程中的应用 说到元编程，我们就从元编程的\u0026quot;hello world\u0026quot;程序——计算阶乘开始，我们先写出一个不使用constexpr if的阶乘：\n1#include \u0026lt;iostream\u0026gt; 2 3template\u0026lt;int N\u0026gt; struct Factorial 4{ 5 static constexpr int value = N * Factorial\u0026lt;N - 1\u0026gt;::value; 6}; 7 8template\u0026lt;\u0026gt; struct Factorial\u0026lt;1\u0026gt; 9{ 10 static constexpr int value = 1; 11}; 12 13template\u0026lt;int N\u0026gt; inline constexpr int Factorial_v = Factorial\u0026lt;N\u0026gt;::value; 14 15int main(int argc, char* argv[]) 16{ 17 std::cout \u0026lt;\u0026lt; Factorial_v\u0026lt;1\u0026gt; \u0026lt;\u0026lt; std::endl; 18 std::cout \u0026lt;\u0026lt; Factorial_v\u0026lt;2\u0026gt; \u0026lt;\u0026lt; std::endl; 19 std::cout \u0026lt;\u0026lt; Factorial_v\u0026lt;3\u0026gt; \u0026lt;\u0026lt; std::endl; 20 std::cout \u0026lt;\u0026lt; Factorial_v\u0026lt;4\u0026gt; \u0026lt;\u0026lt; std::endl; 21 return 0; 22} 这段代码非常简单，没什么可解释的，这里之所以拿出来是为了将其使用constexpr if进行重写：\n1#include \u0026lt;iostream\u0026gt; 2 3template\u0026lt;int N\u0026gt; constexpr int factorial() 4{ 5 if constexpr (N \u0026gt;= 2) { 6 return N * factorial\u0026lt;N - 1\u0026gt;(); 7 } else { 8 return N; 9 } 10} 11 12int main(int argc, char* argv[]) 13{ 14 std::cout \u0026lt;\u0026lt; factorial\u0026lt;1\u0026gt;() \u0026lt;\u0026lt; std::endl; 15 std::cout \u0026lt;\u0026lt; factorial\u0026lt;2\u0026gt;() \u0026lt;\u0026lt; std::endl; 16 std::cout \u0026lt;\u0026lt; factorial\u0026lt;3\u0026gt;() \u0026lt;\u0026lt; std::endl; 17 std::cout \u0026lt;\u0026lt; factorial\u0026lt;4\u0026gt;() \u0026lt;\u0026lt; std::endl; 18 return 0; 19} 通过上面的改写，可以很容易发现，在不使用constexpr if的时候，我们需要额外的对Factorial模板类做特例化，来定义递归的结束位置。而有了constexpr if我们可以像写正常的函数那样写出能具有常量特性的函数，在编译期计算阶乘。\n同样地，我们也可以很容易将fibonacci函数改造成constexpr if版本，这里就不再赘述了。\n","date":"March 18, 2022","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/cpp/2022-03-18-c++17-constexpr_if/","series":[],"smallImg":"","tags":[{"title":"C++","url":"/blog/tags/c++/"},{"title":"C++17","url":"/blog/tags/c++17/"}],"timestamp":1647561600,"title":"c++17:constexpr if"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"Programming","url":"/blog/categories/programming/"}],"content":"对于熟悉 c99 的人来说，Designated Initializers 并不算是什么新鲜事物，然而 c++直到 c++20 才正式支持这一特性。 虽然在 c++20 之前，像 GCC 这样的编译器通过扩展的形式已经对该特性做了支持，但是随着 c++20 将其纳入新标准，这一特性将在所有编译器中得到支持。\n基本用法 Designated Initialization 是聚合初始化(Aggregate Initialization)的一种形式。 在 c++20 中，聚合类型(Aggregate types)是指：\n数组类型 具备如下特性的 class 类型： has no private or protected direct non-static data members has no user-declared or inherited constructors has no virtual, private, or protected base classes has no virtual member functions c++20 中的 Designated Initializers 的用法跟 c99 非常相似：\n1struct Points 2{ 3 double x{0.0}; 4 double y{0.0}; 5}; 6 7const Points p{.x = 1.1, .y = 2.2}; 8const Points o{.x{1.1}, .y{2.2}}; 9const Points x{.x = 1.1, .y{2.2}}; 优点 使用 Designated Initializers 最大的好处就是能够提升代码的可读性。\n我们考拿下面的例子来说，首先声明一个struct Date，其中有三个int类型的成员变量，分别代表了年、月、日。\n1struct Date 2{ 3 int year; 4 int mon; 5 int day; 6} 如果没有 Designated Initializers，我们对它进行初始化通常会这样做：\n1Date someday {2022, 3, 15}; 而使用 Designated Initializers：\n1Date someday { .year = 2022, .mon = 3, .day = 15 }; 很显然，使用 Designated Initializers 能让人一目了然，知道每个数字的含义，而不使用的话，必须要回过头去看Date结构的定义才能确定这几个数字代表啥意思。\n使用规则 c++20 中的 Designated Initializers 遵循一下规则：\n只能用于聚合类型初始化(aggregate initialization) Designators 只能是非静态类型的成员 Designators 的顺序应该跟成员声明时的顺序保持一致 并不是所有成员都要指定，可以跳过一些成员 普通的初始化和 Designated Initializers 不能混用 Designators 不支持嵌套，例如 .x.y = 10 是不允许的 下面是一些代码示例：\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026lt;string\u0026gt; 3 4struct Product 5{ 6 std::string name_; 7 bool inStock_{false}; 8 double price_ = 0.0; 9}; 10 11void Print(const Product\u0026amp; p) 12{ 13 std::cout \u0026lt;\u0026lt; \u0026#34;name: \u0026#34; \u0026lt;\u0026lt; p.name_ \u0026lt;\u0026lt; \u0026#34;, in stock: \u0026#34; \u0026lt;\u0026lt; std::boolalpha \u0026lt;\u0026lt; p.inStock_ 14 \u0026lt;\u0026lt; \u0026#34;, price: \u0026#34; \u0026lt;\u0026lt; p.price_ \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 15} 16 17struct Time 18{ 19 int hour; 20 int minute; 21}; 22struct Date 23{ 24 Time t; 25 int year; 26 int month; 27 int day; 28}; 29 30int main() 31{ 32 Product p{.name_ = \u0026#34;box\u0026#34;, .inStock_{true}}; 33 Print(p); 34 35 Date d{.t{.hour = 10, .minute = 35}, .year = 2050, .month = 5, .day = 10}; 36 37 // pass to a function: 38 Print({.name_ = \u0026#34;tv\u0026#34;, .inStock_{true}, .price_{100.0}}); 39 40 // not all members used: 41 Print({.name_ = \u0026#34;car\u0026#34;, .price_{2000.0}}); 42} ","date":"March 15, 2022","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/cpp/2022-03-15-c++20-designated_initializers/","series":[],"smallImg":"","tags":[{"title":"C++","url":"/blog/tags/c++/"},{"title":"C++20","url":"/blog/tags/c++20/"}],"timestamp":1647302400,"title":"c++20:Designated Initializers"},{"authors":[],"categories":[{"title":"Programming","url":"/blog/categories/programming/"}],"content":" 前言 做存储开发，一定会经常涉及到 IO 相关的操作。而现在的高级编程语言，往往会帮助我们屏蔽 IO 操作的底层细节，虽然这样能降低开发门槛，提升效率，但是却也导致我们对 IO 底层操作实现的理解不够系统和深入。 所以呢，我一直想抽时间来系统整理一下 Linux IO 涉及的系统调用，以及相互之间的区别和联系，以加深对 IO 操作的理解。\nIO 操作 fwrite fwrite 是 c 语言标准库中的文件写入函数，其作用是向指定的文件中写入若干数据。调用 fwrite 实际上是将数据写入到了 c 标准库的 IO Buffer 中。\nmmap mmap 将一个文件或者其它对象映射进内存。文件被映射到多个页上，如果文件的大小不是所有页的大小之和，最后一个页不被使用的空间将会清零。mmap 在用户空间映射调用系统中作用很大。\nfflush fflush 就是将 c 标准库中的 IO Buffer 中的数据写入到参数 stream 指定的文件中。\nfsync fsync 系统调用就是将内核缓冲区中的数据同步到存储介质(如硬盘)。也可以在 open 文件的时候通过开启O_SYNC来开启同步 I/O.\n各 IO 操作的区别与联系 图片引用自 https://oscimg.oschina.net/oscnet/51a17cc9aa34eba47971af609fdecabf398.jpg 上图非常清晰的展示了 Linux IO 操作相互之间的区别和联系。\nfwrite 写入的数据会先存放到 c 标准库的 IO Buffer 中，可以通过 fflush 将其写入到内核的 Page Buffer 中。也就是说即使 fwrite 写成功，程序崩溃了数据仍然可能会丢失。 fflush 就是将程序 IO Buffer 中的数据写入到内核的 Page Buffer，此时应用程序的崩溃不会导致数据丢失，但是如果内核崩溃的话，仍然可能会造成数据丢失。 通过 mmap 映射的文件，数据直接写入到内核的 Page Buffer 中。 fsync 可以将内核 Page Buffer 中的数据写入到存储介质的 Disk Cache 中。 参考资料 Linux 中如何保证数据安全落盘\n","date":"February 25, 2022","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/linux/2022-02-25-linux%E7%A3%81%E7%9B%98io/","series":[],"smallImg":"","tags":[{"title":"Linux","url":"/blog/tags/linux/"},{"title":"IO","url":"/blog/tags/io/"}],"timestamp":1645747200,"title":"Linux磁盘IO"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"Programming","url":"/blog/categories/programming/"}],"content":"对于一个标准的 c++容器来说，我们可以很容易在运行时使用迭代器和 range-based for loop 来遍历其中的每一个元素。但是对于std::tuple，却不能像普通的容器那样去遍历它。\nstd::tuple 简介 std::tuple是一个具有固定大小，包含不同类型值的集和。与之相似的是std::pair，只不过std::pair只能容纳两个元素， 而std::tuple可以容纳许多元素：\n1std::tuple\u0026lt;int, double, const char*\u0026gt; tup {42, 10.5, \u0026#34;hello\u0026#34;}; 2 3// or with CTAD(class template argument deduction), C++17: 4std::tuple deducedTup {42, 10.5, \u0026#34;hello\u0026#34;}; // 自动推导类型 访问std::pair中的元素只需要访问.first和.second成员即可:\n1std::pair p = {10, 10.5}; 2p.first += 10; 然而std::tuple并没有类似于.first .second的成员，标准库中我们只能通过std::get来直接访问其中的元素:\n1std::tuple tp {1, 2, \u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;, 10.5}; 2 3// by index 4std::get\u0026lt;0\u0026gt;(tp) += 10; 5std::get\u0026lt;1\u0026gt;(tp) *= 20; 6std::cout \u0026lt;\u0026lt; std::get\u0026lt;2\u0026gt;(tp) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // hello 7std::cout \u0026lt;\u0026lt; std::get\u0026lt;3\u0026gt;(tp) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // world 8 9// by type 10std::cout \u0026lt;\u0026lt; std::get\u0026lt;double\u0026gt;(tp) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 10.5 如何遍历 tuple 对 tuple 有了初步的了解，也知道了如何去获取 tuple 中的元素，那么接下来我们就来一步步构造对 tuple 遍历的方法。\n准备工作 首先我们来编写下面这样一段代码，通过向模板中传递一系列想要访问的元素下标，来完成对tuple的遍历：\n1template\u0026lt;typename T\u0026gt; void print(const T\u0026amp; t) 2{ 3 std::cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0026#39;,\u0026#39;; 4} 5 6template\u0026lt;typename TupleT, std::size_t... Is\u0026gt; void print_tuple(const TupleT\u0026amp; tp) 7{ 8 (print(std::get\u0026lt;Is\u0026gt;(tp)), ...); 9} 10 11int main(int argc, char* argv[]) 12{ 13 std::tuple tp{1, 2, \u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}; 14 print_tuple\u0026lt;decltype(tp), 0, 1, 2, 3\u0026gt;(tp); 15 return 0; 16} 代码比较简单，模板参数除了tuple类型以外，还需要传递一组\u0026quot;non-type\u0026quot;模板参数，也就是指定要访问的元素下标， 然后通过 c++17 的 fold expression 来展开调用print方法，打印对应下标的值。\n使用 index_sequence 优化 在上面的代码中，我们需要手动传递元素的下标，那么有没有一种更好的办法，让编译器自动为我们生成元素下标，从而简化调用呢？ 答案是可以的。在 c++14 中引入了std::index_sequence和std::make_index_sequence，这样的话我们的程序可以做以下优化：\n1template\u0026lt;typename T\u0026gt; void print(const T\u0026amp; t) 2{ 3 std::cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0026#39;,\u0026#39;; 4} 5 6template\u0026lt;typename TupleT, std::size_t... Is\u0026gt; 7void print_tuple(const TupleT\u0026amp; tp, std::index_sequence\u0026lt;Is...\u0026gt;) 8{ 9 (print(std::get\u0026lt;Is\u0026gt;(tp)), ...); 10} 11 12 13int main(int argc, char* argv[]) 14{ 15 std::tuple tp{1, 2, \u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}; 16 print_tuple(tp, std::make_index_sequence\u0026lt;4\u0026gt;()); 17 return 0; 18} 以上代码通过std::make_index_sequence和std::index_sequence在编译期自动生成了元素下标的\u0026quot;non-type\u0026quot;模板参数， 但是在调用的时候还需要手动传 tupe 的 size，因此我们使用std::tuple_size来继续对代码进行优化：\n1template\u0026lt;typename T\u0026gt; void print(const T\u0026amp; t) 2{ 3 std::cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0026#39;,\u0026#39;; 4} 5 6template\u0026lt;typename TupleT, std::size_t... Is\u0026gt; 7void print_tuple(const TupleT\u0026amp; tp, std::index_sequence\u0026lt;Is...\u0026gt;) 8{ 9 (print(std::get\u0026lt;Is\u0026gt;(tp)), ...); 10} 11 12 13int main(int argc, char* argv[]) 14{ 15 std::tuple tp{1, 2, \u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}; 16 print_tuple(tp, std::make_index_sequence\u0026lt;std::tupe_size_v\u0026lt;decltype(tp)\u0026gt;\u0026gt;()); 17 return 0; 18} 接下来我们再对代码进行一些封装，从而让我们的使用再简单一些：\n1template\u0026lt;typename T\u0026gt; void print(const T\u0026amp; t) 2{ 3 std::cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0026#39;,\u0026#39;; 4} 5 6template\u0026lt;typename TupleT, std::size_t... Is\u0026gt; 7void print_tuple_manual(const TupleT\u0026amp; tp, std::index_sequence\u0026lt;Is...\u0026gt;) 8{ 9 (print(std::get\u0026lt;Is\u0026gt;(tp)), ...); 10} 11 12template\u0026lt;typename TupleT, std::size_t tuple_size = std::tuple_size_v\u0026lt;TupleT\u0026gt;\u0026gt; 13void print_tuple(const TupleT\u0026amp; tp) 14{ 15 print_tuple_manual(tp, std::make_index_sequence\u0026lt;tuple_size\u0026gt;()); 16} 17 18int main(int argc, char* argv[]) 19{ 20 std::tuple tp{1, 2, \u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}; 21 print_tuple(tp); 22 return 0; 23} 打印 tuple 虽然我们已经能够简单的向print_tuple函数传递一个tuple实例来实现对tuple内元素的打印了，但是 我们还是希望对打印的格式进行一个优化，下面我们来为打印加上括号和下标：\n1template\u0026lt;typename TupleT, std::size_t... Is\u0026gt; 2void print_tuple_manual(const TupleT\u0026amp; tp, std::index_sequence\u0026lt;Is...\u0026gt;) 3{ 4 auto print = [](const auto\u0026amp; x, std::size_t idx) { 5 if (idx \u0026gt; 0) { 6 std::cout \u0026lt;\u0026lt; \u0026#34;, \u0026#34;; 7 } 8 std::cout \u0026lt;\u0026lt; idx \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; x; 9 }; 10 std::cout \u0026lt;\u0026lt; \u0026#39;(\u0026#39;; 11 (print(std::get\u0026lt;Is\u0026gt;(tp), Is), ...); 12 std::cout \u0026lt;\u0026lt; \u0026#39;)\u0026#39;; 13} 14 15template\u0026lt;typename TupleT, std::size_t tuple_size = std::tuple_size_v\u0026lt;TupleT\u0026gt;\u0026gt; 16void print_tuple(const TupleT\u0026amp; tp) 17{ 18 print_tuple_manual(tp, std::make_index_sequence\u0026lt;tuple_size\u0026gt;()); 19} 20 21int main(int argc, char* argv[]) 22{ 23 std::tuple tp{1, 2, \u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}; 24 print_tuple(tp); // (0: 1, 1: 2, 2: hello, 3: world) 25 return 0; 26} \\\u003c\\\u003c操作符 下面我们继续优化，为std::tuple实现\u0026lt;\u0026lt;操作符：\n1template\u0026lt;typename TupleT, std::size_t... Is\u0026gt; 2std::ostream\u0026amp; print_tuple_manual(std::ostream\u0026amp; os, const TupleT\u0026amp; tp, std::index_sequence\u0026lt;Is...\u0026gt;) 3{ 4 auto print = [\u0026amp;os](const auto\u0026amp; x, std::size_t idx) { 5 if (idx \u0026gt; 0) { 6 os \u0026lt;\u0026lt; \u0026#34;, \u0026#34;; 7 } 8 os \u0026lt;\u0026lt; idx \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; x; 9 }; 10 os \u0026lt;\u0026lt; \u0026#39;(\u0026#39;; 11 (print(std::get\u0026lt;Is\u0026gt;(tp), Is), ...); 12 os \u0026lt;\u0026lt; \u0026#39;)\u0026#39;; 13 return os; 14} 15 16template\u0026lt;typename TupleT, std::size_t tuple_size = std::tuple_size\u0026lt;TupleT\u0026gt;::value\u0026gt; 17std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const TupleT\u0026amp; tp) 18{ 19 return print_tuple_manual(os, tp, std::make_index_sequence\u0026lt;tuple_size\u0026gt;{}); 20} 21 22int main(int argc, char* argv[]) 23{ 24 std::tuple tp{1, 2, \u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}; 25 std::cout \u0026lt;\u0026lt; tp \u0026lt;\u0026lt; std::endl; // (0: 1, 1: 2, 2: hello, 3: world) 26 return 0; 27} ","date":"February 22, 2022","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/cpp/2022-02-22-c++%E5%85%83%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%8D%E5%8E%86tuple/","series":[],"smallImg":"","tags":[{"title":"C++","url":"/blog/tags/c++/"},{"title":"Template","url":"/blog/tags/template/"}],"timestamp":1645488000,"title":"c++元编程之遍历tuple"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"Programming","url":"/blog/categories/programming/"}],"content":" string_view 简介 std::string_view是 c++17 中新增的一种类型。其核心理念是，能够让我们在传统的 C++03 风格的具体性和泛型编程之间找到一个很好的折衷点。 在 C++17 标准之前，我们通常只能在粗糙的不严谨的模板实现和相对严谨但是有着冗长约束的模板之间做出选择。举个简单的例子：\n1// c++03 style 2class Widget 3{ 4 std::string name_; 5 6public: 7 void setName(const char* new_name); 8 void setName(const std::string\u0026amp; new_name); 9}; 10 11// 不正确的欠约束的模板 12class Widget 13{ 14 std::string name_; 15 16public: 17 template\u0026lt;class T\u0026gt; void setName(T\u0026amp;\u0026amp; new_name); 18}; 19 20// 正确的但是约束但滑稽冗长的模板 21class Widget 22{ 23 std::string name_; 24 25public: 26 template\u0026lt;class T, class = decltype(std::declval\u0026lt;std::string\u0026amp;\u0026gt;() = std::declval\u0026lt;T\u0026amp;\u0026amp;\u0026gt;()) \u0026gt;\u0026gt; 27 void setName(T\u0026amp;\u0026amp; new_name); 28}; 而有了 string_view 之后，以上代码就可以简化成如下：\n1class Widget 2{ 3private: 4 std::string name_; 5 6public: 7 void setName(std::string_view name) { name_ = name; } 8}; string_view 在替代const std::string\u0026amp;参数上取得了巨大的成功，但是有人坚持尝试在任何地方 使用std::string_view来替代const std::string\u0026amp;，这是不对的，例如下面的例子：\n1const std::string\u0026amp; s1 = \u0026#34;hello world\u0026#34;; // OK, lifetime-extended 2const std::string\u0026amp; s2 = std::string(\u0026#34;hello world\u0026#34;); // OK, lifetime-extended 3std::string_view sv1 = \u0026#34;hello world\u0026#34;; // OK, points to static array 4std::string_view sv2 = std::string(\u0026#34;hello world\u0026#34;); // BUG! Dangling pointer! 为了更加清楚的说明问题，这里用一个完整的示例来演示：\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026lt;string\u0026gt; 3#include \u0026lt;string_view\u0026gt; 4 5class Widget 6{ 7private: 8 std::string name_; 9 10public: 11 explicit Widget(std::string_view name) 12 : name_(name) 13 {} 14 void setName(std::string_view name) { name_ = name; } 15 std::string_view getName() const { return name_; } 16}; 17 18 19int main(int argc, char* argv[]) 20{ 21 Widget w(\u0026#34;ok\u0026#34;); 22 auto name = w.getName(); 23 w.setName(\u0026#34;hello\u0026#34;); 24 std::cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; std::endl; // BUG! heap use after free 25 return 0; 26} 当我们使用AddressSanitizer工具来编译运行的时候，会报出heap-use-after-free的错误。 这个例子中使用 string_view 作为返回类型，由于 string_view 只是创建了一个 string 的视图，它既不能对 string 进行修改，也没有明确的所有权。 当我们调用w.getName()，返回的只是 w::name_ 的一个视图，当我们调用w.setName(\u0026quot;hello\u0026quot;);后， w::name_替换成一个新构造的 string 对象， 由于name只是w::name_原来 string 对象的一个视图，它并不能延长原 string 对象的生命周期，因此原来的 string 对象被释放。当我们再使用name 变量的时候，就会出现问题。\n传值还是引用 先说结论：按值传递 string_view 是通用的方式。下面来具体分析原因。\n在 C++ 中，所有的值默认都是通过值传递，当我们使用Widget w的时候，实际上我们得到的是一个全新的对象。 但是对于大内存的拷贝是很昂贵的操作，因此当我们传递一些像std::string这样的很大的对象的时候，需要使用引用传递的方式来对按值传递进行优化。 而对于像int, char *, std::pair\u0026lt;int, int\u0026gt;, std::span\u0026lt;Widget\u0026gt;这样的轻量对象，我们依然更加倾向于使用默认的按值传递的方式。\n对于string_view而言，按值传递比按引用传递有三个方面的性能优势：\n1. 消除了被调用方的间接指针\npass-by-const-reference 意味着传递的是对象的地址，而 pass-by-value 意味着传递的是对象本身。 对于 int, span, string_view 这样的 trivial types 来说，它们会直接保存在寄存器上。 我们可以通过一个例子来具具体说明一下区别：\n1// test_string_view.cpp 2#include \u0026lt;string_view\u0026gt; 3 4int byvalue(std::string_view sv) 5{ 6 return sv.size(); 7} 8 9int byref(const std::string_view\u0026amp; sv) 10{ 11 return sv.size(); 12} 将上面的代码编译成汇编代码：\n1# gcc 11.2 2# g++ -std=c++20 -O1 test_string_view.cpp -o test_string_view.s 3byvalue(std::basic_string_view\u0026lt;char, std::char_traits\u0026lt;char\u0026gt; \u0026gt;): 4 movl %edi, %eax 5 ret 6 7byref(std::basic_string_view\u0026lt;char, std::char_traits\u0026lt;char\u0026gt; \u0026gt; const\u0026amp;): 8 movl (%rdi), %eax 9 ret 通过上面的汇编代码，可以很清晰的看到，按值传递的时候是将 string_view 直接在寄存器之间传递， 而按引用传递，则是需要先将 size 成员通过引用的地址和偏移 load 到内存中，然后再传递给寄存器。\n2. 在调用的时候，能消除一次栈帧溢出\n当我们通过引用传递的时候，调用者需要将对象的地址放入寄存器，所以对象一定要有地址。 即使调用者的其他所有对象都可以直接通过寄存器来保存，但是传递对象地址的行为也会迫使调用者将其溢出到堆栈中。 而按值传递消除了溢出参数的必要，在一些极端情况下意味着此次调用根本不需要调用程序中的栈帧。\n下面同样通过一个例子来更加具体的说明：\n1#include \u0026lt;string_view\u0026gt; 2 3int byvalue(std::string_view sv) 4{ 5 return sv.size(); 6} 7 8int byref(const std::string_view\u0026amp; sv) 9{ 10 return sv.size(); 11} 12 13 14void callbyvalue(std::string_view sv) 15{ 16 byvalue(\u0026#34;hello\u0026#34;); 17} 18 19void callbyref(std::string_view sv) 20{ 21 byref(\u0026#34;hello\u0026#34;); 22} 同样的编译成汇编代码：\n1# gcc 11.2 2.LC0: 3 .string \u0026#34;hello\u0026#34; 4callbyvalue(std::basic_string_view\u0026lt;char, std::char_traits\u0026lt;char\u0026gt; \u0026gt;): 5 movl $5, %edi 6 movl $.LC0, %esi 7 jmp byvalue(std::basic_string_view\u0026lt;char, std::char_traits\u0026lt;char\u0026gt; \u0026gt;) 8callbyref(std::basic_string_view\u0026lt;char, std::char_traits\u0026lt;char\u0026gt; \u0026gt;): 9 subq $24, %rsp // 分配堆栈空间 10 movq %rsp, %rdi 11 movq $5, (%rsp) 12 movq $.LC0, 8(%rsp) 13 call byref(std::basic_string_view\u0026lt;char, std::char_traits\u0026lt;char\u0026gt; \u0026gt; const\u0026amp;) 14 addq $24, %rsp // 清理堆栈空间 15 ret 在 callbyvalue 中，只需要在寄存器中设置好 string_view 的数据指针和大小就直接调用 byvalue 了。而在 callbyref 中，需要使用 string_view 参数的地址，所以首先在堆栈上分配空间，当调用 byref 返回的时候，需要清理之前分配好的堆栈空间。\n3. 对编译器优化更加友好\n当我们传递引用的时候，我们给被调用的函数一个它们一无所知的对象引用，被调用方不知道还有谁持有这个对象的引用， 也不知道自己的指针是否指向该对象或该对象的一部分。因此编译器在做优化的时候必须非常保守。 而当我们按值传递的时候，我们给被调用函数一个全新的副本，一个绝对不会与程序中其他任何对象构成别名的副本，因此编译器可以尽可能做更多的优化。\n例如下面的例子：\n1#include \u0026lt;stddef.h\u0026gt; 2#include \u0026lt;string_view\u0026gt; 3 4void byvalue(std::string_view sv, size_t* p) 5{ 6 *p = 0; 7 for (size_t i = 0; i \u0026lt; sv.size(); ++i) *p += 1; 8} 9 10void byref(const std::string_view\u0026amp; sv, size_t* p) 11{ 12 *p = 0; 13 for (size_t i = 0; i \u0026lt; sv.size(); ++i) *p += 1; 14} 编译成汇编代码：\n1# gcc 11.2 2byvalue(std::basic_string_view\u0026lt;char, std::char_traits\u0026lt;char\u0026gt; \u0026gt;, unsigned long*): 3 movq %rdi, (%rdx) 4 ret 5byref(std::basic_string_view\u0026lt;char, std::char_traits\u0026lt;char\u0026gt; \u0026gt; const\u0026amp;, unsigned long*): 6 movq $0, (%rsi) 7 xorl %eax, %eax 8 cmpq $0, (%rdi) 9 je .L5 10.L6: 11 addq $1, %rax 12 movq %rax, (%rsi) 13 cmpq (%rdi), %rax 14 jb .L6 15.L5: 16 ret 在 byvalue 中，编译器能够很聪明的知道循环是以 1 为步幅，累加 sv.size() 次，因此直接将程序优化为将 *p 赋值为 sv.size()。 而 byref 中，编译器老老实实生成循环的代码。\n总结 string_view作为 c++17 引入的新类型，其功能还是非常强大的。但是在使用的时候也要对其特性足够的了解，切勿滥用，尤其不能笼统的使用 std::string 替代 const std::string\u0026amp;。 在通常情况下，函数的参数，或者循环控制变量是string_view两个最常用的使用场景。对于其他使用场景，大家一定要注意 string_view 不会延长原 std::string 的生命周期，因此在对象中保存 string_view 或者通过函数返回 string_view 的时候一定要非常小心。\n另外，对于string_view这种简单的类型，更倾向于按值传递。\n","date":"February 14, 2022","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/cpp/2022-02-14-c++17%E4%B9%8Bstring_view/","series":[],"smallImg":"","tags":[{"title":"C++","url":"/blog/tags/c++/"},{"title":"C++17","url":"/blog/tags/c++17/"}],"timestamp":1644796800,"title":"c++17:string_view"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"Programming","url":"/blog/categories/programming/"}],"content":" 1. 概览 要谈论 LevelDB 的 Compaction 就不得不从 LevelDB 的整个数据写入流程入手。LevelDB 的基本写入流程大致为：\n数据先写入到 WAL 日志中，做持久化 然后数据同步到mutable memtable中 当mutable memtable大小达到Options.write_buffer_size设置的大小时，就会变成immutable memtable，并且创建一个新的mutable memtable 后台的 Compaction 线程会把immutable memtabledump 成 sstable 文件，并设置于 Level 0 层 当 Level i 达到一定条件后，就会和 Level i + 1 层的 sstable 进行合并，从而触发 Compaction 过程，并在 Level n + 1 层生成一个新的 sstable 文件 2. Compaction 分类 在 LevelDB 中，Compaction 大体上可以分为两类，分别是：\nimmutable memtable compaction，也叫做minor compaction，指的是将immutable memtabledump 到 sstable 文件的过程 sstable compaction，也叫做major compaction，指的是 sstable 文件之间的合并过程 而对于sstable compaction又可以细分为三种：\nmanual compaction，是指外部通过调用DBImpl::CompactRange接口触发的 size compaction，是指程序根据每个 Level 的总文件大小通过一定规则自动触发的 seek compaction，每个 sstable 文件内部维护了一个seek miss的 counter，当达到一定条件的时候，LevelDB 就认为这个文件需要 Compact 从DBImpl::BackgroundCompaction的代码逻辑中不难看出，这些 Compaction 策略的优先级为：\nimmutable memtable compaction \u0026gt; manual compaction \u0026gt; size compaction \u0026gt; seek compaction\n1// db_impl.cc 2void DBImpl::BackgroundCompaction() { 3 mutex_.AssertHeld(); 4 5 // 首先判断是否存在 immutable memtable，如果存在，则优先进行 6 // immutable memtable compaction 7 if (imm_ != nullptr) { 8 CompactMemTable(); 9 return; 10 } 11 Compaction* c; 12 // 其次判断是否存在 manual_compaction_，如果有，则进行manual compaction 13 bool is_manual = (manual_compaction_ != nullptr); 14 InternalKey manual_end; 15 if (is_manual) { 16 // ... 17 } else { 18 // 然后通过PickCompaction选择size compaction还是seek compaction 19 c = versions_-\u0026gt;PickCompaction(); 20 } 21 //...... 22} 23 24// version_set.cc 25Compaction* VersionSet::PickCompaction() { 26 Compaction* c; 27 int level; 28 // We prefer compactions triggered by too much data in a level over 29 // the compactions triggered by seeks. 30 const bool size_compaction = (current_-\u0026gt;compaction_score_ \u0026gt;= 1); 31 const bool seek_compaction = (current_-\u0026gt;file_to_compact_ != nullptr); 32 if (size_compaction) { 33 // ... 34 } else if (seek_compaction) { 35 // ... 36 } else { 37 return nullptr; 38 } 39 // ... 40} 3. Immutable memtable Compaction 3.1 触发条件 由于immutable memtable compaction是当存在Immutable memtable的时候才会触发，因此，immutable memtable compaction的触发于数据的写入有着密切的关联。追踪整个数据写入的逻辑，不难发现整个调用的链路为：DBImpl::Put -\u0026gt; DB::Put -\u0026gt; DBImpl::Write -\u0026gt; DBImpl::MakeRoomForWrite。\nDBImpl::MakeRoomForWrite的逻辑也很清晰：\n1// db_impl.cc 2Status DBImpl::MakeRoomForWrite(bool force) { 3 mutex_.AssertHeld(); 4 assert(!writers_.empty()); 5 bool allow_delay = !force; 6 Status s; 7 while (true) { 8 if (!bg_error_.ok()) { 9 // Yield previous error 10 s = bg_error_; 11 break; 12 } else if (allow_delay \u0026amp;\u0026amp; versions_-\u0026gt;NumLevelFiles(0) \u0026gt;= 13 config::kL0_SlowdownWritesTrigger) { 14 // ... 15 mutex_.Unlock(); 16 env_-\u0026gt;SleepForMicroseconds(1000); 17 allow_delay = false; // Do not delay a single write more than once 18 mutex_.Lock(); 19 } else if (!force \u0026amp;\u0026amp; 20 (mem_-\u0026gt;ApproximateMemoryUsage() \u0026lt;= options_.write_buffer_size)) { 21 // There is room in current memtable 22 break; 23 } else if (imm_ != nullptr) { 24 // ... 25 background_work_finished_signal_.Wait(); 26 } else if (versions_-\u0026gt;NumLevelFiles(0) \u0026gt;= config::kL0_StopWritesTrigger) { 27 // ... 28 background_work_finished_signal_.Wait(); 29 } else { 30 // ... 31 imm_ = mem_; 32 has_imm_.store(true, std::memory_order_release); 33 mem_ = new MemTable(internal_comparator_); 34 mem_-\u0026gt;Ref(); 35 // ... 36 MaybeScheduleCompaction(); 37 } 38 } 39 return s; 40} 先判断 Level 0 层的文件数是否达到了 kL0_SlowdownWritesTrigger (default: 8)中配置的值，如果达到的话，则 Sleep 1ms 判断当前 memtable 占用的内存大小是否达到了 Options.write_buffer_size 的值，如果没有达到，则说明当前 memtable 符合写入条件 如果当前 memtable 占用的内存大小达到了阈值，则检查是否有还未 compaction 的 immutable memtable，如果有，则等待直到上一个 immutable memtable compaction 执行完成 如果不存在还未 compaction 的 immutable memtable，则判断当前 Level 0 层的的文件数是否达到了 kL0_StopWritesTrigger (default: 12)设置的数量，如果达到了则等待后台的 compaction 任务执行完成，并且直到满足条件 如果当前 Level 0 层的文件数没有达到阈值，则将当前的 mutable memtable 设置成 immutable mentable，并创建一个新的 mutable memtable，然后触发 compaction 3.2 执行过程 Immutable memtable compaction 的执行过程逻辑在DBImpl::CompactMemTable -\u0026gt; DBImpl::WriteLevel0Table中，整个流程分为 3 个步骤：\n1// db_impl.cc 2Status DBImpl::WriteLevel0Table(MemTable* mem, VersionEdit* edit, 3 Version* base) { 4 // ... 5 Status s; 6 { 7 mutex_Unlock(); 8 s = BuildTable(dbname_, env_, options_, table_cache_, iter, \u0026amp;meta); 9 mutex_Lock(); 10 } 11 // ... 12 int level = 0; 13 if (s.ok() \u0026amp;\u0026amp; meta.file_size \u0026gt; 0) { 14 const Slice min_user_key = meta.smallest.user_key(); 15 const Slice max_user_key = meta.largest.user_key(); 16 if (baze != nullptr) { 17 level = baze-\u0026gt;PickLevelForMemTableOutput(min_user_key, max_user_key); 18 } 19 edit-\u0026gt;AddFile(level, meta.number, meta.file_size, meta.smallest, 20 meta.largest); 21 } 22 // ... 23} 调用DBImpl::BuildTable将 Immutable memtable 中的数据 dump 成 sstable 文件 调用VersionSet::PickLevelForMemTableOutput为这个新生成的 sstable 文件选择一个新的 Level 调用VersionEdit::AddFile将这个新的 sstable 文件放到选出来的 Level 中 下图是VersionSet::PickLevelForMemTableOutput的流程图\n4. Sstable Compaction Sstable Compaction 就是将不同层级的 sst 文件进行合并的，主要是为了均衡各个 level 的数据，保证读性能，同时也会合并 delete 数据，释放磁盘空间。\n4.1 Manual Compaction Manual Compaction 的核心逻辑在 VersionSet::CompactRange 中，执行流程为：\n通过 Version::GetOverlappingInputs 获取指定的 Level 中 key-range 与[start, end]有交集的 sstable 如果指定的 Level \u0026gt; 0 则对一次 compaction 的 sst 文件总大小做个限制，避免一次 compact 过多 通过 VersionSet::SetupOtherInputs 获取其他需要 compatcion 的 sstable 通过调用VersionSet::AddBoundaryInputs将当前 Level 中符合边界条件的 sst 添加到要 compaction 的 sst 列表中 通过调用VersionSet::GetRange确定当前 Level 中要 compaction 的 sst 文件的 key range 通过调用Version::GetOverlappingInputs获取 Level + 1 层中与上一步获取的 key range 有交集的 sst 文件 通过调用VersionSet::GetRange2获取所有将要参与 compaction 的 sst 文件的 key range 在不改变 Level + 1 层 compaction 文件个数的情况下，尝试增加 Level 层 compaction 文件的数量 获取 Level + 2 层中与上述获取的最终 key range 有交集的 sst 文件 4.2 Size Compaction Size Compaction 的执行条件是 LevelDB 会计算每个 Level 的总文件大小，从而计算出一个 score，最后根据 score，来选择一个合适的 level 来进行 compaction。 score 的计算逻辑主要在VersionSet::Finalize中：当$Level = 0$时，$score = files.size() / 4$，当 $Level \u0026gt; 0$时，$score = levelbytes / (1048576.0 * 10^level)$。通过遍历每一层的所有 sstable 文件，根据对应的公式计算出来$score$，然后挑选出最大的$score$以及对应的 Level。\n4.3 Seek Compaction 在FileMetaData中，有一个字段是allowed_seeks，是用来保存当前 sst 文件，允许容忍的 seek miss 最大值，每次调用 Get，并且触发 seek miss 的时候，就会对对应的 sst 文件的allowed_seeks执行减 1。allowed_seeks的初始值为：$sstsize / 16384$，且最小为 100。 如果某个 sst 文件的allowed_seeks减到 0 的时候，则会将该 sst 文件赋值给Version::file_to_compact_，同时将该 sst 的 level 赋值给Version::file_to_compact_level_。\n4.4 Do Compaction Work 前面的逻辑属于 Compaction 策略，而这一步可以说是真正执行 Compaction 的过程了，核心逻辑都在DBImpl::DoCompactionWork中：\n调用VersionSet::MakeInputIterator构造迭代器： 对于 Level 0 层的文件，会为每一个 sst 文件创建一个 Iterator 对于非 Level 0 层的文件，会创建一个 concatenating iterator (TwoLevelIterator) 然后将通过上述两条规则创建好的 Iterator 构造成 MergingIterator 对构造好的 Iterator 进行遍历 input-\u0026gt;SeekToFirst() 优先检查并合并存在的Immutable Memtable 如果当前 key 与 level + 2 层产生的重叠的 sst 文件的 size 超过阈值，则调用 DBImpl::FinishCompactionOutputFile 立即结束当前写入的 sstable 文件 解析当前的 key 判断当前 key 是否重复且不在快照范围内，或者当前 key 被标记为删除(type == kTypeDeletion)并且当前 key 不在快照范围内并且在 Level + 2 层以上的 Level 中不存在该 key(Compaction::IsBaseLevelForKey)，满足上述条件时，该 key 被丢弃 当该 key 不被丢弃时，将该 key 写入到 compat 的 sst 文件中 当当前写入的 sst 文件大小超过阈值的时候，会关闭该文件，在下一次写入 key 的时候创建一个新的 sst 文件 调用迭代器迁移input-\u0026gt;Next() 更新 compact 统计信息 调用DBImpl::InstallCompactionResults生效 compact 后的状态 将 compat 中的 input sstable 设置为删除，生成的新的 sstable 文件添加到 Level + 1 层中 调用VersionSet::LogAndApply应用 VersionEdit 以当前 version 为基准，构造新的 Version 通过VersionSet::Builder将 VersionEdit 应用在新的 Version 上 重新计算每一个 sstable 的 score 值 写入 MANIFEST 文件 将current_设置为新的 version ","date":"January 12, 2021","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/storage/2021-01-12-leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8Bcompaction/","series":[],"smallImg":"","tags":[{"title":"Leveldb","url":"/blog/tags/leveldb/"},{"title":"Storage","url":"/blog/tags/storage/"}],"timestamp":1610409600,"title":"LevelDB 源码阅读之 Compaction"},{"authors":[],"categories":[{"title":"Theory","url":"/blog/categories/theory/"}],"content":" 拜占庭将军问题 简介 在可能存在叛军的情况下，采用合适的通讯协议，让多个将军达成共识，执行统一的作战计划 二忠一叛难题 它是分布式领域最复杂的容错模型 莱斯利·兰伯特（Leslie Lamport）The Byzantine Generals Problem 二忠一叛难题 总共有三个将军，其中一个作为指挥官 通过信使相互传递作战指令，进攻或者撤退 所有忠诚的将军必须执行统一的作战计划，忠诚的将军必须执行忠诚的指挥官发布的指令 假如 LIEUTENANT2 叛变，LIEUTENANT1 收到的作战指令就是“进攻，撤退” 假如 COMMANDER 叛变，LIEUTENANT1 和 LIEUTENANT2 收到的作战指令都是“进攻，撤退” 口信消息型解法 叛变人数为 m 需要已知 则所有参与者的人数至少为 3m+1 第一轮由指挥官发送作战指令 第二轮由各位将军相互发送指令 收到指令的将军按照少数服从多数的原则执行指令 按照这个公式，前面的例子叛军为 1 人的情况，则需要 1 个指挥官和 3 个将军 假如 LIEUTENANT3 叛变了，那么首先指挥官向各位将军发送“进攻”的指令，由于 3 号将军叛变了，所以最终 1 号将军收到的指令是 2 个进攻，1 个撤退，2 号将军同样收到 2 个进攻，1 个撤退，这样忠诚的将军将会执行一致的指令\n假如 COMMANDER 叛变了，分别向 1 号将军发送了“进攻”，向 2 号将军发送了“撤退”，向 3 号将军发送“进攻”，那么通过第二轮的协商后，1，2，3 号将军得到的指令都是“进攻，进攻，撤退”，这样按照少数服从多数的原则，忠诚的将军最终执行了一致的作战指令。\n口信消息型解法非常简单有效，但是有一些缺点，就是必须知道叛军的数量，而且对参与协商的人数有限制\n签名消息型解法 忠诚将军的签名无法伪造，对他签名的任何变更都将被发现 任何人都能验证将军签名的真假 对于开始三个将军的例子而言，假如 2 号将军叛变，那么 1 号将军在收到 2 号将军篡改的指挥官的指令后，就能发现消息被篡改，从而执行跟指挥官执行相同的指令 假如指挥官叛变，分别给 1 号将军和 2 号将军发送“进攻”和“撤退”的指令，那么通过第二轮协商后，1 号将军收到的指令是“进攻，撤退”，2 号将军同样收到“进攻，撤退”的指令，此时他们只需要实现约定好规则，将指令排序后取其中的某一个值就能实现忠诚将军永远执行相同的指令 小结 将军相当于计算机的服务节点 忠诚的将军相当于正常服务的节点 叛变的将军相当于故障的节点 实际上在分布式系统常常面临的问题比拜占庭问题要简单很多，因为这个场景可能会丢失消息，重复消息，但是很少会出现错误消息或者伪造消息的情况 分布式系统中，最长用的是非拜占庭容错算法，即故障容错算法（Crash Fault Tolerance, CFT） CFT 解决的是分布式系统中存在故障，但不存在恶意节点的场景下的共识问题 CFT 的常见实现有 Paxos 算法，Raft 算法等 分布式共识算法 Paxos 在过去的几十年里，Paxos 是分布式共识算法的代名词 Basic Paxos：多个节点间就某个值达成共识 Multi-Paxos：执行多个 Basic Paxos 实例，就一系列值达成共识 Raft Raft 算法是现在分布式系统开发的首选共识算法 本质上说，Raft 算法是通过一切以领导者为准的方式，保证一系列值得共识和各节点日志的一致性 成员角色 领导者(Leader): 处理写请求，管理日志复制，发送心跳，宣告领导地位 跟随者(Follower): 接收和处理 Leader 的消息，等待 Leader 的心跳，如果 Leader 心跳超时，就主动成为候选人，并发起一轮新的选举 候选人(Candidate): 向其他节点发送投票请求，如果赢得大多数选票，就晋升为 Leader 选举过程 假设有 3 个节点 A,B,C，初始阶段任期编号都为 0，Raft 实现了随机超时，也就是每个节点等待 Leader 心跳的超时时间是随机的。\n由于节点 A 的超时时间最短，所以最先因为没有等到 Leader 的心跳而发生超时，此时 A 变成候选人，并增加自己的任期编号为 1，向 B 和 C 发起选举请求。\nB 和 C 在收到 A 的请求后，由于在任期编号为 1 的这届任期内，还没有收到其他的投票请求，B 和 C 将自己本地的任期编号改为候选人 A 发起的任期编号，并将赞同票投给 A。\n节点 A 顺利赢得了大多数选票，成功晋升为 Leader。并且周期性的向 B 和 C 发送心跳信息，防止 Follower 节点发生新的选举，导致“篡权”。\n选举总结 Leader 周期性的向所有 Follower 发送心跳信息 如果在指定时间内，Follower 没有收到 Leader 的心跳，那么它就认为当前没有领导者，推举自己为 Candidate，并发起选举 在一次选举中，赢得大多数选票的 Candidate 晋升为 Leader 在一个任期内，Leader 一直都是 Leader，直到它自身出现问题不能发送心跳，或者因为网络原因导致其他节点没能在规定时间内收到心跳发起新的选举 在一次选举中，每个服务节点最多只能对一个人气编号投出一张选票，并且按照先来先服务的原则投票。比如 C 先收到任期编号为 1 的 A 的请求，又收到请求编号为 1 的 B 的请求，那么 C 会把选票投给 A 当任期编号相同时，日志完整性更高（也就是最后一条日志项对应的任期编号值更大）的 Follower 拒绝投票给日志完整性低的 Candidate 选票瓜分导致选举失败：同一任期内，多个候选人同时发起选举，导致选票被瓜分，所有候选人都不能达到赢得大多数选票 随机超时时间：为了避免同一时间出现多个候选人，Raft 算法采用随机超时时间的机制，保证大多数情况下，只有一个服务节点先发起选举，而不是同时发起选举，从而减少发生选票瓜分导致选举失败的可能 日志复制 在 Raft 算法中，副本数据是以日志的形式存在的，Leader 接收来自客户端的写请求后，处理写请求的过程就是一个复制和应用日志项到状态机的过程。副本数据是以日志的形式存在，日志由日志项组成。日志项是一种数据格式，包含指令和一些附加信息，比如索引值（Log index）、任期编号（Term）\n指令：一条由客户端请求指定的、状态机需要执行的指令 索引值：日志项对应的索引值，是一个连续的、单调递增整数 任期编号：创建这条日志项的 Leader 的任期编号 Raft 的日志复制过程其实就是一个优化后的二阶段提交，Leader 进入第一阶段，通过日志复制（AppendEntries）RPC 消息，将日志项复制到其他节点上，如果 Leader 收到大多数的节点的复制成功响应后，它将日志应用到自己的状态机，并返回成功给客户端。如果 Leader 没有收到大多数节点的复制成功响应，那么直接返回错误给客户端，此时 Leader 并没有进行二阶段提交，通知 Follower 应用日志项，而是当 Leader 在下一次发送心跳或者日志复制的 RPC 请求时，会包含 Leader 当前最大的和将要被提交的日志项的索引值，收到消息后的 Follower 发现自己还有未应用的日志项，则会应用。Leader 通过日志复制 RPC 的一致性校验，找到 Follower 节点上，与自己相同日志项的最大索引值，也就是说，在这个索引值之前的日志，Leader 和 Follower 是一致的，之后就是不一致的了。Leader 强制 Follower 更新覆盖不一致的日志项，实现日志一致性。\nPrevLogEntry：表示当前要复制的日志项前一条日志的索引值 PrevLogTerm：表示当前要复制的日志项，前一条日志对应的任期编号 Leader 通过日志复制 RPC 消息，发送当前最新的日志项到 Follower，此时 PrevLogEntry 为 5，PrevLogTerm 为 3 Follower 收到消息后，在自己的日志中找不到 Index 为 5，Term 为 3 的日志项，所以拒绝日志复制 Leader 收到拒绝响应后，会递减要复制的日志项的索引值，并发送新的消息给 Follower 直到 Folloer 在本地日志中找到对应 PrevLogEntry 和 PrevLogTerm 的日志，则从此时开始日志的复制 ","date":"May 25, 2020","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/inf/2020-05-25-%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AE/","series":[],"smallImg":"","tags":[{"title":"Inf","url":"/blog/tags/inf/"},{"title":"Raft","url":"/blog/tags/raft/"}],"timestamp":1590364800,"title":"分布式协议"},{"authors":[],"categories":[{"title":"Go","url":"/blog/categories/go/"}],"content":" 背景 我们 laser 存储为了更好的跟引擎对接，适应其他团队的技术生态，决定开发一套 golang 的公共库来给大家使用。于是我们在公司私有的 gitlab 上新建了一个项目:git.yourcomp.com/ad/ads_core/adgo，并且我们想使用单一的 codebase 来管理所有的公共 library.\n而且，为了更好的管理模块，我们统一使用了 go mod。\n按照平时我们在 github 上拉取 go library 的惯例，我本以为直接使用go get git.yourcomp.com/ad/ads_core/adgo/xxx就能直接拉取到相应的模块了，然而在开发完功能测试的时候却发现，事实并不是想象中那样。\n遇到的问题和解决方案 1. 仓库问题 执行go get后，实际上会请求\u0026quot;https://git.yourcomp.com/ad/ads_core/adgo?go-get=1\u0026quot;这个地址，如果使用-insecure选项，则会请求\u0026quot;http://git.yourcomp.com/ad/ads_core/adgo?go-get=1\u0026quot;，正常情况下回返回meta tag：\n1\u0026lt;html\u0026gt; 2 \u0026lt;head\u0026gt; 3 \u0026lt;meta 4 name=\u0026#34;go-import\u0026#34; 5 content=\u0026#34;git.yourcomp.com/ad/ads_core git http://git.yourcomp.com/ad/ads_core.git\u0026#34; 6 /\u0026gt; 7 \u0026lt;/head\u0026gt; 8\u0026lt;/html\u0026gt; 这是 go remote import 的协议，meta tag 的格式一般为\n1\u0026lt;meta name=\u0026#34;go-import\u0026#34; content=\u0026#34;import-prefix vcs repo-root\u0026#34; /\u0026gt; 由于 gitlab 的版本问题，如果使用了 subgroup，则不能正确返回 meta tag。也就是说，我们使用的 gitlab 版本只支持一层 namespace 下建的项目。而\u0026quot;ad/ads_core/adgo\u0026quot;就是两层 namespace，所以 meta tag 中返回的 repo 地址是\u0026quot;http://git.yourcomp.com/ad/ads_core.git\u0026quot;显然是错的。于是我们又对代码库进行了迁移。\n2. 权限问题 获取正确的 meta tag 后，通过对应的版本控制工具下载 repo。所以我们这里最终会转换成使用git clone ...来获取代码。由于是私有的 git 仓库，所以会遇到 clone 时需要输入用户名和密码的情况。\n其实这个问题，我们首先会想到的是，如何把通过 https 的方式获取代码变成通过 ssh 的方式，这样就可以配置公钥免密码拉取。其实这个实现起来并不难，只需要在.gitconfig中添加一行配置就可以：\n1[url \u0026#34;ssh://git@git.yourcomp.com:2222\u0026#34;] 2 insteadOf = http://git.yourcomp.com 这个配置就是将 http 形式的的请求，转换成 ssh 的形式。\n3. 版本号问题 由于我们使用的单一的 codebase，对代码仓库打 tag 不能用来标识内部单个 library 的版本，而且内部 library 之间还存在依赖关系，所以这里就需要 Pseudo-versions，具体格式如下：\n1vX.0.0-yyyymmddhhmmss-abcdefabcdef 其中\u0026quot;abcdefabcdef\u0026quot;是 commit hash，而\u0026quot;yyyymmddhhmmss\u0026quot;是该 commit 的 UTC 时间，特别注意是 UTC 时间，跟我们所在的东八区相差 8 个小时。\n为了方便，一般我们查看某个 commit 和 UTC 时间的话，需要使用TZ=UTC git log，获取 12 位的 commit id 也可以使用如下命令：\n1TZ=UTC git log -n 20 --pretty=\u0026#34;format:%C(auto)%h %ad %C(auto)%s%d %Cblue(%an)\u0026#34; --decorate --abbrev=12 --abbrev-commit --date=local 参考文档 Support for Go remote import\nPseudo_versions\n","date":"October 17, 2019","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/go/2019-10-17-%E5%9F%BA%E4%BA%8E%E5%85%AC%E5%8F%B8%E7%A7%81%E6%9C%89gitlab%E7%9A%84go-module%E5%AE%9E%E8%B7%B5/","series":[],"smallImg":"","tags":[{"title":"Go","url":"/blog/tags/go/"}],"timestamp":1571270400,"title":"基于公司私有gitlab的go module实践"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"Programming","url":"/blog/categories/programming/"}],"content":"使用 c 语言的 macro 操作，能够很简单的用 c 语言模拟 lisp 语法。\n下面我们来定义 lisp.h 头文件 1#ifndef LISP_H_OTE1HWPK 2#define LISP_H_OTE1HWPK 3 4#include \u0026lt;stdio.h\u0026gt; 5#include \u0026lt;stdlib.h\u0026gt; 6 7#define define(ret, name, args, block) \\ 8 ret name args { return block; } 9 10#define if(expr, block1, block2) \\ 11 expr ? block1 : block2 12 13#define eq(a, b) \\ 14 a == b 15 16#define neq(a, b) \\ 17 a != b 18 19#define sub(a, b) \\ 20 a - b 21 22#define mul(a, b) \\ 23 a * b 24 25#define add(a, b) \\ 26 a + b 27 28#define div(a, b) \\ 29 a / b 30 31#endif /* end of include guard: LISP_H_OTE1HWPK */ 然后来用类似于 lisp 的语法编写一段求阶乘的代码： 1define(int, factorial, (int n), 2 if(eq(n, 0), 3 1, 4 mul(n, factorial(sub(n, 1))))) 5 6define(int, main, (void), 7 (printf(\u0026#34;10! = %d\\n\u0026#34;, factorial(10)), EXIT_SUCCESS)) 编写 Makefile: 1CFLAGS = -Wall -include \u0026#34;lisp.h\u0026#34; 2 3TARGET=factorial 4 5all: 6\tgcc -o $(TARGET) $(TARGET).c $(CFLAGS) 7 8clean: 9\trm -f $(TARGET) 编译并运行： 1liubang@venux-dev:~$ make 2gcc -o factorial factorial.c -Wall -include \u0026#34;lisp.h\u0026#34; 3liubang@venux-dev:~$ ./factorial 410! = 3628800 ","date":"August 18, 2019","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/sp/2019-08-18-c%E8%AF%AD%E8%A8%80%E6%A8%A1%E6%8B%9Flisp%E8%AF%AD%E6%B3%95/","series":[],"smallImg":"","tags":[{"title":"C","url":"/blog/tags/c/"},{"title":"Sp","url":"/blog/tags/sp/"}],"timestamp":1566086400,"title":"使用c语言模拟lisp语法"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"Programming","url":"/blog/categories/programming/"}],"content":"我们有这样一段简单的代码，用来输出 10 个[0, 100)的随机数：\n1// random.c 2#include \u0026lt;stdio.h\u0026gt; 3#include \u0026lt;stdlib.h\u0026gt; 4#include \u0026lt;time.h\u0026gt; 5 6int main() { 7 srand(time(NULL)); 8 int i = 10; 9 while (i--) printf(\u0026#34;%d\\n\u0026#34;, rand() % 100); 10 return 0; 11} 编译运行：\n1liubang@venux-dev:~$ gcc random.c -o random 2liubang@venux-dev:~$ ./random 344 446 597 651 762 876 992 1076 1138 1210 这个程序每次运行的结果都是不一样的，现在我们希望我们能够在不修改源码的情况下，控制程序的输出结果，例如我希望这段程序运行的结果是 每次都能输出 10 个 10。由于不能修改源码，或者我们根本没有源码，面对这样一个编译后的可执行二进制文件，想要修改程序的运行结果，可能显 得有些困难。然而，如果能够善用动态连接器的话，这都不是问题。\n下面我们来创建一段程序：\n1// unrandom.c 2int rand() { 3 return 10; 4} 然后将它编译成动态链接库：\n1liubang@venux-dev:~$ gcc -shared -fPIC unrandom.c -o libunrandom.so 这样我们就得到了一个名为libunrandom.so的动态链接库，然后执行：\n1liubang@venux-dev:~$ LD_PRELOAD=./libunrandom.so ./random 210 310 410 510 610 710 810 910 1010 1110 是不是发现原来程序的结果变成了 10 个 10，即使执行多次，结果都一样。为什么会这样呢？LD_PRELOAD到底做了什么事？ 下面我们来进一步了解其中的原理。\n我们使用 ldd 命令查看原始程序用到的链接库：\n1liubang@venux-dev:~$ ldd random 2\tlinux-vdso.so.1 (0x00007ffebcba5000) 3\tlibc.so.6 =\u0026gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f21ad8d7000) 4\t/lib64/ld-linux-x86-64.so.2 (0x00007f21adeca000) 这些链接库是在程序编译时期就确定的，而且被编译到最终的可执行文件中了。众所周知，libc.so提供了标准 c 函数库，所以所有的 c 程序都会使用到这个链接库。 我们可以使用下面的命令查看libc.so都提供了哪些标准函数：\n1liubang@venux-dev:~$ nm -D /lib/x86_64-linux-gnu/libc.so.6 2... 3... 400000000000443a0 T rand 5... 在输出的结果中，我们确实能够看到rand这个标准函数。\n下面我们再来看看，使用LD_PRELOAD后到底发生了什么。\n1liubang@venux-dev:~$ LD_PRELOAD=./libunrandom.so ldd ./random 2\tlinux-vdso.so.1 (0x00007ffe48bed000) 3\t./libunrandom.so (0x00007f419497d000) 4\tlibc.so.6 =\u0026gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f419458c000) 5\t/lib64/ld-linux-x86-64.so.2 (0x00007f4194d81000) 很显然，我们的程序“被强制”使用了libunrandom.so这个链接库。从而导致 random 程序在调用rand()函数的时候使用了我们自己实现的，而不是真正的rand()函数。\n这个技巧仅仅使用来 hack 程序，修改程序的运行结果吗？其实不然，在实际的应用中，通常会使用这个技巧来做一些类似于 Java 中的\u0026rsquo;AOP\u0026rsquo;，对程序进行切面，并注入一些有用的代码，以实现一些功能。\n下面我们来看另一个例子：我们想要知道某个二进制程序中每次调用 malloc 时的参数，并统计调用了多少次。注意这里仅仅是想要获取调用标准函数 malloc 的参数，而不会改变原始程序的行为。\n1// malloc_trace.c 2#include \u0026lt;dlfcn.h\u0026gt; 3#include \u0026lt;unistd.h\u0026gt; 4#include \u0026lt;stddef.h\u0026gt; 5#include \u0026lt;stdio.h\u0026gt; 6#include \u0026lt;string.h\u0026gt; 7 8static int c = 0; 9 10void *malloc(size_t size) { 11 char buf[128]; 12 static void *(*real_malloc)(size_t) = NULL; 13 if (real_malloc == NULL) { 14 real_malloc = dlsym(RTLD_NEXT, \u0026#34;malloc\u0026#34;); 15 } 16 c++; 17 sprintf(buf, \u0026#34;malloc called, size = %zu, count = %d\\n\u0026#34;, size, c); 18 write(2, buf, strlen(buf)); 19 return real_malloc(size); 20} 编译成动态链接库：\n1liubang@venux-dev:~$ gcc -D_GNU_SOURCE -shared -ldl -fPIC -o libmalloc_trace.so malloc_trace.c 然后我们来统计一下ls这个命令中 malloc 调用的参数和次数：\n1liubang@venux-dev:~$ LD_PRELOAD=./libmalloc_trace.so ls 2malloc called, size = 552, count = 1 3malloc called, size = 120, count = 2 4malloc called, size = 1024, count = 3 5malloc called, size = 5, count = 4 6...... 7malloc called, size = 5928, count = 174 8malloc called, size = 208, count = 175 9malloc called, size = 208, count = 176 10malloc called, size = 1024, count = 177 11 bin btree.c Desktop Documents Downloads go libmalloc_trace.so libunrandom.so malloc_trace.c merge_sort.c Pictures Public random random.c rsync.sh unrandom.c \u0026#39;VirtualBox VMs\u0026#39; workspace 模板 大功告成，是不是很简单。\n","date":"July 18, 2019","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/sp/2019-07-18-%E5%8A%A8%E6%80%81%E8%BF%9E%E6%8E%A5%E5%99%A8%E6%8A%80%E5%B7%A7%E4%B9%8B%E4%BD%BF%E7%94%A8ld_preload%E6%94%B9%E5%8F%98%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A1%8C%E4%B8%BA/","series":[],"smallImg":"","tags":[{"title":"C","url":"/blog/tags/c/"},{"title":"Sp","url":"/blog/tags/sp/"}],"timestamp":1563408000,"title":"动态连接器技巧之使用LD_PRELOAD改变程序的行为"},{"authors":[],"categories":[{"title":"Programming","url":"/blog/categories/programming/"}],"content":" 什么是 BDD BDD(Behavior Driven Development)，行为驱动开发，是一种敏捷软件开发的技术，它鼓励软件项目中的开发者、QA 和非技术人员或商业参与者之间的协作。\nBDD 的重点是通过与利益相关者的讨论取得对预期的软件行为的清醒认识。它通过用自然语言书写非程序员可读的测试用例扩展了测试驱动开发方法。行为驱动开发人员使用混合了领域中统一的语言的母语语言来描述他们的代码的目的。这让开发者得以把精力集中在代码应该怎么写，而不是技术细节上，而且也最大程度的减少了将代码编写者的技术语言与商业客户、用户、利益相关者、项目管理者等的领域语言之间来回翻译的代价。\n具体怎么操作 结合我们项目开发使用的 spring boot 2.x，下面我们来具体说明如何在实际项目中使用 BDD。\n依赖的包 1\u0026lt;cucumber.version\u0026gt;4.2.5\u0026lt;/cucumber.version\u0026gt; 2 3... 4 5\u0026lt;dependency\u0026gt; 6 \u0026lt;groupId\u0026gt;io.cucumber\u0026lt;/groupId\u0026gt; 7 \u0026lt;artifactId\u0026gt;cucumber-junit\u0026lt;/artifactId\u0026gt; 8 \u0026lt;version\u0026gt;${cucumber.version}\u0026lt;/version\u0026gt; 9 \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; 10\u0026lt;/dependency\u0026gt; 11 12\u0026lt;dependency\u0026gt; 13 \u0026lt;groupId\u0026gt;io.cucumber\u0026lt;/groupId\u0026gt; 14 \u0026lt;artifactId\u0026gt;cucumber-java\u0026lt;/artifactId\u0026gt; 15 \u0026lt;version\u0026gt;${cucumber.version}\u0026lt;/version\u0026gt; 16 \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; 17\u0026lt;/dependency\u0026gt; 18 19\u0026lt;dependency\u0026gt; 20 \u0026lt;groupId\u0026gt;io.cucumber\u0026lt;/groupId\u0026gt; 21 \u0026lt;artifactId\u0026gt;cucumber-spring\u0026lt;/artifactId\u0026gt; 22 \u0026lt;version\u0026gt;${cucumber.version}\u0026lt;/version\u0026gt; 23 \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; 24\u0026lt;/dependency\u0026gt; 定义启动文件 BDD 其实也是依赖 junit，然后调用Cucumber的 Runner 来运行相应的测试。\n1package com.weibo.ad.bp.st.ryujo.web.test; 2 3import cucumber.api.CucumberOptions; 4import cucumber.api.junit.Cucumber; 5import org.junit.runner.RunWith; 6 7@RunWith(Cucumber.class) 8@CucumberOptions(features = \u0026#34;classpath:features\u0026#34;, 9 tags = {\u0026#34;not @ignored\u0026#34;, \u0026#34;@base\u0026#34;}, 10 plugin = {\u0026#34;pretty\u0026#34;, \u0026#34;html:target/cucumber\u0026#34;, \u0026#34;junit:target/junit-report.xml\u0026#34;}, 11 glue = {\u0026#34;classpath:com.weibo.ad.bp.st.ryujo.web.test.step\u0026#34;}) 12public class RunCucumberTest { 13} @CucumberOptions中的 features，用于指定我们项目中要运行的 feature 的目录 @CucumberOptions中的 format，用于指定我们项目中要运行时生成的报告，并指定之后可以在 target 目录中找到对应的测试报告 @CucumberOptions中的 glue，用于指定项目运行时查找实现 step 定义文件的目录 @CucumberOptions中的 tags,用来决定想要 Cucumber 执行哪个特定标签（以及场景），标签以“@”开头，如果是排除某个特定标签，用\u0026quot;not @ignored\u0026quot; 定义 feature 在项目模块的test/resources/features目录下新建一个get_mid_info.feature 文件\n1@base 2Feature: Get Mid Info. 3 This is some operations about mid. 4 5 Scenario Outline: Get Mid info by mid. 6 Given mid is \u0026#34;\u0026lt;mid\u0026gt;\u0026#34; 7 When I ask whether the mid info can be get correctly. 8 Then I shoud be told \u0026#34;\u0026lt;answer\u0026gt;\u0026#34; 9 10 Examples: 11 | mid | answer | 12 | 2608812381 | Yes | 13 | 123 | No | 当然也可以使用Scenario来写\n1@base 2Feature: Get Mid Info 3 Scenario: I can get mid info correctly 4 Given mid is 2608812381 5 When I ask whether the mid info can be get correctly 6 Then I shoud be told \u0026#34;Yes\u0026#34; 7 8 Scenario: I can\u0026#39;t get mid info correctly 9 Given mid is 123 10 When I ask whether the mid info can be get correctly 11 Then I shoud be told \u0026#34;No\u0026#34; 相关术语 单词 中文含义 Feature 功能 Background 背景 Scenario 场景，剧本 Scenario Outline 场景大纲，剧本大纲 Examples 例子 Given *, 假如，假设，假定 When *, 当 Then *, 那么 And *, 并且，而且，同时 But *, 但是 以上get_mid_info.feature文件中我们可以很清楚的了解到，我们这里定义了一个获取 mid info 的功能，此功能包含了根据 mid 获取 mid info 的场景大纲，大纲包含了示例的列表，假定 mid 依次为 examples 中列举的 mid 的值时候，当我们判断是否能正确获取到 mid info，那么答案依次为 examples 中对应的 answer。\n实现相应的 step 我们在com.weibo.ad.bp.st.ryujo.web.test.step包下新建一个TestFeedMidServiceStep类：\n1@Slf4j 2public class TestFeedMidServiceStep { 3 4 private Long mid; 5 6 private String actualAnswer; 7 8 @Autowired 9 private FeedMidService feedMidService; 10 11 @Given(\u0026#34;^mid is \\\u0026#34;([^\\\u0026#34;]*)\\\u0026#34;$\u0026#34;) 12 public void mid_is(String arg1) throws Exception { 13 this.mid = Long.valueOf(arg1); 14 } 15 16 @When(\u0026#34;^I ask whether the mid info can be get correctly\\\\.$\u0026#34;) 17 public void i_ask_whether_the_mid_info_can_be_get_correctly() throws Exception { 18 List\u0026lt;String\u0026gt; type = new ArrayList\u0026lt;\u0026gt;(); 19 type.add(\u0026#34;1\u0026#34;); 20 FeedMidResp.ObjectEntity objectEntity = 21 feedMidService.getAuthorizedMidInfo(mid, null, \u0026#34;hosho\u0026#34;, null, false, type, null, null, null); 22 log.info(\u0026#34;{}\u0026#34;, objectEntity); 23 if (null != objectEntity \u0026amp;\u0026amp; !objectEntity.getItems().isEmpty()) { 24 this.actualAnswer = \u0026#34;Yes\u0026#34;; 25 } else { 26 this.actualAnswer = \u0026#34;No\u0026#34;; 27 } 28 } 29 30 @Then(\u0026#34;^I shoud be told \\\u0026#34;([^\\\u0026#34;]*)\\\u0026#34;$\u0026#34;) 31 public void i_shoud_be_told(String arg1) throws Exception { 32 assertEquals(arg1, this.actualAnswer); 33 } 34} 配置 spring boot 容器 至此我们已经写好了一个基本的 feature，但是由于我们的测试依赖了 spring 管理的 bean，所以运行测试时必须启动 spring 容器。这里提供两种基本的方法。\n方法一：\n在每个 step 类上添加 spring 测试相关的注解:\n1@Slf4j 2@ContextConfiguration 3@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) 4@ActiveProfiles(\u0026#34;test\u0026#34;) 5public class TestFeedMidServiceStep { 6 ...... 7} 或者自定义一个注解类CucumberStepsDefinition\n1package com.weibo.ad.bp.st.ryujo.web.test.step; 2 3import org.springframework.boot.test.context.SpringBootTest; 4import org.springframework.test.context.ActiveProfiles; 5import org.springframework.test.context.ContextConfiguration; 6 7import java.lang.annotation.ElementType; 8import java.lang.annotation.Retention; 9import java.lang.annotation.RetentionPolicy; 10import java.lang.annotation.Target; 11 12@Target(ElementType.TYPE) 13@Retention(RetentionPolicy.RUNTIME) 14@ContextConfiguration 15@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) 16@ActiveProfiles(\u0026#34;test\u0026#34;) 17public @interface CucumberStepsDefinition { 18} 然后在每个 step 类上加上该注解：\n1@Slf4j 2@CucumberStepsDefinition 3public class TestFeedMidServiceStep { 4 ...... 5} 这种方法的优点是简单，基本上很多网上的示例代码都是这样写的，但是如果有多个 step 类的时候，在运行测试的时候，会多次初始化 spring 容器。而且还会抛出 WARN 信息。\n于是就有了第二种方法。\n方法二：\n参考 https://github.com/cucumber/cucumber-jvm/issues/1420#issuecomment-405258386\n在glue指定的包路径下新建一个CucumberContextConfiguration类\n1package com.weibo.ad.bp.st.ryujo.web.test.step; 2 3import cucumber.api.java.Before; 4import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc; 5import org.springframework.boot.test.context.SpringBootTest; 6import org.springframework.test.context.ActiveProfiles; 7 8@ActiveProfiles(\u0026#34;test\u0026#34;) 9@SpringBootTest 10@AutoConfigureMockMvc 11public class CucumberContextConfiguration { 12 13 @Before 14 public void setup_cucumber_spring_context(){ 15 // Dummy method so cucumber will recognize this class as glue 16 // and use its context configuration. 17 } 18} 注意这里用的@Before注解是cucumber.api.java.Before，如果用错了，是不起作用的。\n然后我们就可以正常的实现 step 类了，而且可以直接使用@Autowired来注入 spring 管理的 bean.\n运行测试 1mvn clean test 或者使用 IDE 的话，直接点击RunCucumberTest类上的按钮即可。\n补充说明 IDEA 建议安装 Cucumber for java 插件。https://plugins.jetbrains.com/plugin/7212-cucumber-for-java\n中文支持 Cucumber 本身支持超过 30 种语言（此处语言是 Spoken Language 而非 Programming Language）。查看其所有支持的语言和对应的关键字可以访问https://github.com/cucumber/cucumber/blob/master/gherkin/gherkin-languages.json\n下面我们来使用中文来描述一个 feature。\n1# language: zh-CN 2@base 3功能: 测试计算器 4 5 场景大纲: 两个整数的四则运算 6 假如 我们有两个整数\u0026lt;a\u0026gt;和\u0026lt;b\u0026gt; 7 当 我们将其求和运算 8 那么 我们能得到数值 \u0026lt;c\u0026gt; 9 例子: 10 11 | a | b | c | 12 | 1 | 2 | 3 | 13 | 2 | 5 | 7 | 首先第一行我们使用# language: zh-CN来说明我们使用的是中文，这样安装了 cucumber 插件的 IDE 也会有相应的关键字提示和语法高亮。\n然后编写 step\n1package cn.iliubang.exercises.bdd.test.glue; 2 3import cucumber.api.java.zh_cn.假如; 4import cucumber.api.java.zh_cn.当; 5import cucumber.api.java.zh_cn.那么; 6import org.junit.Assert; 7 8public class Test1 { 9 10 private Integer a; 11 private Integer b; 12 private Integer c; 13 14 @假如(\u0026#34;我们有两个整数{int}和{int}\u0026#34;) 15 public void 我们有两个整数_和(Integer int1, Integer int2) { 16 a = int1; 17 b = int2; 18 } 19 20 @当(\u0026#34;我们将其求和运算\u0026#34;) 21 public void 我们将其求和运算() { 22 c = a + b; 23 } 24 25 @那么(\u0026#34;我们能得到数值 {int}\u0026#34;) 26 public void 我们能得到数值(Integer int1) { 27 Assert.assertEquals(int1, c); 28 } 29} 这里很神奇的是，连注解都是中文的。最后是编写启动文件，这里不再赘述。运行的结果如下：\n指定 Cucumber 运行结果报告 Cucumber 本身支持多种报告格式以适用于不同环境下调用的报告输出：\npretty ：用于在命令行环境下执行 Cucumber 测试用例所产生的报告，如果您的 console 支持，pretty 形式的报告还可以按照颜色显示不同的运行结果；如下图所示的例子分别显示了用例执行通过和用例没有 Steps definitions 的输出报告： json ：多用于在持续集成环境下的跨机器生成报告时使用，比如在用例执行的机器 A 上运行 Cucumber 测试用例，而在调度或报告机器 B 上生成用例执行报告，此时只需要把生成的 JSON 报告传输到机器 B 上即可。 1[ 2 { 3 \u0026#34;line\u0026#34;: 3, 4 \u0026#34;elements\u0026#34;: [ 5 { 6 \u0026#34;line\u0026#34;: 12, 7 \u0026#34;name\u0026#34;: \u0026#34;两个整数的四则运算\u0026#34;, 8 \u0026#34;description\u0026#34;: \u0026#34;\u0026#34;, 9 \u0026#34;id\u0026#34;: \u0026#34;测试计算器;两个整数的四则运算;;2\u0026#34;, 10 \u0026#34;type\u0026#34;: \u0026#34;scenario\u0026#34;, 11 \u0026#34;keyword\u0026#34;: \u0026#34;场景大纲\u0026#34;, 12 \u0026#34;steps\u0026#34;: [ 13 { 14 \u0026#34;result\u0026#34;: { 15 \u0026#34;duration\u0026#34;: 3204397, 16 \u0026#34;status\u0026#34;: \u0026#34;passed\u0026#34; 17 }, 18 \u0026#34;line\u0026#34;: 6, 19 \u0026#34;name\u0026#34;: \u0026#34;我们有两个整数1和2\u0026#34;, 20 \u0026#34;match\u0026#34;: { 21 \u0026#34;arguments\u0026#34;: [ 22 { 23 \u0026#34;val\u0026#34;: \u0026#34;1\u0026#34;, 24 \u0026#34;offset\u0026#34;: 7 25 }, 26 { 27 \u0026#34;val\u0026#34;: \u0026#34;2\u0026#34;, 28 \u0026#34;offset\u0026#34;: 9 29 } 30 ], 31 \u0026#34;location\u0026#34;: \u0026#34;Test1.我们有两个整数_和(Integer,Integer)\u0026#34; 32 }, 33 \u0026#34;keyword\u0026#34;: \u0026#34;假如\u0026#34; 34 }, 35 { 36 \u0026#34;result\u0026#34;: { 37 \u0026#34;duration\u0026#34;: 110745, 38 \u0026#34;status\u0026#34;: \u0026#34;passed\u0026#34; 39 }, 40 \u0026#34;line\u0026#34;: 7, 41 \u0026#34;name\u0026#34;: \u0026#34;我们将其求和运算\u0026#34;, 42 \u0026#34;match\u0026#34;: { 43 \u0026#34;location\u0026#34;: \u0026#34;Test1.我们将其求和运算()\u0026#34; 44 }, 45 \u0026#34;keyword\u0026#34;: \u0026#34;当\u0026#34; 46 }, 47 { 48 \u0026#34;result\u0026#34;: { 49 \u0026#34;duration\u0026#34;: 1611672, 50 \u0026#34;status\u0026#34;: \u0026#34;passed\u0026#34; 51 }, 52 \u0026#34;line\u0026#34;: 8, 53 \u0026#34;name\u0026#34;: \u0026#34;我们能得到数值 3\u0026#34;, 54 \u0026#34;match\u0026#34;: { 55 \u0026#34;arguments\u0026#34;: [ 56 { 57 \u0026#34;val\u0026#34;: \u0026#34;3\u0026#34;, 58 \u0026#34;offset\u0026#34;: 8 59 } 60 ], 61 \u0026#34;location\u0026#34;: \u0026#34;Test1.我们能得到数值(Integer)\u0026#34; 62 }, 63 \u0026#34;keyword\u0026#34;: \u0026#34;那么\u0026#34; 64 } 65 ], 66 \u0026#34;tags\u0026#34;: [ 67 { 68 \u0026#34;name\u0026#34;: \u0026#34;@base\u0026#34; 69 } 70 ] 71 }, 72 { 73 \u0026#34;line\u0026#34;: 13, 74 \u0026#34;name\u0026#34;: \u0026#34;两个整数的四则运算\u0026#34;, 75 \u0026#34;description\u0026#34;: \u0026#34;\u0026#34;, 76 \u0026#34;id\u0026#34;: \u0026#34;测试计算器;两个整数的四则运算;;3\u0026#34;, 77 \u0026#34;type\u0026#34;: \u0026#34;scenario\u0026#34;, 78 \u0026#34;keyword\u0026#34;: \u0026#34;场景大纲\u0026#34;, 79 \u0026#34;steps\u0026#34;: [ 80 { 81 \u0026#34;result\u0026#34;: { 82 \u0026#34;duration\u0026#34;: 779875, 83 \u0026#34;status\u0026#34;: \u0026#34;passed\u0026#34; 84 }, 85 \u0026#34;line\u0026#34;: 6, 86 \u0026#34;name\u0026#34;: \u0026#34;我们有两个整数2和5\u0026#34;, 87 \u0026#34;match\u0026#34;: { 88 \u0026#34;arguments\u0026#34;: [ 89 { 90 \u0026#34;val\u0026#34;: \u0026#34;2\u0026#34;, 91 \u0026#34;offset\u0026#34;: 7 92 }, 93 { 94 \u0026#34;val\u0026#34;: \u0026#34;5\u0026#34;, 95 \u0026#34;offset\u0026#34;: 9 96 } 97 ], 98 \u0026#34;location\u0026#34;: \u0026#34;Test1.我们有两个整数_和(Integer,Integer)\u0026#34; 99 }, 100 \u0026#34;keyword\u0026#34;: \u0026#34;假如\u0026#34; 101 }, 102 { 103 \u0026#34;result\u0026#34;: { 104 \u0026#34;duration\u0026#34;: 472993, 105 \u0026#34;status\u0026#34;: \u0026#34;passed\u0026#34; 106 }, 107 \u0026#34;line\u0026#34;: 7, 108 \u0026#34;name\u0026#34;: \u0026#34;我们将其求和运算\u0026#34;, 109 \u0026#34;match\u0026#34;: { 110 \u0026#34;location\u0026#34;: \u0026#34;Test1.我们将其求和运算()\u0026#34; 111 }, 112 \u0026#34;keyword\u0026#34;: \u0026#34;当\u0026#34; 113 }, 114 { 115 \u0026#34;result\u0026#34;: { 116 \u0026#34;duration\u0026#34;: 199326, 117 \u0026#34;status\u0026#34;: \u0026#34;passed\u0026#34; 118 }, 119 \u0026#34;line\u0026#34;: 8, 120 \u0026#34;name\u0026#34;: \u0026#34;我们能得到数值 7\u0026#34;, 121 \u0026#34;match\u0026#34;: { 122 \u0026#34;arguments\u0026#34;: [ 123 { 124 \u0026#34;val\u0026#34;: \u0026#34;7\u0026#34;, 125 \u0026#34;offset\u0026#34;: 8 126 } 127 ], 128 \u0026#34;location\u0026#34;: \u0026#34;Test1.我们能得到数值(Integer)\u0026#34; 129 }, 130 \u0026#34;keyword\u0026#34;: \u0026#34;那么\u0026#34; 131 } 132 ], 133 \u0026#34;tags\u0026#34;: [ 134 { 135 \u0026#34;name\u0026#34;: \u0026#34;@base\u0026#34; 136 } 137 ] 138 } 139 ], 140 \u0026#34;name\u0026#34;: \u0026#34;测试计算器\u0026#34;, 141 \u0026#34;description\u0026#34;: \u0026#34;\u0026#34;, 142 \u0026#34;id\u0026#34;: \u0026#34;测试计算器\u0026#34;, 143 \u0026#34;keyword\u0026#34;: \u0026#34;功能\u0026#34;, 144 \u0026#34;uri\u0026#34;: \u0026#34;classpath:features/test_1.feature\u0026#34;, 145 \u0026#34;tags\u0026#34;: [ 146 { 147 \u0026#34;name\u0026#34;: \u0026#34;@base\u0026#34;, 148 \u0026#34;type\u0026#34;: \u0026#34;Tag\u0026#34;, 149 \u0026#34;location\u0026#34;: { 150 \u0026#34;line\u0026#34;: 2, 151 \u0026#34;column\u0026#34;: 1 152 } 153 } 154 ] 155 } 156] html ：用于生成简单的 HTML 格式的报告以便查看 Cucumber 测试用例运行的结果 junit ：用于生成 JUnit 格式的报告： 1\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; standalone=\u0026#34;no\u0026#34;?\u0026gt; 2\u0026lt;testsuite failures=\u0026#34;0\u0026#34; name=\u0026#34;cucumber.runtime.formatter.JUnitFormatter\u0026#34; skipped=\u0026#34;0\u0026#34; tests=\u0026#34;2\u0026#34; time=\u0026#34;0.028641\u0026#34;\u0026gt; 3\u0026lt;testcase classname=\u0026#34;测试计算器\u0026#34; name=\u0026#34;两个整数的四则运算\u0026#34; time=\u0026#34;0.022812\u0026#34;\u0026gt; 4\u0026lt;system-out\u0026gt;\u0026lt;![CDATA[假如我们有两个整数1和2................................................................passed 5当我们将其求和运算...................................................................passed 6那么我们能得到数值 3.................................................................passed 7]]\u0026gt;\u0026lt;/system-out\u0026gt; 8\u0026lt;/testcase\u0026gt; 9\u0026lt;testcase classname=\u0026#34;测试计算器\u0026#34; name=\u0026#34;两个整数的四则运算_2\u0026#34; time=\u0026#34;0.005829\u0026#34;\u0026gt; 10\u0026lt;system-out\u0026gt;\u0026lt;![CDATA[假如我们有两个整数2和5................................................................passed 11当我们将其求和运算...................................................................passed 12那么我们能得到数值 7.................................................................passed 13]]\u0026gt;\u0026lt;/system-out\u0026gt; 14\u0026lt;/testcase\u0026gt; 15\u0026lt;/testsuite\u0026gt; 此外，Github 上有很多开源的插件或者 Cucumber 扩展可以帮助从 JSON 格式的报告生成 HTML 格式的报告。这里推荐大家使用 Cucumber-reporting。Cucumber-reporting 不仅能够完成从 JSON 格式报告生成 HTML 格式报告，而且可以按照 tag 和 feature 以及 step 查看，不得不提的是生成的 HTML 格式报告的样式非常好看，下面就是以本文中所使用的 feature 文件为例，以 Cucumber-reporting 来生成的 HTML 报告：\n","date":"March 15, 2019","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/java/2019-03-15-spring_boot_with_bdd/","series":[],"smallImg":"","tags":[{"title":"Java","url":"/blog/tags/java/"},{"title":"SpringBoot","url":"/blog/tags/springboot/"},{"title":"BDD","url":"/blog/tags/bdd/"}],"timestamp":1552608000,"title":"Spring Boot With BDD"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"Programming","url":"/blog/categories/programming/"}],"content":" 开始之前 这篇文章主要是为了帮助大家熟悉 POSIX 线程库以及在实际开发中使用它的特性。我们会具体讲解如何利用这个线程库定义的不同工具 来解决编程中的问题。当然这里隐含了一个假设，就是读者已经了解过并行编程（或者多进程）的相关概念，如果没有这些背景知识 的话，读者可能会感觉到很难理解。不过也没关系，我的另一篇教程里边有专门为只具备线性编程思维的读者提供了对并行编程理论 和相关术语的讲解。\n同样的，我假设聪明的你已经熟悉了异步编程模型，那些经常使用桌面环境的人会更容易去接受多线程编程的理念。\n当我们谈到 POSIX 线程的时候，肯定会有人心生疑惑：“我们应该使用哪个标准下的 POSIX 线程？”。由于 POSIX 线程标准已经修订了好 多年，人们会发现，依据不同标准的实现有不同的函数集，不同的默认值和不同的细微差别。所以在此说明的是，本教程使用的是 v0.5 版的 Linux 内核中的线程库，使用其他操作系统和使用其他版本的读者，需要阅读一下你们对应的系统文档来同本文中的实例进行对应。同时，有些示例代码中使用到了阻塞式的系统调用，它们不能再用户级的线程库中很好的工作（参考另一篇文章：parallel programming theory tutorial 来获取详细信息）。好了，说了那么多，主要是为了能保证文章中的示例代码能够在其他系统中正常使用，从而提高跨平台性。\n什么是线程？为什么要使用线程？ 线程是一个迷你版的进程，它们拥有自己的栈，能够执行给定的一段代码。但是不同于进程的是，线程通常与其他线程共享记忆体（而 每个进程都拥有一个独立的记忆体区域）。一个线程组就是一个执行相同代码的线程的集合，他们共用记忆体，可以访问相同的全局变 量，拥有同样的文件描述符等等，他们以并行的方式执行（可能是时间片的方式，或者对于多核心系统，他们会真正平行执行）。\n使用线程组而不是普通顺序执行程序的好处是多个操作可以同时进行，当一些事件产生的时候，他们能立马被处理（例如：如果我们有 一个线程处理用户接口，另一个线程处理数据库查询，那么我们可以在处理很多用户查询的同时，依然能够响应用户的输入）。\n使用线程组而不是进程组的好处是线程间的上下文切换要比进程间的上下文切换要快很多（上下文切换是指系统从一个正在运行的线程或进程切换到去执行另一个线程或进程）。此外，线程间的通信也远远比进程间通信要高效很多。\n线程编程有利也有弊，由于线程组共享记忆体，如果一个线程破坏了记忆体，那么其他线程也要受到牵连。但是进程就不同了，操作系 统会将进程之间隔离开，如果一个进程破坏了它的记忆体，那么其他进程不会受到影响。使用进程的另一个好处是，不同的进程可以运 行在不同的机器上，但是线程必须运行在同一台机器上（至少通常情况下是这样的）。\n创建和销毁线程 当一个多线程程序启动执行到main()函数的时候，就会有一个线程运行，这是一个全程线程（full-fledged thread，或者叫主线程），如果想创建一个新的线程，程序中需要使用pthread_create()函数\n1#include \u0026lt;stdio.h\u0026gt; 2#include \u0026lt;pthread.h\u0026gt; 3 4void *do_loop(void *data) 5{ 6 int i; // counter, to print numbers 7 int j; // counter, for delay 8 int me = *((int *)data); 9 for (i = 0; i \u0026lt; 10; i++) { 10 for (j = 0; j \u0026lt; 50000; j++) // delay loop 11 ; 12 printf(\u0026#34;\u0026#39;%d\u0026#39; - Got \u0026#39;%d\u0026#39;\\n\u0026#34;, me, i); 13 } 14 15 // terminate the thread 16 pthread_exit(NULL); 17} 18 19int main(int argc, char *argv[]) 20{ 21 int thr_id; // thread ID for the newly created thread 22 pthread_t p_thread; // thread\u0026#39;s structure 23 int a = 1; // thread 1 identifying number 24 int b = 2; // thread 2 identifying number 25 26 // create a new thread that will execute \u0026#39;do_loop()\u0026#39; 27 thr_id = pthread_create(\u0026amp;p_thread, NULL, do_loop, (void *)\u0026amp;a); 28 29 // run \u0026#39;do_loop\u0026#39; in the main thread as well 30 do_loop((void *)\u0026amp;b); 31 32 return 0; 33} 上述这段代码需要特殊说明的是：\n因为执行 main 函数的也是一个线程，所以它在执行do_loop()函数的时候跟它创建的线程是并行的； pthread_create()函数接收 4 个参数。第一个是提供该线程的相关信息，第二个是用来定义线程的属性，在上面的示例代码中，我 们使用 NULL 来表示使用默认的值，第三个参数是传递一个函数来给线程执行，第四个参数是传递给要执行函数的参数。 在函数内部使用一个空的循环只是为了演示线程的并行执行。如果你的 CPU 足够快，导致你看到一个线程输出前都是同一个线程的输出，那就把空循环的次数改的更大一些。 调用pthread_exit()会使当前线程退出，同时释放当前线程占有的私有资源。在线程执行函数的末尾其实是没有必要显示调用这个函数的，因为当函数返回的时候，这个线程自动就会退出。当我们想要退出一个执行中的线程的时候就会非常有用。 使用 gcc 编译多线程程序的时候，我们需要链接 pthread 库。确定你的系统中已经安装了线程库，下面是如何编译我们的第一个示例程序：\n1gcc pthread_create.c -o pthread_create -lpthread 用互斥同步线程 使用多线程遇到的基本问题是确保他们不会相互踩到脚，这里指的是在不同的线程中使用同一个数据结构。\n例如：假设有两个线程想要修改两个变量。一个线程想将他们都改为 0，另一个想改为 1.如果两个线程同时执行，我们可能会得到这样 的结果：一个变量是 1，而另一个是 0.造成这种结果的原因是上下文切换可能会发生在第一个线程将第一个变量设置为 0 之后，此时第二个线程将两个变量都设置为 1，然后第一个线程恢复执行，将第二个变量设置为 0，这样就会导致第一个变量为 1，第二个变量为 0 的结果。\n什么是互斥？ 线程库中针对上述问题提供的一个基本的解决方案就是互斥。\n创建和初始化一个互斥锁 要创建一个互斥锁，我们首先要申明一个pthread_mutex_t类型的变量，然后再对其进行初始化。最简单的方法就是将它赋值为PTHREAD_MUTEX_INITIALIZER 常量。形如以下代码：\n1pthread_mutex_t a_mutex = PTHREAD_MUTEX_INITIALIZER; 这里需要说明的是：用这种方式创建的互斥锁称为“快速互斥锁”，也就是说，如果一个线程已经获得了一个互斥锁的前提下尝试重新获得 这个锁，那么他就会卡死，形成死锁。\n还有另一种被称为“可重入锁”的互斥锁，它能够允许线程多次获取锁而不会发生阻塞。如果这个线程释放了锁，那么它将继续持有锁，直 到它做了通获取锁相同次数的释放锁操作为止。这种锁可以使用常量PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP来初始化。\n获取和释放互斥锁 想要获取互斥锁，我们需要使用pthread_mutex_lock()函数，该函数尝试获取一把锁，或者当该锁已经被其他线程持有的时候阻塞当 前线程，这种情况下，当前面的线程释放锁的时候，改函数会返回锁给当前的线程。下面是如何获取锁的操作（假设我们已经事先初始化过了）：\n1int rc = pthread_mutex_lock(\u0026amp;a_mutex); 2if (rc) { 3 /* an error has occurred */ 4 perror(\u0026#34;pthread_mutex_lock\u0026#34;); 5 pthread_exit(NULL); 6} 7 8/* mutex is now locked - do your stuff. */ 当线程完成了相关操作（修改变量或数据结构，处理文件或其他的事情），它需要释放锁，此时需要使用pthread_mutex_unlock()函数 ，就像下面这样：\n1rc = pthread_mutex_unlock(\u0026amp;a_mutex); 2if (rc) { 3 perror(\u0026#34;pthread_mutex_unlock\u0026#34;); 4 pthread_exit(NULL); 5} 销毁一个互斥锁 当我们使用完一把锁之后，我们需要对他进行销毁操作。完成使用是指再没有线程需要使用它了，如果只有一个线程不再使用了，而其它 线程还需要使用，那么就不能销毁。销毁互斥锁需要使用到pthread_mutex_destroy()函数：\n1rc = pthread_mutex_destroy(\u0026amp;a_mutex); 销毁完之后，变量a_mutex就不能再被用于锁操作了，除非它再次被初始化。也就是说，如果销毁太早，后续还有线程尝试获取或释放 锁，那么该线程会从调用 lock 或者 unlock 的函数得到一个EINVAL的错误。\n使用互斥锁——一个完整的例子 我们已经知道了一个互斥锁的完整的生命周期，那么让我们来看一个使用互斥锁的完整程序。程序会产生两个员工来竞争\u0026quot;employee of the day\u0026quot;的荣耀。我们将会创建 3 个线程，一个用来让 Danny 获得\u0026quot;employee of the day\u0026quot;的荣誉，另一个让 Moshe 获得，第三个负责确保只有一个人获得。这里提供两份代码，一个使用了互斥锁，另一个没有使用。运行这些程序，观察他们的区别，你会发现互斥锁对于多线程环境 编程是非常重要的。\n1#include \u0026lt;stdio.h\u0026gt; 2#include \u0026lt;pthread.h\u0026gt; 3 4#define num_employees 2 5 6/* global mutex for out program. assignment initializes it */ 7pthread_mutex_t a_mutex = pthread_mutex_initializer; 8 9struct employee { 10 int number; 11 int id; 12 char first_name[20]; 13 char last_name[20]; 14 char department[30]; 15 int room_number; 16}; 17 18/* global variable - our employee array, with 2 employees */ 19struct employee employees[] = { 20 { 1, 12345678, \u0026#34;danny\u0026#34;, \u0026#34;cohen\u0026#34;, \u0026#34;accounting\u0026#34;, 101 }, 21 { 2, 87654321, \u0026#34;moshe\u0026#34;, \u0026#34;levy\u0026#34;, \u0026#34;programmers\u0026#34;, 202 }, 22}; 23 24/* global variable - employee of the day. */ 25struct employee employee_of_the_day; 26 27void copy_employee(struct employee *from, struct employee *to) 28{ 29 int rc; /* contain mutex lock/unlock results */ 30 31 /* lock the mutex, to assure exclusive access to \u0026#39;a\u0026#39; and \u0026#39;b\u0026#39;. */ 32 rc = pthread_mutex_lock(\u0026amp;a_mutex); 33 34 to-\u0026gt;number = from-\u0026gt;number; 35 to-\u0026gt;id = from-\u0026gt;id; 36 strcpy(to-\u0026gt;first_name, from-\u0026gt;first_name); 37 strcpy(to-\u0026gt;last_name, from-\u0026gt;last_name); 38 strcpy(to-\u0026gt;department, from-\u0026gt;department); 39 to-\u0026gt;room_number = from-\u0026gt;room_number; 40 41 /* unlock mutex */ 42 rc = pthread_mutex_unlock(\u0026amp;a_mutex); 43} 44 45 46void *do_loop(void *data) 47{ 48 int my_num = *((int *)data); 49 while (1) { 50 /* set employee of the day to be the one with number \u0026#39;my_num\u0026#39;. */ 51 copy_employee(\u0026amp;employees[my_num - 1], \u0026amp;employee_of_the_day); 52 } 53} 54 55int main(int argc, char *argv[]) 56{ 57 int i; /* loop counter */ 58 int thr_id1; /* thread id for the first new thread */ 59 int thr_id2; /* thread id for the second new thread */ 60 pthread_t p_thread1; /* first thread\u0026#39;s structure */ 61 pthread_t p_thread2; /* second thread\u0026#39;s structure */ 62 int num1 = 1; /* thread 1 employee number */ 63 int num2 = 2; /* thread 2 employee number */ 64 struct employee eotd; /* local copy of \u0026#39;employee of the day\u0026#39; */ 65 struct employee *worker; /* pointer to currently checked employee */ 66 67 /* initialize employee of the day to first 1. */ 68 copy_employee(\u0026amp;employees[0], \u0026amp;employee_of_the_day); 69 70 /* create a new thread that will execute \u0026#39;do_loop\u0026#39; with 1 */ 71 thr_id1 = pthread_create(\u0026amp;p_thread1, null, do_loop, (void *)\u0026amp;num1); 72 73 /* create a new thread that will execute \u0026#39;do_loop\u0026#39; with 2 */ 74 thr_id2 = pthread_create(\u0026amp;p_thread2, null, do_loop, (void *)\u0026amp;num2); 75 76 /* run a loop that verfies integrity of \u0026#39;employee of the day\u0026#39; many */ 77 for (i = 0; i \u0026lt; 6000; i++) { 78 copy_employee(\u0026amp;employee_of_the_day, \u0026amp;eotd); 79 worker = \u0026amp;employees[eotd.number - 1]; 80 81 if (eotd.id != worker-\u0026gt;id) { 82 printf(\u0026#34;mismatching \u0026#39;id\u0026#39;, %d != %d (loop \u0026#39;%d\u0026#39;)\\n\u0026#34;, eotd.id, worker-\u0026gt;id, i); 83 exit(0); 84 } 85 86 if (strcmp(eotd.first_name, worker-\u0026gt;first_name) != 0) { 87 printf(\u0026#34;mismatching \u0026#39;first_name\u0026#39;, %s != %s (loop \u0026#39;%d\u0026#39;)\\n\u0026#34;, eotd.first_name, worker-\u0026gt;first_name, i); 88 exit(0); 89 } 90 91 if (strcmp(eotd.last_name, worker-\u0026gt;last_name) != 0) { 92 printf(\u0026#34;mismatching \u0026#39;last_name\u0026#39;, %s != %s (loop \u0026#39;%d\u0026#39;)\\n\u0026#34;, eotd.last_name, worker-\u0026gt;last_name, i); 93 exit(0); 94 } 95 96 if (strcmp(eotd.department, worker-\u0026gt;department) !=0) { 97 printf(\u0026#34;mismatching \u0026#39;department\u0026#39;, %s != %s (loop \u0026#39;%d\u0026#39;)\\n\u0026#34;, eotd.department, worker-\u0026gt;department, i); 98 exit(0); 99 } 100 101 if (eotd.room_number != worker-\u0026gt;room_number) { 102 printf(\u0026#34;mismatching \u0026#39;room_number\u0026#39;, %d != %d (loop \u0026#39;%d\u0026#39;)\\n\u0026#34;, eotd.room_number, worker-\u0026gt;room_number, i); 103 exit(0); 104 } 105 } 106 107 printf(\u0026#34;glory, employees contents was always consistent\\n\u0026#34;); 108 return 0; 109} 饥饿和死锁 特别需要我们注意的是，由于pthread_mutex_lock()持有锁的时间不确定，当一个线程长时间持有一把锁的时候，其他线程就会产生“饥饿”——因为这些线程一直无法获取资源。然而线程库无法帮助我们避免这种情况的发生，需要我们自己来保证。\n线程库也可能会产生“死锁”。所谓的死锁就是多个线程相互等待其他线程释放锁，以获取资源。通常情况下，如果所有线程都阻塞在等待其他线程释放锁，那么它们将不会自己恢复到执行状态。幸运的是，线程库会检测这种情况，当发生死锁的时候，线程库会在最后一个线程调用pthread_mutex_lock()的时候返回一个EDEADLK的错误。我们在开发的时候需要对这种错误采取措施，以避免死锁的发生。\n精简同步——条件变量 通过上面对互斥锁的描述我们了解到，互斥能够实现一些简单的线程交互——互斥的访问资源。然而，我们经常需要在线程间使用真正的异步。\n在一个服务器程序中，一个线程从客户端接收请求，然后分发给其他线程去处理请求。这些处理请求的线程需要在数据到达的时候能够被唤醒，否的它们需要处于等待状态，而且不会占用 CPU 时间 在一个 GUI 应用中，有一个线程用于读取用户的输入，另一个线程处理图形界面的渲染，第三个线程用于发送请求到服务端并且处理服务端的响应。处理服务端响应的线程在接收到服务端响应的时候需要能够通知图形渲染线程立即将服务端响应的结果渲染出来呈现给用户。读取用户输入的线程需要实时对用户的操作做出响应，例如允许用户取消服务端处理线程的一个长时间操作。 以上例子都需要线程间必须具备相互通信的能力，这就需要使用到条件变量。\n什么是条件变量 条件变量是一种允许线程等待某些事件发生的机制。多个线程可能会等待一个条件变量，直到其他线程给这个条件变量发送信号。此时，会有一个线程会被唤醒，然后来处理这个事件。也可以通过广播的形式唤醒所有等待该条件变量的线程。\n由于条件变量不提供锁，也就是说我们需要对条件变量单独使用互斥锁，来提供必要的访问控制。\n创建和初始化条件变量 创建一个条件变量需要定义一个类型为pthread_cond_t的变量，然后正确的对其进行初始化。初始化条件变量可以简单的用一个叫做PTHREAD_COND_INITIALIZER的宏，也可以通过调用pthread_cond_init()函数。我们这里使用宏来初始化：\n1pthread_cond_t got_request = PTHREAD_COND_INITIALIZER; 上述代码就定义并初始化了一个名为got_request的条件变量。\n注意：由于PTHREAD_COND_INITIALIZER实际上是一个结构体，只能在条件变量被定义的时候用它来初始化。如果想在运行时对条件变量进行初始化，就只能使用pthread_cond_init()函数了。\n给条件变量发送信号 我们可以使用pthread_cond_signal()函数来给条件变量发送信号，以唤其中一个等待该条件变量的线程，或者使用pthread_cond_broadcast()函数来唤醒所有等待该条件变量的线程。下面是使用示例：\n1int rc = pthread_cond_signal(\u0026amp;got_request); 2 3// or 4 5int rc = pthread_cond_broadcast(\u0026amp;got_request); 当函数返回后，\u0026lsquo;rc\u0026rsquo;等于 0 表示执行成功，否则失败。返回值代表了错误的类型，EINVAL表示传递的参数不是一个条件变量，ENOMEM表示系统内存溢出了。\n注意：成功发送信号并不代表一定有等待的线程被唤醒，因为有可能该条件变量压根就没有被任何线程等待，这种情况下，发送信号就不会做任何事情。如果一个线程在一次信号发送后开始等待该条件变量，那么需要再次发送信号才能唤醒该线程。\n等待一个条件变量 如果一个线程发送信号给条件变量，而其他线程可能想要等待该条件变量，那么就需要使用到pthread_cond_wait()或者pthread_cond_timedwait()中的其中一个。这两个函数都接收一个条件变量和一个互斥锁作为参数，当 wait 函数执行的时候会释放锁，然后等待条件变量，并将线程挂起。如果有信号唤醒了这个线程，wait 函数会自动重新获取锁，然后返回。\n这两个函数的唯一区别是pthread_cond_timedwait()允许我们指定一个等待的超时时间，当超过这个时间，函数就会立即返回一个ETIMEDOUT的错误，来告诉我们程序在超时时间内没有，条件变量没有获取到信号。而pthread_cond_wait()在条件变量获取到信号前会一直等待。\n下面是代码示例，我们假设got_request是一个经过正确初始化的条件变量，request_mutex是一个经过正确初始化的锁，我们来尝试使用pthread_cond_wait()函数：\n1/* first, lock the mutex */ 2int rc = pthread_mutex_lock(\u0026amp;request_mutex); 3if (rc) { /* an error has occurred */ 4 perror(\u0026#34;pthread_mutex_lock\u0026#34;); 5 pthread_exit(NULL); 6} 7 8/* mutex is now locked - wait on the condition variable */ 9/* During the execution of pthread_cond_wait, the mutex is unlocked */ 10rc = pthread_cond_wait(\u0026amp;got_request, \u0026amp;request_mutex); 11if (rc == 0) { /* we were awakened due to the cond. variable being signaled */ 12 /* The mutex is now locked again by pthread_cond_wait() */ 13 /* do your stuff... */ 14} 15 16/* finally, unlock the mutex */ 17pthread_mutex_unlock(\u0026amp;request_mutex); 下面我们来使用pthread_cond_timedwait()函数：\n1#include \u0026lt;sys/time.h\u0026gt; /* struct timeval definition */ 2#include \u0026lt;unistd.h\u0026gt; /* declaration of gettimeofday() */ 3 4struct timeval now; /* time when we started waiting. */ 5struct timespec timeout; /* timeout value for the wait function */ 6int done; /* are we done waiting? */ 7 8/* first, lock the mutex */ 9int rc = pthread_mutex_lock(\u0026amp;request_mutex); 10if (rc) { /* an error has occurred. */ 11 perror(\u0026#34;pthread_mutex_lock\u0026#34;); 12 pthread_exit(NULL); 13} 14 15/* mutex is now locked */ 16 17/* get current time */ 18gettimeofday(\u0026amp;now); 19/* prepare timeout value */ 20timeout.tv_sec = now.tv_sec + 5; 21timeout.tv_nsec = now.tv_usec * 1000; /* timeval uses microseconds. */ 22 /* timespec uses nanoseconds. */ 23 /* 1 nanosecond = 1000 micro seconds. */ 24 25/* wait on the condition variable. */ 26/* we use a loop, since a Unix signal might stop the wait before the timeout. */ 27done = 0; 28while (!done) { 29 /* remember that pthread_cond_timedwait() unlocks the mutex on entrance */ 30 rc = pthread_cond_timedwait(\u0026amp;got_request, \u0026amp;request_mutex, \u0026amp;timeout); 31 switch (rc) { 32 case 0: /* we were awakened due to the cond. variable being signaled */ 33 /* the mutex was now locked again by pthread_cond_timedwait. */ 34 /* do your stuff here... */ 35 done = 0; 36 break; 37 case ETIMEDOUT: /* our time is up */ 38 done = 0; 39 break; 40 default: /* some error occurred (e.g. we got a Unix signal) */ 41 break; /* break this switch, but re-do the while loop. */ 42 } 43} 44 45/* finally, unlock the mutex */ 46pthread_mutex_unlock(\u0026amp;request_mutex); 正如你所看到的，使用 timed wait 的方式更加复杂一些，最好能够将其封装成一个函数，而不是在必要的地方一直写重复的代码。\n销毁一个条件变量 当我们用完一个条件变量后，我们需要将它销毁，以释放它占用的系统资源。完成这个操作就需要使用pthread_cond_destroy()函数。 而在销毁之前，一定要确保没有线程等待该条件变量：\n1int rc = pthread_cond_destroy(\u0026amp;got_request); 2if (rc == EBUSY) { /* some thread is still waiting on this condition variable */ 3 /* handle this case here ... */ 4} 当还有线程正在等待该条件变量的时候该怎么办呢？这个要视情况而定，它可能意味着我们对这个条件变量的使用存在缺陷，或者缺少合适的 清理线程的代码。这对程序开发者来说是一个很好的提示，至少在程序调试的时候。它可能不能说明任何问题，但是却很重要。\n对条件变量的条件检查 在这里需要对条件变量特别说明的是——如果没有结合一些实际的条件检查，它们的存在通常是毫无意义的。为了解释清楚，我们拿前面说的那个服务端程序的例子来说明。假设我们使用got_request这个条件变量来发送请求到来时需要被处理的信号，然后将其放入请求队列里边。如果有线程正在等待这个条件变量，那么我们可以肯定至少有一个线程会被唤醒来处理这个请求。\n然而，假如当一个新的请求到来时，所有线程恰好都正在处理之前的请求呢？此时发送给这个条件变量的信号不会做任何操作（因为所有的线程都在忙于处理之前的请求，没有线程等待该条件变量），当这些线程完成手头上的工作后，就会回来继续等待，而该条件变量不会再次发送信号（例如，没有新的请求到来），此时，至少有一个请求一直处于等待状态，而所有的处理线程都阻塞在等待信号上而无法处理。\n为了解决上面的问题，我们需要设置一些整数变量来表示正在等待处理的请求数，然后在每个线程等待条件变量之前检查一下这个变量的值，如果是正数，说明有一些请求正等待处理，然后该线程就需要去先处理完请求，然后再进入休眠，此外，一个线程处理完一个请求后，需要将这个数值减 1，一定要确保数值的准确性。 下面我们来用代码实现以下：\n1/* number of pending requests, initially none. */ 2int num_requests = 0; 3 4/* first, lock the mutex */ 5int rc = pthread_mutex_lock(\u0026amp;a_mutex); 6if (rc) { /* an error has occurred */ 7 perror(\u0026#34;pthread_mutex_lock\u0026#34;); 8 pthread_exit(NULL); 9} 10 11/* mutex is now locked - wait on the condition variable */ 12/* if there are no requests to be handled. */ 13rc = 0; 14if (num_requests == 0) { 15 rc = pthread_cond_wait(\u0026amp;got_request, \u0026amp;a_mutex); 16} 17 18if (num_requests \u0026gt; 0 \u0026amp;\u0026amp; rc == 0) { /* we have a request pending. */ 19 /* do your stuff... */ 20 21 /* decrease count of pending requests */ 22 num_requests--; 23} 24 25/* finally, unlock the mutex */ 26pthread_mutex_unlock(\u0026amp;a_mutex); 使用条件变量的完整示例 为了能够更好的说明条件变量的用法，我们用前面描述的服务端程序的例子来做一个完整示例。\n1#include \u0026lt;stdio.h\u0026gt; 2#define __USE_GNU 3#include \u0026lt;pthread.h\u0026gt; 4#include \u0026lt;stdlib.h\u0026gt; 5 6#define NUM_HANDLER_THREADS 3 7 8/* global mutex for our program. assignment initializes it. */ 9/* note that we use a RECURSIVE mutex, since a handler thread might try to lock 10 * it twice consecutively. */ 11pthread_mutex_t request_mutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP; 12 13/* global condition variable for our program. assignment initializes it. */ 14pthread_cond_t got_request = PTHREAD_COND_INITIALIZER; 15 16/* number for pending requests, initially none. */ 17int num_requests = 0; 18 19/* format of a single request. */ 20struct request { 21 int number; /* number of the request */ 22 struct request *next; /* pointer to next request, NULL if none. */ 23}; 24 25/* head of linked list of requests. */ 26struct request *requests = NULL; 27/* pointer to last request */ 28struct request *last_request = NULL; 29 30void add_request(int request_num, pthread_mutex_t *p_mutex, 31 pthread_cond_t *p_cond_var) { 32 /* return code of pthreads functions. */ 33 int rc; 34 35 /* pointer to newly added request */ 36 struct request *a_request; 37 38 a_request = (struct request *)malloc(sizeof(struct request)); 39 if (!a_request) { 40 fprintf(stderr, \u0026#34;add_request: out of memory\\n\u0026#34;); 41 exit(1); 42 } 43 44 a_request-\u0026gt;number = request_num; 45 a_request-\u0026gt;next = NULL; 46 47 /* lock the mutex, to assure exclusive access to the list */ 48 rc = pthread_mutex_lock(p_mutex); 49 50 /* add new request to the end of the list, updating list */ 51 /* pointers as required */ 52 if (num_requests == 0) { 53 requests = a_request; 54 last_request = a_request; 55 } else { 56 last_request-\u0026gt;next = a_request; 57 last_request = a_request; 58 } 59 60 num_requests++; 61 62#ifdef DEBUG 63 printf(\u0026#34;add_request: added request with id \u0026#39;%d\u0026#39;\\n\u0026#34;, a_request-\u0026gt;number); 64 fflush(stdout); 65#endif 66 67 /* unlock mutex */ 68 rc = pthread_mutex_unlock(p_mutex); 69 70 /* signal the condition variable - there\u0026#39;s a new request to handle */ 71 rc = pthread_cond_signal(p_cond_var); 72} 73 74struct request *get_request(pthread_mutex_t *p_mutex) { 75 int rc; 76 struct request *a_request; 77 78 rc = pthread_mutex_lock(p_mutex); 79 80 if (num_requests \u0026gt; 0) { 81 a_request = requests; 82 requests = a_request-\u0026gt;next; 83 84 if (requests == NULL) { 85 last_request = NULL; 86 } 87 num_requests--; 88 } else { 89 a_request = NULL; 90 } 91 92 /* unlock mutex */ 93 rc = pthread_mutex_unlock(p_mutex); 94 95 return a_request; 96} 97 98void handle_request(struct request *a_request, int thread_id) { 99 if (a_request) { 100 printf(\u0026#34;Thread \u0026#39;%d\u0026#39; handled request \u0026#39;%d\u0026#39;\\n\u0026#34;, thread_id, 101 a_request-\u0026gt;number); 102 fflush(stdout); 103 } 104} 105 106void handle_requests_loop(void *data) { 107 int rc; 108 struct request *a_request; 109 int thread_id = *((int *)data); 110 111#ifdef DEBUG 112 printf(\u0026#34;Starting thread \u0026#39;%d\u0026#39;\\n\u0026#34;, thread_id); 113 fflush(stdout); 114#endif 115 116 /* lock the mutex, to access the requests list exclusively. */ 117 rc = pthread_mutex_lock(\u0026amp;request_mutex); 118 119#ifdef DEBUG 120 printf(\u0026#34;thread \u0026#39;%d\u0026#39; after pthread_mutex_lock\\n\u0026#34;, thread_id); 121 fflush(stdout); 122#endif 123 124 /* do forever... */ 125 while (1) { 126#ifdef DEBUG 127 printf(\u0026#34;thread \u0026#39;%d\u0026#39;, number_requests = %d\\n\u0026#34;, thread_id, num_requests); 128 fflush(stdout); 129#endif 130 if (num_requests \u0026gt; 0) { 131 a_request = get_request(\u0026amp;request_mutex); 132 if (a_request) { 133 handle_request(a_request, thread_id); 134 free(a_request); 135 } 136 } else { 137#ifdef DEBUG 138 printf(\u0026#34;thread \u0026#39;%d\u0026#39; before pthread_cond_wait\\n\u0026#34;, thread_id); 139 fflush(stdout); 140#endif 141 rc = pthread_cond_wait(\u0026amp;got_request, \u0026amp;request_mutex); 142 143#ifdef DEBUG 144 printf(\u0026#34;thread \u0026#39;%d\u0026#39; after pthread_cond_wait\\n\u0026#34;, thread_id); 145 fflush(stdout); 146#endif 147 } 148 } 149} 150 151int main(int argc, char *argv[]) { 152 int i; 153 int thr_id[NUM_HANDLER_THREADS]; 154 pthread_t p_threads[NUM_HANDLER_THREADS]; 155 struct timespec delay; 156 157 /* create the request-handling threads */ 158 for (i = 0; i \u0026lt; NUM_HANDLER_THREADS; i++) { 159 thr_id[i] = i; 160 pthread_create(\u0026amp;p_threads[i], NULL, handle_requests_loop, 161 (void *)\u0026amp;thr_id[i]); 162 } 163 164 sleep(3); 165 166 /* run a loop that generates requests */ 167 for (i = 0; i \u0026lt; 600; i++) { 168 add_request(i, \u0026amp;request_mutex, \u0026amp;got_request); 169 if (rand() \u0026gt; 3 * (RAND_MAX / 4)) { 170 delay.tv_sec = 0; 171 delay.tv_nsec = 10; 172 nanosleep(\u0026amp;delay, NULL); 173 } 174 } 175 176 sleep(5); 177 printf(\u0026#34;Glory, we are done.\\n\u0026#34;); 178 179 return 0; 180} ","date":"December 5, 2018","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/sp/2018-12-05-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/","series":[],"smallImg":"","tags":[{"title":"C","url":"/blog/tags/c/"},{"title":"Sp","url":"/blog/tags/sp/"}],"timestamp":1543968000,"title":"多线程编程"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"Programming","url":"/blog/categories/programming/"}],"content":"原文地址：http://nikic.github.io/2014/02/18/Fast-request-routing-using-regular-expressions.html\n前一些日子，我发现了一个叫做Pux的路由库，这个路由库声称自己比现有的路由要快很多，为了实现这个特点，该库使用了 C 语言编写了 PHP 扩展。\n然而，当我瞅了几眼它的代码后，我非常怀疑这个库在路由过程中做了错误的优化，而且我能够很容易在不适用扩展的情况下做出更高性能的实现。 当我在看了 benchmarking 代码后更加确定了我的怀疑，因为我发现这里仅仅只是对及其确定的单个路由做了测试。\n为了进一步研究这个问题，我写了一个轻量的路由库：FastRoute。这个库中实现的分发过程接下来我会具体描述。为了给出一些前期印象，这里先给出一个 同 Pux 库的 benchmark 结果：\n11 placeholder | Pux (no ext) | Pux (ext) | FastRoute 2----------------------------------------------------- 3First route | 0.17 s | 0.13 s | 0.14 s 4Last route | 2.51 s | 1.20 s | 0.49 s 5Unknown route | 2.34 s | 1.10 s | 0.34 s 6 79 placeholders | Pux (no ext) | Pux (ext) | FastRoute 8----------------------------------------------------- 9First route | 0.22 s | 0.19 s | 0.20 s 10Last route | 2.65 s | 1.78 s | 0.59 s 11Unknown route | 2.50 s | 1.49 s | 0.40 s 这个 benchmark 使用了 100 个路由，分别对最好和最坏的情况做了测试。而且分两个方面进行：一个是只包含一个占位符的路由，另一个是包含 9 个占位符的路由。整个过程 重复了上千次。\n在进入到正式的主题之前，让我再强调最后一点：这篇文章表面上是关于路由的，但是我真正想聊得是一般的基于正则 表达式的调度过程。从某种程度上说，这是对我之前写的\u0026quot;lexing performance in PHP\u0026ldquo;的重复。\n关于路由的问题 为了确保我们没有跑题，让我们首先来定义一下“路由”。在大多数实现形式中，它是类似于如下形式的一系列过程：\n1$r-\u0026gt;addRoute(\u0026#39;GET\u0026#39;, \u0026#39;/usr/{name}/{id:\\d+}\u0026#39;, \u0026#39;handler0\u0026#39;); 2$r-\u0026gt;addRoute(\u0026#39;GET\u0026#39;, \u0026#39;/user/{id:\\d+}\u0026#39;, \u0026#39;handler1\u0026#39;); 3$r-\u0026gt;addRoute(\u0026#39;GET\u0026#39;, \u0026#39;/user/{name}\u0026#39;, \u0026#39;handler2\u0026#39;); 接着像下面这样分发 URI:\n1$d-\u0026gt;dispatch(\u0026#39;GET\u0026#39;, \u0026#39;/user/nikic/42\u0026#39;); 2// =\u0026gt; provides \u0026#39;handler0\u0026#39; and [\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;nikic\u0026#39;, \u0026#39;id\u0026#39; =\u0026gt; \u0026#39;42\u0026#39;] 为了达到更高的抽象度，我们会使用 HTTP Method 和一些特定的格式来定义路由，在这篇文章中，我唯一要阐述的是在分发层面上，路由是如何被解析的，而关于分发的数据是如何 生成的将不会做深入说明。\n那么，在路由过程中，慢的地方在哪呢？在一个大型设计的系统中很可能会生成几十个对象，调用几百个方法。Pux 在减少这种开销上做了很伟大的工作。但是，在更基础的层面上， 路由分发过程中导致开销大的因素是一系列几十个或几百个甚至几千个路由正则来跟现有的 URI 做匹配。如何让他变得更快是本文将要讨论的话题。\n组合正则 优化的基本思想是避免一个个进行正则匹配，而是将这些正则合并成一个大正则，这样就只需要匹配一次，我们用前面的例子来说，组合正则如下：\n1Individual regexes: 2 3 ~^/user/([^/]+)/(\\d+)$~ 4 ~^/user/(\\d+)$~ 5 ~^/user/([^/]+)$~ 6 7Combined regex: 8 9 ~^(?: 10 /user/([^/]+)/(\\d+) 11 | /user/(\\d+) 12 | /user/([^/]+) 13 )$~x\u0026lt;Paste\u0026gt; 转换起来非常简单，只需要将所有的单个正则用 OR 连接起来。当与该正则匹配的时候，如何确定是哪个路由匹配上了呢？为此，让我们来看看简单的preg_match执行的结果：\n1preg_match($regex, \u0026#39;/user/nikic\u0026#39;, $matches); 2=\u0026gt; [ 3 \u0026#34;/user/nikic\u0026#34;, # full match 4 \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, # groups from first route (empty) 5 \u0026#34;\u0026#34;, # groups from second route (empty) 6 \u0026#34;nikic\u0026#34;, # groups from third route (used!) 7] 所以，技巧就是在$matches数组中找到第一个不为空的元素。为了能够使用匹配的结果，你还需要一个额外的数据结构来映射$matches索引到匹配的路由\n1[ 2 1 =\u0026gt; [\u0026#39;handler0\u0026#39;, [\u0026#39;name\u0026#39;, \u0026#39;id\u0026#39;]], 3 3 =\u0026gt; [\u0026#39;handler1\u0026#39;, [\u0026#39;id\u0026#39;]], 4 4 =\u0026gt; [\u0026#39;handler2\u0026#39;, [\u0026#39;name\u0026#39;]], 5] 下面是一个简单的实现：\n1public function dispatch($uri) { 2 if (!preg_match($this-\u0026gt;regex, $uri, $matches)) { 3 return [self::NOT_FOUND]; 4 } 5 6 // find first non-empty match (skipping full match) 7 for ($i = 1; \u0026#39;\u0026#39; === $matches[$i]; ++$i); 8 9 list($handler, $varNames) = $this-\u0026gt;routeData[$i]; 10 11 $vars = []; 12 foreach ($varNames as $varName) { 13 $vars[$varName] = $matches[$i++]; 14 } 15 return [self::FOUND, $handler, $vars]; 16} 当我们找到第一个不为空的元素下标$i后，占位符变量就能够通过继续移动$matches数组下标计算出来，并且跟 变量名进行关联。\n这么简单的方法到底有多好呢？下面是跟 Pux（c 扩展）对比的结果：\n11 placeholder | Pux (ext) | GPB-NC 2----------------------------------- 3First route | 0.13 s | 0.20 s 4Last route | 1.20 s | 0.70 s 5Unknown route | 1.10 s | 0.16 s 6 79 placeholders | Pux (ext) | GPB-NC 8----------------------------------- 9First route | 0.19 s | 0.41 s 10Last route | 1.78 s | 4.09 s 11Unknown route | 1.49 s | 0.30 s GPB-NC 表示的是\u0026quot;Group Position based, non-chunked\u0026quot;分发。接下来你就会明白这个术语的含义。正如你所看到的，这个方法在单个路由的时候 表现出很高的性能，当然在第一次路由的情况下它还稍逊色于 C 扩展实现，但是在 last route 和没有匹配路由的情况下，它比 c 扩展要更快一些。\n当我们注意到有 9 个占位符的路由时，情况就不那么乐观了：在 last route 的情况下，它要比 c 扩展慢两倍，而另一方面，在没有匹配到路由的情况下依然表现很好的性能。 为什么会这样呢？\n这背后的原因是（至少我假设是）在编译正则表达式的过程中，包含了大量的捕获组调用：100 个路由，每个路由有 9 个占位符，那么你会得到 900 个组，如果路由没有匹配到，$matches不需要计算， 所以调用很快，如果第一个路由匹配上了，PCRE 只计算与该路由相关的匹配（也就是 9 个元素组合一个全匹配）。但是如果是最后一个路由匹配上的话，PCRE 不仅仅要计算最后一个路由，而且还要计算前面所有的路由包含的组。\n所以，我们需要做的就是减少正则组的数量。\n重置组数量 PCRE 正则语法中有一个比较少见的特性，就是(?|...，不捕获组类型。(?:和(?|的区别就是后者能在正则的每个分支上重置组数量。为了更好的说明它的含义，我们来看下面的例子：\n1preg_match(\u0026#39;~(?:(Sat)ur|(Sun))day~\u0026#39;, \u0026#39;Saturday\u0026#39;, $matches) 2=\u0026gt; [\u0026#34;Saturday\u0026#34;, \u0026#34;Sat\u0026#34;, \u0026#34;\u0026#34;] # The last \u0026#34;\u0026#34; is not actually in the $matches array, but that\u0026#39;s just 3 # an implementation detail. I\u0026#39;m writing it here to clarify the concept. 4 5preg_match(\u0026#39;~(?:(Sat)ur|(Sun))day~\u0026#39;, \u0026#39;Sunday\u0026#39;, $matches) 6=\u0026gt; [\u0026#34;Sunday\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;Sun\u0026#34;] 7 8preg_match(\u0026#39;~(?|(Sat)ur|(Sun))day~\u0026#39;, \u0026#39;Saturday\u0026#39;, $matches) 9=\u0026gt; [\u0026#34;Saturday\u0026#34;, \u0026#34;Sat\u0026#34;] 10 11preg_match(\u0026#39;~(?|(Sat)ur|(Sun))day~\u0026#39;, \u0026#39;Sunday\u0026#39;, $matches) 12=\u0026gt; [\u0026#34;Sunday\u0026#34;, \u0026#34;Sun\u0026#34;] 当使用(?:的时候，PCRE 会把Sat和Sun两个组分开匹配，每一个组都有一个唯一的下标。(Sat)是 1，(Sun)是 2。\n在子组定义的左括号后面紧跟字符串 ”?:” 会使得该子组不被单独捕获， 并且不会对其后子组序号的计算产生影响。比如, 如果字符串 \u0026ldquo;the white queen\u0026rdquo; 匹配模��the ((?:red|white) (king|queen))，匹配到的子串是 \u0026ldquo;white queen\u0026rdquo; 和 \u0026ldquo;queen\u0026rdquo;， 他们的下标分别是 1 和 2。\n有时需要多个匹配可以在一个正则表达式中选用子组。 为了让多个子组可以共用一个后向引用数字的问题， (?| 语法允许复制数字。 考虑下面的正则表达式匹配 Sunday： (?:(Sat)ur|(Sun))day 这里当后向引用 1 空时 Sun 存储在后向引用 2 中. 当后向引用 2 不存在的时候 Sat 存储在后向引用 1 中。 使用(?|修改模式来修复这个问题： (?|(Sat)ur|(Sun))day, 使用这个模式， Sun 和 Sat 都会被存储到后向引用 1 中。\n这就给我们提供了解决路由匹配中“太多子组”问题的方法。只需要将(?:替换成(?|:\n1~^(?| 2 /user/([^/]+)/(\\d+) 3 | /user/(\\d+) 4 | /user/([^/]+) 5)$~x 然而，现在组下标被重置了，我们不能确定到底是哪个路由被匹配上。前面我们是使用第一个不为空的下标，而现在下标被重置后，第一个不为空的元素永远都是$matches[1]。\n聪明的你们也许会想到给每一个子组取一个名字，从而通过名字来看到底是哪个路由被匹配上了：\n1~^(?| 2 (?\u0026lt;route1\u0026gt; /user/([^/]+)/(\\d+) ) 3 | (?\u0026lt;route2\u0026gt; /user/(\\d+) ) 4 | (?\u0026lt;route3\u0026gt; /user/([^/]+) ) 5)$~x 但是，这在 PCRE 中是不被允许的：内部命名组的实现是通过映射子模式名到组下标，然后将其作为一个普通的，无名组。 也就是说上述的正则表达式\u0026lt;route1\u0026gt;, \u0026lt;route2\u0026gt;和\u0026lt;route3\u0026gt;都关联了同一个下标 1，这是没有意义的。\n一个有效的方法是考虑匹配组的数量。上面给出的三个路由中，第一个路由会产生一个包含 3 个元素的$matches数组，第二个路由会产生 2 个元素。\n那么，我们使用$matches的长度来确定匹配的路由是不准确的，但是我们可以很容易通过添加无用的组来调整正则：\n1~^(?| 2 /user/([^/]+)/(\\d+) 3 | /user/(\\d+)()() 4 | /user/([^/]+)()()() 5)$~x 现在，第一个路由有两个组（产生 3 个元素），第二个路由有三个组（产生 4 个元素），第三个路由有四个组（产生 5 个元素）。如此以来，分发可以被表达成如下格式的一个数组：\n1[ 2\t3 =\u0026gt; [\u0026#39;handler0\u0026#39;, [\u0026#39;name\u0026#39;, \u0026#39;id\u0026#39;]], 3 4 =\u0026gt; [\u0026#39;handler1\u0026#39;, [\u0026#39;id\u0026#39;]], 4 5 =\u0026gt; [\u0026#39;handler2\u0026#39;, [\u0026#39;name\u0026#39;]], 5] 下面是一个简单的实现：\n1public function dispatch($uri) { 2 if (!preg_match($this-\u0026gt;regex, $uri, $matches)) { 3 return [self::NOT_FOUND]; 4 } 5 6 list($handler, $varNames) = $this-\u0026gt;routeData[count($matches)]; 7 8 $vars = []; 9 $i = 0; 10 foreach ($varNames as $varName) { 11 $vars[$varName] = $matches[++$i]; 12 } 13 return [self::FOUND, $handler, $vars]; 14} 让我们再来看一下之前的对比：\n11 placeholder | Pux (ext) | GPB-NC | GCB-NC 2-------------------------------------------- 3First route | 0.13 s | 0.20 s | 0.60 s 4Last route | 1.20 s | 0.70 s | 1.06 s 5Unknown route | 1.10 s | 0.16 s | 0.56 s 6 79 placeholders | Pux (ext) | GPB-NC | GCB-NC 8-------------------------------------------- 9First route | 0.19 s | 0.41 s | 0.65 s 10Last route | 1.78 s | 4.09 s | 0.96 s 11Unknown route | 1.49 s | 0.30 s | 0.54 s GPB 和 GCB(the Geoup Count Based)方法都是 Non-Chunked。很显然的是，GCB 很好的解决了 GPB 中的性能瓶颈，但是在其他情况下的性能却有所降低。\n这是为什么呢？我认为这是由于增大的正则表达式和子组数量导致的。我们来具体分析一下：100 个路由我们需要生成$99 * 100 / 2 = 4950$个无用的子组，这会产生 $4950 * 2 = 9900$额外字节，也即是将近 10KB 的开销。\n你可以看一下 100 个包含 9 个占位符的正则长啥样：generated regular expression:\n1|/cv/([^/]+)/([^/]+)/([^/]+)/([^/]+)/([^/]+)/([^/]+)/([^/]+)/([^/]+)/([^/]+) 2()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()() 3()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()() 4()()()()()()()()()()()()()()()()()()()()()()())$~ （这看起来多像 LISP 代码呀！）\n分块正则表达式 由于填充的空子组数量随着路由数量呈现指数级增长，这种方法并不能被广泛应用。另一种减少填充空子组数量的方法是 将正则表达式分割成两个部分：一部分匹配前 50 个路由，另一部分匹配剩下的 50 个。每一个部分只需要$49 * 50 / 2 = 1225$个填充空子组， 也就是总共有 2450 个子组，这样就远远少于 4950 个。如果路由被分割成 10 个部分，那么每个部分只需要$9 * 10 / 2 = 45$个空子组，也就是总共 只需要 450 个。\n下面是一个简单实现：\n1public function dispatch($uri) { 2 foreach ($this-\u0026gt;regexes as $i =\u0026gt; $regex) { 3 if (!preg_match($regex, $uri, $matches)) { 4 continue; 5 } 6 7 list($handler, $varNames) = $this-\u0026gt;routeData[$i][count($matches)]; 8 9 $vars = []; 10 $i = 0; 11 foreach ($varNames as $varName) { 12 $vars[$varName] = $matches[++$i]; 13 } 14 return [self::FOUND, $handler, $vars]; 15 } 16 17 return [self::NOT_FOUND]; 18} 下面是 10 个分块的性能测试：\n11 placeholder | GCB-NC | GCB-10C 2--------------------------------- 3First route | 0.60 s | 0.14 s 4Last route | 1.06 s | 0.49 s 5Unknown route | 0.56 s | 0.34 s 6 79 placeholders | GCB-NC | GCB-10C 8--------------------------------- 9First route | 0.65 s | 0.20 s 10Last route | 0.96 s | 0.59 s 11Unknown route | 0.54 s | 0.40 s 显然，使用 10 个分块的方式在每种情况下都战胜了没有分块的情况，甚至有些时候有 2 到 3 倍的性能提升。\n总结 ","date":"April 16, 2018","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/php/2018-04-16-%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E9%AB%98%E6%80%A7%E8%83%BD%E8%B7%AF%E7%94%B1/","series":[],"smallImg":"","tags":[{"title":"Php","url":"/blog/tags/php/"}],"timestamp":1523836800,"title":"使用正则表达式开发一个高性能路由"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"Programming","url":"/blog/categories/programming/"}],"content":" 1. C++标准库 C++提供了很多库：\n标准 ANSI C 库都可以移植到 C++中。不同于 ANSI C 库的是，C++中需要在库名前加上\u0026quot;c\u0026quot;前缀，而且去掉\u0026quot;.h\u0026quot;，例如\u0026lt;cmath\u0026gt;对应于 C 语言就是\u0026lt;math.h\u0026gt;，\u0026lt;cstdlib\u0026gt;对应于 C 语言的\u0026lt;stlib.h\u0026gt; C++新增的库，例如 \u0026lt;iostream\u0026gt;，\u0026lt;iomanip\u0026gt;，\u0026lt;string\u0026gt;，\u0026lt;fstream\u0026gt;，\u0026lt;sstream\u0026gt; C++STL：包括容器，迭代器，算法和函数对象 Boost C++库 1.1 C 库和相关头文件 \u0026lt;cstring\u0026gt;：待会解释 \u0026lt;cmath\u0026gt;：数学计算相关的库 \u0026lt;cstdlib\u0026gt;：通用工具，例如异常（abort, exit, EXIT_SUCCESS, EXIT_FAILURE）；环境相关（getenv）；动态内存管理（malloc, free, calloc, realloc），字符解析（atoi, atof, atol, strtod）， 伪随机序列生成（rand, srand, RAND_MAX）；数组搜索和排序（bsearch, qsort） \u0026lt;cctype\u0026gt;：字符类型检测（isalpha, isdigit, isalnum, isspace, isupper, islower, isblank, iscntrl, isgraph, isprint, ispunct, isxdigit）和字符转换（toupper, tolower） \u0026lt;climits\u0026gt;, \u0026lt;cfloat\u0026gt;：Size and limit of integer types (INT_MAX, INT_MIN, UINT_MAX, CHAR_BIT; and SHRT_XXX for short, LONG_XXX for long, LLONG_XXX for long long, CHAR_XXX for char) and floating-point types (DBL_MIN, DBL_MAX, DBL_DIG, DBL_MIN_EXP, DBL_MAX_EXP; and FLT_XXX for float, LDBL_XXX for long double) \u0026lt;ctime\u0026gt;：time, difftime, clock, gmttime, localtime, and etc. \u0026lt;cstdio\u0026gt;: C\u0026rsquo;s IO operations (scanf, printf, fscanf, fprintf, fopen, fclose, etc) \u0026lt;cassert\u0026gt;, \u0026lt;cerrno\u0026gt;, csignal\u0026gt;: 断言和错误 \u0026lt;clocale\u0026gt;：本地化 \u0026lt;cstdbool\u0026gt;, \u0026lt;cstdint\u0026gt;, \u0026lt;cstddef\u0026gt;, \u0026lt;cstdarg\u0026gt;: \u0026lt;cuchar\u0026gt;, \u0026lt;cwchar\u0026gt;, \u0026lt;cwcchar\u0026gt;: Unicode 字符 1.2 C++库和相关头文件 \u0026lt;ios\u0026gt;, \u0026lt;iostream\u0026gt;, \u0026lt;istream\u0026gt;, \u0026lt;ostream\u0026gt;, \u0026lt;fstream\u0026gt;, \u0026lt;sstream\u0026gt; \u0026lt;iomanip\u0026gt; \u0026lt;string\u0026gt; \u0026lt;regex\u0026gt; \u0026lt;random\u0026gt; \u0026lt;limits\u0026gt; \u0026lt;stdexception\u0026gt;, \u0026lt;exception\u0026gt; \u0026lt;complex\u0026gt;, \u0026lt;tuple\u0026gt;, \u0026lt;valarry\u0026gt; \u0026lt;locale\u0026gt; \u0026lt;typeinfo\u0026gt; \u0026lt;chrono\u0026gt; 其它：\u0026lt;codecvt\u0026gt;, \u0026lt;new\u0026gt;, \u0026lt;ratio\u0026gt;, \u0026lt;system_error\u0026gt;, \u0026lt;type_traits\u0026gt; 1.3 C++ STL 和相关头文件 STL 主要由以下头文件提供：\n\u0026lt;vector\u0026gt;, \u0026lt;list\u0026gt;, \u0026lt;deque\u0026gt;, \u0026lt;queue\u0026gt;, \u0026lt;stack\u0026gt;, \u0026lt;map\u0026gt;, \u0026lt;set\u0026gt;, \u0026lt;bitset\u0026gt;, \u0026lt;forward_list\u0026gt; (C++11), \u0026lt;unordered_map\u0026gt; (C++11), \u0026lt;unordered_set\u0026gt; (C++11), \u0026lt;array\u0026gt; (C++11)：容器和数据结构模板类 \u0026lt;iterator\u0026gt;：迭代器 \u0026lt;algorithm\u0026gt;, \u0026lt;numeric\u0026gt;, \u0026lt;functional\u0026gt;, \u0026lt;utility\u0026gt;：算法和函数对象 \u0026lt;initializer_list\u0026gt; (C++11), \u0026lt;memroy\u0026gt; (C++11) 1.4 Boost C++库 TODO 2. C++ STL 2.1 初探 C++ STL 中的 vector 类 示例 1：构造vector\u0026lt;\u0026gt;和访问元素\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026lt;cstdlib\u0026gt; 3#include \u0026lt;ctime\u0026gt; 4#include \u0026lt;vector\u0026gt; 5 6using namespace std; 7 8 9void print(const vector\u0026lt;int\u0026gt; \u0026amp;v) { 10\tfor (int i = 0; i \u0026lt; v.size(); ++i) { 11\tcout \u0026lt;\u0026lt; v[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 12\t} 13\tcout \u0026lt;\u0026lt; endl; 14} 15 16int main(int argc, char *argv[]) { 17\tconst int SIZE = 10; 18\tvector\u0026lt;int\u0026gt; numbers(SIZE); 19 20\tcout \u0026lt;\u0026lt; \u0026#34;size = \u0026#34; \u0026lt;\u0026lt; numbers.size() \u0026lt;\u0026lt; endl; 21\tcout \u0026lt;\u0026lt; \u0026#34;capacity = \u0026#34; \u0026lt;\u0026lt; numbers.capacity() \u0026lt;\u0026lt; endl; 22\tprint(numbers); 23 24\tsrand(time(0)); 25 26\tfor (size_t i = 0; i \u0026lt; numbers.size(); ++i) { 27\tnumbers.at(i) = rand() % 100; 28\t} 29 30\tprint(numbers); 31 32\t// no error compile and run 33\tcout \u0026lt;\u0026lt; \u0026#34;First element is \u0026#34; \u0026lt;\u0026lt; numbers.front() \u0026lt;\u0026lt; endl; 34\t// runtime out_of_range exception 35\tcout \u0026lt;\u0026lt; \u0026#34;Last element is \u0026#34; \u0026lt;\u0026lt; numbers.back() \u0026lt;\u0026lt; endl; 36 37\tcout \u0026lt;\u0026lt; numbers[55] \u0026lt;\u0026lt; endl; 38\t// cout \u0026lt;\u0026lt; numbers.at(55) \u0026lt;\u0026lt; endl; 39 40\treturn 0; 41} 特别说明：\nsize 是当前 vector 容器真实占用的大小，也就是容器当前拥有多少个容器。\ncapacity 是指在发生 realloc 前能允许的最大元素数，即预分配的内存空间。\n示例 2：使用push_back()和pop_back()来添加和删除元素\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026lt;cstdlib\u0026gt; 3#include \u0026lt;ctime\u0026gt; 4#include \u0026lt;vector\u0026gt; 5 6using namespace std; 7 8void print(const vector\u0026lt;int\u0026gt; \u0026amp;v) { 9\tfor (int i = 0; i \u0026lt; v.size(); ++i) { 10\tcout \u0026lt;\u0026lt; v[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 11\t} 12\tcout \u0026lt;\u0026lt; endl; 13} 14 15int main(int argc, char *argv[]) { 16\tvector\u0026lt;int\u0026gt; numbers; 17\tcout \u0026lt;\u0026lt; \u0026#34;size = \u0026#34; \u0026lt;\u0026lt; numbers.size() \u0026lt;\u0026lt; endl; 18\tcout \u0026lt;\u0026lt; \u0026#34;capacity = \u0026#34; \u0026lt;\u0026lt; numbers.capacity() \u0026lt;\u0026lt; endl; 19 20\tsrand(time(0)); 21\tfor (int i = 0; i \u0026lt; 5; ++i) { 22\tnumbers.push_back(rand() % 100); 23\t} 24\tprint(numbers); 25\tcout \u0026lt;\u0026lt; \u0026#34;size = \u0026#34; \u0026lt;\u0026lt; numbers.size() \u0026lt;\u0026lt; endl; 26\tcout \u0026lt;\u0026lt; \u0026#34;capacity = \u0026#34; \u0026lt;\u0026lt; numbers.capacity() \u0026lt;\u0026lt; endl; 27 28\tnumbers.pop_back(); 29\tnumbers.pop_back(); 30\tprint(numbers); 31\tcout \u0026lt;\u0026lt; \u0026#34;size = \u0026#34; \u0026lt;\u0026lt; numbers.size() \u0026lt;\u0026lt; endl; 32\tcout \u0026lt;\u0026lt; \u0026#34;capacity = \u0026#34; \u0026lt;\u0026lt; numbers.capacity() \u0026lt;\u0026lt; endl; 33\tnumbers.clear(); 34\tcout \u0026lt;\u0026lt; \u0026#34;size = \u0026#34; \u0026lt;\u0026lt; numbers.size() \u0026lt;\u0026lt; endl; 35\tcout \u0026lt;\u0026lt; \u0026#34;capacity = \u0026#34; \u0026lt;\u0026lt; numbers.capacity() \u0026lt;\u0026lt; endl; 36\treturn 0; 37} 示例 3：使用iterator来访问容器元素\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026lt;string\u0026gt; 3#include \u0026lt;cstdlib\u0026gt; 4#include \u0026lt;vector\u0026gt; 5 6using namespace std; 7 8void print(vector\u0026lt;string\u0026gt; \u0026amp;v) { 9\tfor (vector\u0026lt;string\u0026gt;::iterator iter = v.begin(); iter != v.end(); ++iter) { 10\tcout \u0026lt;\u0026lt; *iter \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 11\t} 12\tcout \u0026lt;\u0026lt; endl; 13} 14 15int main(int argc, char *argv[]) { 16\tvector\u0026lt;string\u0026gt; strs; 17\tstrs.push_back(\u0026#34;apple\u0026#34;); 18\tstrs.push_back(\u0026#34;orange\u0026#34;); 19\tstrs.push_back(\u0026#34;banana\u0026#34;); 20\tprint(strs); 21\tcout \u0026lt;\u0026lt; \u0026#34;size = \u0026#34; \u0026lt;\u0026lt; strs.size() \u0026lt;\u0026lt; endl; 22 23\t// Test insert() 24\tstrs.insert(strs.begin() + 2, \u0026#34;b4-banana\u0026#34;); 25\tstrs.insert(strs.begin() + 1, 2, \u0026#34;b4-orange\u0026#34;); 26\tprint(strs); 27 28\t// Test arase() 29\tstrs.erase(strs.begin() + 1, strs.begin() + 4); 30\tprint(strs); 31\tcout \u0026lt;\u0026lt; \u0026#34;size + \u0026#34; \u0026lt;\u0026lt; strs.size() \u0026lt;\u0026lt; endl; 32 33\t// insert() from another vector 34\tvector\u0026lt;string\u0026gt; newStrs; 35\tnewStrs.push_back(\u0026#34;1\u0026#34;); 36\tnewStrs.push_back(\u0026#34;2\u0026#34;); 37\tnewStrs.push_back(\u0026#34;3\u0026#34;); 38\tstrs.insert(strs.begin() + 1, newStrs.begin(), newStrs.end()); 39\tprint(strs); 40\tcout \u0026lt;\u0026lt; \u0026#34;size = \u0026#34; \u0026lt;\u0026lt; strs.size() \u0026lt;\u0026lt; endl; 41\treturn 0; 42} 说明：\n每一种容器类都有其对应的迭代器 vector的begin()和end()成员函数分别返回一个指向集合第一个元素的iterator和指向最后一个元素后的iterator Iterator 很像指针，可以使用*iter来访问元素，++iter来移动到下一个元素 insert(iter, item)，在当前 iter 元素前插入 item，insert(iter, n , item)，在当前 iter 前插入 n 个 item erase(first, last)，删除区间$[first, last)$中的所有元素 在 C++11 中可以使用auto来作为 iterator 的类型，从而告诉编译器自动匹配类型： 1for (auto iter = strs.begin(); iter != strs.end(); ++iter) { 2\tcout \u0026lt;\u0026lt; *iter \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 3} C++引入了一种 for-each 循环 1for (auto item:strs) { 2\tcout \u0026lt;\u0026lt; item \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 3} 2.2 vector 模板类 Constructor\n1vector (const allocator_type \u0026amp; alloc = allocator_type()); 2 // Default Constructor: construct a vector object 3vector (size_type n, const value_type \u0026amp; val = value_type(), 4 const allocator_type \u0026amp; alloc = allocator_type()); 5 // Fill Constructor: construct a vector object with n-element filled with val 6vector (const vector \u0026amp; v); 7 // Copy Constructor 8template \u0026lt;class InputIterator\u0026gt; 9vector (InputIterator first, InputIterator last, 10 const allocator_type \u0026amp; alloc = allocator_type()); 11 // Range Copy Constructor Size and Capacity\n1size_type size () const; // Return the size (number of elements) 2size_type capacity () const; // Return the storage allocated (in term of element) 3bool empty () const; // Return true if size is 0 4void reserve (size_type n); // Request for storage to hold n elements 5void resize (size_type n, value_type val = value_type()); 6 // resize to n, remove extra element or fill with val 7size_type max_size () const; // Return the maximum number of element 8void shrink_to_fit (); // (C++11) Request to shrink storage Accessing Element\n1value_type \u0026amp; operator[] (size_type n); // [n] operator (without index-bound check) 2value_type \u0026amp; at (size_type n); // Return a reference to n-th element with index-bound check 3value_type \u0026amp; front (); // Return a reference to the first element 4value_type \u0026amp; back (); // Return a reference to the last element Modifying Contents\n1void push_back (const value_type \u0026amp; val); // Append val at the end 2void pop_back (); // Remove the last element 3void clear (); // Remove all elements Non-member Friend Functions\n1==, !=, \u0026lt;, \u0026gt;, \u0026lt;=, \u0026gt;= // Comparison Operators 2// E.g. 3template \u0026lt;class T, class Alloc\u0026gt; 4bool operator== (const vector\u0026lt;T,Alloc\u0026gt; \u0026amp; left, const vector\u0026lt;T, Alloc\u0026gt; \u0026amp; right); 5 // Compare two vectors 6 // For == and !=, first compare the size, then each element with equal algorithm. 7 // Stop at the first mismatch. 8 // For \u0026lt;, \u0026gt;, \u0026lt;=, \u0026gt;=, use lexicographical_compare algorithm. Stop at first mismatch. 9 10template \u0026lt;class T, class Alloc\u0026gt; 11void swap (vector\u0026lt;T,Alloc\u0026gt; \u0026amp; v1, vector\u0026lt;T,Alloc\u0026gt; v2); 12 // Swap the contents of containers v1 and v2. 13 // Both shall has the same type, but can have different sizes. Iterator\n1iterator begin(); // Return an iterator pointing to the first element 2iterator end(); // Return an iterator pointing to the pass-the-end element 3 4reverse_iterator rbegin(); // Return a reverse iterator pointing to the reverse beginning (last element) 5 // increasing a reverse iterator to transverse in reverse order 6reverse_iterator rend(); // Return a reverse iterator pointing to the reverse past-the-end Iterator-based Operations\n1iterator insert (iterator pos, const value_type \u0026amp; val); // Single-Element: insert element val before iterator pos 2void insert (iterator pos, size_type n, const value_type \u0026amp; val); // Fill: insert n copies of val before pos 3template \u0026lt;class InputIterator\u0026gt; 4void insert (iterator pos, InputIterator first, InputIterator last) 5 // Range-copy: copy the range [first, last) and insert before pos. 6 7iterator erase (iterator pos); // Single-element: remove element pointed to by iterator pos 8iterator erase (iterator first, iterator last); // Range: remove elements between [first,last) 9 10void assign (size_type n, const value_type \u0026amp; val); // Fill: clear old contents and assign n copies of val 11template \u0026lt;class InputIterator\u0026gt; 12void assign (InputIterator first, InputIterator last); // Range: assign [first, last) 2.3 容器 顺序型容器，关联型容器和容器适配器\nSTL 提供了以下几种类型的容器：\n顺序型容器：元素是线性结构组织的\nvector: dynamically resizable array. deque: double-ended queue. list: double-linked list. 关联型容器：存储 key-value 对的非线性结构\nset: 没有重复元素，支持快速查找 multiset: 允许重复元素，支持快速查找 map: 一对一隐射（关联数组），没有重复元素，支持快速 key 查找 multimap: 一对一隐射，允许有重复元素，支持快速 key 值查找 容器适配器类：\nStack: 后进先出 queue: 先进先出 priority_queue: 高优先级的位于队列前面 ","date":"March 19, 2018","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/cpp/2018-03-19-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93%E5%92%8Cstl/","series":[],"smallImg":"","tags":[{"title":"C++","url":"/blog/tags/c++/"}],"timestamp":1521417600,"title":"c++编程之标准库和STL"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"Programming","url":"/blog/categories/programming/"}],"content":" 1. 字符 1.1 字符类型库：头文件\"cctype\" 在头文件\u0026lt;cctype\u0026gt;（相当于 C 语言中的\u0026lt;ctype.h\u0026gt;），包含了一下字符处理函数：\nFUNCTION EXAMPLE int isalpha(int ch);//如果 ch 是字母，返回 1，否则 0 int isdigit(int ch);//如果 ch 是数字，返回 1，否则 0 int isalnum(int ch);//如果 ch 是字母或数字，返回 1，否则 0 int isxdigit(int ch);//如果 ch 是十六进制数字[0-9A-Fa-f]，返回 1 int isupper(int ch);//如果 ch 是大写字母，返回 1 int islower(int ch);//如果 ch 是小写字母，返回 1 int toupper(int ch);//转成大写字母 int tolower(int ch);//转成小写 int isspace(int ch); int ispunct(int ch);//是否是标点符号 int iscntrl(int ch);//是否是 control int isprint(int ch);//是否是可打印字符 int isgraph(int ch);//是否图形表示 2. 字符串：C-String 和 string 类 回顾一下，我们知道 C++支持两种类型的字符串：\n一种是 C 语言中的 string，定义在头文件\u0026rsquo;cstring\u0026rsquo;中（相当于 c 中的 string.h）。这种形式是将字符串表示成以\\0结束的字符数组 另一种是 C++中的 string 类，被定义在头文件\u0026rsquo;string\u0026rsquo;中。\u0026lsquo;string\u0026rsquo;是一个定义了一些公共构造函数和成员函数的普通类 2.1 C-String 字面量 一个字符串字面量，例如\u0026quot;hello\u0026quot;，被认为是一个以\\0结束的字符数组，该数组的长度是字符串字面量长度加上结束字符的长度。\n1#include \u0026lt;iostream\u0026gt; 2 3int main(int argc, char *argv[]) { 4\tchar *str1 = \u0026#34;hello\u0026#34;; 5\t// warning: deprecated conversion from string constant to \u0026#39;char *\u0026#39;; 6\tchar *str2 = const_cast\u0026lt;char *\u0026gt;(\u0026#34;hello\u0026#34;); // remove the \u0026#34;const\u0026#34; 7 8\tconst char *str3 = \u0026#34;hello\u0026#34;; 9\t// *(str3 + 1) = \u0026#39;a\u0026#39;; // error: assignment of read-only location \u0026#39;*(str3 + 1)\u0026#39; 10 11\tchar str4[] = \u0026#34;hello\u0026#34;; 12\tstr4[1] = \u0026#39;a\u0026#39;; 13\tconst char str5[] = \u0026#34;hello\u0026#34;; 14\t//str5[1] = \u0026#39;a\u0026#39; // error: assignment of read-only location \u0026#39;str5[1] 15\treturn 0; 16} 2.2 C-String 头文件和函数 C-string 可以被声明为char *或char []。这是因为 C 语言把一个数组的名字当做指向数组第一个元素的指针。不同于普通数组， 在将 C-string 传递给函数的时候，不需要给出数组长度，因为可以根据终结符计算出来。\n定义在头文件中的 C-String 函数\nFUNCTION EXAMPLE size_t strlen (const char * cstr); char * msg = \u0026quot;Hello\u0026quot;; cout \u0026lt;\u0026lt; strlen(msg); // length of string Copying char *strcpy(char *dest, const char *src); char *strncpy(char *desc, char *src, size_t n); Comparison int strcmp(const char *cstr1, const char *cstr2); int strncmp(const char *cstr1, const char *cstr2, size_t n); Concatenation char *strcat(char *dest, const char *src); char *strncat(char *dest, const char *src, size_t n); Searching char *strchr(char *cstr, int ch); char *strrchr(char *cstr, int ch); char *strstr(char *cstr1, char *cstr2); size_t strspn (const char * cstr, const char * accept); char * strpbrk (char * cstr, const char * accept); size_t strcspn (const char * cstr, const char * reject); Tokenizing char * strtok (char * cstr, const char * delim) 定义在头文件中的 C-String 函数\nFUNCTION EXAMPLE int atoi (char * cstr) double atof (char * cstr) long atol (char * cstr) long long atoll (char * cstr) double strtod (const char * cstr, char** endptr) float strtof (const char * cstr, char** endptr) long strtol (const char * cstr, char** endptr) long double strtold (const char * cstr, char** endptr) long long strtoll (const char * cstr, char** endptr) unsigned long long strtoull (const char * cstr, char** endptr) 定义在头文件中的 C-String Input/Output 函数\nFUNCTION EXAMPLE cin \u0026gt;\u0026gt; var char *msg; cin \u0026gt;\u0026gt; msg; cin.getline(char * cstr, unsigned int n); cin.getline(char * cstr, unsigned int n, char delim) char msg[256]; cin.getline(msg, 256); cin.getline(msg, 256, '\\n'); int cin.get() Return the next character, casted as an int. cin.peek() return the next character (casted as an int), but not removing it from the input stream. cin.ignore(unsigned int n = 1, int delim = EOF) Remove n-1 characters from the input stream, or until delimiter is reached. C-string 的大小写转换\n1inline void strtoupper(char *str) { 2\twhile (*str) { 3\t*str = toupper(*str); 4\t++str; 5\t} 6} 2.3 C++中的 string 类 string 类定义在头文件\u0026rsquo;\u0026lsquo;中，属于\u0026rsquo;std\u0026rsquo;命名空间。string 类是 basic_string模板类的一个 char 类型实例：\n1typedef basic_string\u0026lt;char\u0026gt; string; 2typedef basic_string\u0026lt;wchar_t\u0026gt; wstring; string 类的构造器\n1string (); 2 // (1) Default constructor: construct an empty string of length 0. 3string (const string \u0026amp; str); 4 // (2) Copy constructor: construct by copying str (by value) 5string (const string \u0026amp; str, size_t pos, size_t len = npos); 6 // (3) Substring constructor: copy the substring starting at pos, of the len. 7 // size_t is usually typedef to unsigned int 8 // npos is a static constant in string (i.e., string::npos), 9 // which holds the maximum value of size_t. 10string (const char * cstr); 11 // (4) C-string: construct by copying the C-string. 12string (const char * cstr, size_t len); 13 // (5) C-string buffer: construct by copying the cstr for len 14string (size_t len, char c); 15 // (6) Fill Constructor: fill len with char c 16template \u0026lt;class Iterator\u0026gt; 17string (Iterator first, Iterator last); 18 // (7) Iterator: copy the char in [first, last) 19string (initializer_list\u0026lt;char\u0026gt; initList); 20 // (C++11)(8) Initializer list 21string (string \u0026amp;\u0026amp; str) noexcept; 22 // (C++11)(9) Move Constructor 示例：\n1string str1(\u0026#34;apple\u0026#34;); 2string str2 = \u0026#34;orange\u0026#34;; 3// \u0026#39;=\u0026#39; is not an assignment, but an implicit call to string\u0026#39;s 4// constructor str2(\u0026#34;orange\u0026#34;); string 类中的公开函数\n1// Capacity 2size_t size () const; // Return the size of the string 3size_t length () const; // same as above 4 // length() was from earlier version, size() added for compatibility with STL 5bool empty () const; // Return true for empty string 6void clear (); // Clear to empty string 7void resize (size_t n, char pad = \u0026#39;\\0\u0026#39;); // resize the string to length n, 8 // discard trailing characters, or insert pad char 9 10string::npos // static variable for the maximum possible characters in string, 11 // typically max of size_t (unsigned int) 12size_t max_size () const; // Return the maximum size of string object 13size_t capacity () const; // Storage (in terms of characters) currently allocated 14void reserve (size_t n = 0); // Request for minimum of this capacity 15void shrink_to_fit (); ","date":"March 15, 2018","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/cpp/2018-03-15-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/","series":[],"smallImg":"","tags":[{"title":"C++","url":"/blog/tags/c++/"}],"timestamp":1521072000,"title":"c++编程之字符和字符串"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"Programming","url":"/blog/categories/programming/"}],"content":"操作符重载就是指操作符会对不同类型的操作数表现出不同的行为。例如：(a) 按位左移操作符\u0026rsquo;\u0026laquo;\u0026lsquo;在操作流对象的时候就变成了插入操作；(b) *操作符操作于两个数字的时候就是乘法操作，而作用于 地址的时候就是间接寻址操作。C++允许你再用户端扩展操作符重载。\n操作符重载就像函数重载那样，同一个函数名可以因为参数不同而同时存在很多版本。\n1. string 类中重载的操作符 C++的\u0026quot;string\u0026quot;类中重载了以下操作符来作用于\u0026quot;string\u0026quot;对象：\n字符串比较操作(=,!=,\u0026gt;,\u0026lt;,\u0026gt;=,\u0026lt;=)：例如，使用str1 == str2来比较两个\u0026quot;string\u0026quot;对象 流插入和取出操作(\u0026laquo;,\u0026raquo;)：例如，你可以使用cout \u0026lt;\u0026lt; st1和cin \u0026gt;\u0026gt; str2来输出/输入\u0026quot;string\u0026quot;对象 字符串连接(+,+=)：例如，str1 + str2，将两个\u0026quot;string\u0026quot;对象合并成一个新的\u0026quot;string\u0026quot;对象，str1 += str2将str2追加到str1后 字符索引或下标([])：例如，你可以使用str[n]来获取下标为 n 的字符；或者str[n] = c来修改下标为 n 处的字符。需要注意的是\u0026rsquo;[]\u0026lsquo;操作符不会 做边界检测，也就是说，你需要自己保证下标不会超出边界，你可以使用\u0026quot;string\u0026quot;类的at()函数来做边界检测 赋值(=)：例如，str1 = str2，将str2赋值给str1 示例代码：\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026lt;iomanip\u0026gt; 3#include \u0026lt;string\u0026gt; 4 5using namespace std; 6 7int main(int argc, char *argv[]) { 8\tstring msg1(\u0026#34;hello\u0026#34;); 9\tstring msg2(\u0026#34;HELLO\u0026#34;); 10\tstring msg3(\u0026#34;hello\u0026#34;); 11 12\tcout \u0026lt;\u0026lt; boolalpha; 13\tcout \u0026lt;\u0026lt; (msg1 == msg2) \u0026lt;\u0026lt; endl; 14\tcout \u0026lt;\u0026lt; (msg1 == msg3) \u0026lt;\u0026lt; endl; 15\tcout \u0026lt;\u0026lt; (msg1 \u0026lt; msg2) \u0026lt;\u0026lt; endl; 16 17\tstring msg4 = msg1; 18\tcout \u0026lt;\u0026lt; msg4 \u0026lt;\u0026lt; endl; 19 20\tcout \u0026lt;\u0026lt; (msg1 + \u0026#34; \u0026#34; + msg2) \u0026lt;\u0026lt; endl; 21\tmsg3 += msg2; 22 23\tcout \u0026lt;\u0026lt; msg3 \u0026lt;\u0026lt; endl; 24 25\tcout \u0026lt;\u0026lt; msg1[1] \u0026lt;\u0026lt; endl; 26\tcout \u0026lt;\u0026lt; msg1[99] \u0026lt;\u0026lt; endl; 27 28\treturn 0; 29} 2. 用户自定义操作符重载 2.1 “operator\"函数 为了实现操作符重载，我们需要使用一种特殊的函数形式，叫做操作符函数。操作符函数形如：\u0026ldquo;operator Δ()\u0026quot;，Δ 就是将要被重载的操作符。\n1return-type operatorΔ(parameter-list) 例如，operator+()重载了\u0026rdquo;+\u0026ldquo;操作符；operator\u0026lt;\u0026lt;()重载了\u0026rdquo;\u0026laquo;\u0026ldquo;操作符。需要注意的是 Δ 必须是 C++中已经存在的操作符，你不能凭空创造一个新的操作符。\n2.2 示例：重载’+‘操作符，使其成为’Point’类的成员函数 在这个例子中，我们将要重载\u0026rsquo;+\u0026lsquo;操作符，使其能够支持两个\u0026rsquo;Point\u0026rsquo;对象的加法操作。也就是说，我们可以写成p3 = p1 + p2，而p1,p2,p3都是\u0026rsquo;Point\u0026rsquo;对象，就像 普通的数字运算一样，我们需要构造一个新的\u0026rsquo;Point\u0026rsquo;类的实例p3，而且不能改变p1和p2\nPoint.h\n1#ifndef POINT_H_ 2#define POINT_H_ 3 4class Point { 5private: 6\tint x, y; 7public: 8\tPoint(int x = 0, int y = 0); 9\tint getX() const; 10\tint getY() const; 11\tvoid setX(int x); 12\tvoid setY(int y); 13\tvoid print() const; 14\tconst Point opeator+(const Point \u0026amp;rhs) const; 15}; 16 17#endif /* POINT_H_ */ 说明：\n我们通过成员函数operator+()来实现\u0026rsquo;+\u0026lsquo;操作符重载，重载后的操作符会将左边操作数和右边操作数相加，然后构造一个新的对象来存放相加后的结果， 最后将新构造的对象返回。注意这里返回的是新对象的值，而不是引用，因为新对象是在函数体内构造的，如果返回的是引用，在函数退出的时候，临时变量 都会给销毁 rhs操作数出于性能考虑，采用按引用传递的形式 成员函数被声明为 const，说明它不能修改数据成员 返回值被声明为 const 是为了防止它被用作 lvalue。例如，(p1 + p2) = p3，这种写法是没有意义的 Point.cpp\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026#34;Point.h\u0026#34; 3 4using namespace std; 5 6Point::Point(int x, int y) : x(x), y(y) { } 7 8int Point::getX() const { return x; } 9int Point::getY() const { return y; } 10 11void Point::setX(int x) { this-\u0026gt;x = x; } 12void Point::setY(int y) { this-\u0026gt;y = y; } 13 14void Point::print() const { 15\tcout \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; endl; 16} 17 18const Point Point::operator+(const Point \u0026amp;rhs) const { 19\treturn Point(x + rhs.x, y + rhs.y); 20} TestPoint.cpp\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026#34;Point.h\u0026#34; 3 4using namespace std; 5 6int main(int argc, char *argv[]) { 7\tPoint p1(1, 2), p2(4, 5); 8\tPoint p3 = p1 + p2; 9\tp1.print(); 10\tp2.print(); 11\tp3.print(); 12 13\tPoint p4 = p1.operator+(p2); 14\tp2.print(); 15\t// Chaining 16\tPoint p5 = p1 + p2 + p3 + p4; 17\tp5.print(); 18\treturn 0; 19} 说明：\n你可以通过p1 + p2的形式来调用重载的操作符，它会被转换成点操作符调用的形式：p1.operator+(p2) \u0026lsquo;+\u0026lsquo;操作符支持链式调用，因为p1 + p2返回的是一个\u0026rsquo;Point\u0026rsquo;对象 2.3 操作符重载的局限 重载操作符必须是已经存在的合法的操作符，你不能创造你自己的操作符 某些 C++操作符不能被重载，例如\u0026quot;sizeof\u0026rdquo;，点(. 和 .*)，范围解析(::)和(?:) 重载操作符至少要有一个操作数是用户自定义类型，你不能重载一个操作符使其作用于基本数据类型 你不能改变语法规则（例如结合性，优先级以及参数个数） 3. 通过\"friend\"关键字修饰的非成员函数重载操作符 3.1 为什么我们不能总使用成员函数来重载操作符？ 成员函数\u0026rsquo;operatorΔ()\u0026lsquo;只能被对象通过点操作符调用，例如：\u0026lsquo;p1.operatorΔ(p2)\u0026rsquo;，显然左边的操作数p1必须是一个特定类的对象。 假设我们想重载一个二元操作符，例如*来将一个对象p1和一个\u0026rsquo;int\u0026rsquo;字面量作乘法，p1 * 5能够被转成p1.operator*(5)，但是5 * p1就不能 被成员函数表示。一种解决办法就是不允许用户做5 * p1这样的操作，只能是p1 * 5，但是这样很不友好，也破坏了乘法的交换律。另一种解决办法 是使用非成员函数，这样它的调用就不是通过对象和点操作符，而是通过函数和参数的形式。例如，5 * p1会被转换成operator*(5, p1)\n总之，当你的左边操作数不是该类对象的时候，你就不能使用成员函数来重载操作符。\n3.2 “friend\"函数 普通的非成员函数不能直接访问其参数中对象的私有属性。然而有一种特殊被称为友元的函数，能够访问到对象的私有属性。\n一个类的友元函数是用关键字\u0026quot;friend\u0026quot;修饰的定义在类之外的函数，它的该类型参数能够没有限制的访问该类的所有成员。 友元函数能够提高性能，因为它不需要调用 public 成员函数去访问私有数据成员。\n3.3 示例：使用友元函数重载操作类’Point’的\\\u003c\\\u003c和\\\u003e\\\u003e操作符 Point.h\n1#ifndef POINT2_H_ 2#define POINT2_H_ 3 4#include \u0026lt;iostream\u0026gt; 5 6class Point { 7private: 8\tint x, y; 9public: 10\tPoint(int x = 0, int y = 0); 11\tint getX() const; 12\tint getY() const; 13\tvoid setX(int x); 14\tvoid setY(int y); 15 16\tfriend std::ostream \u0026amp; operator\u0026lt;\u0026lt;(std::ostream \u0026amp;out, const Point \u0026amp;point); 17 friend std::istream \u0026amp; operator\u0026gt;\u0026gt;(std::istream \u0026amp;in, Point \u0026amp;point); 18}; 19 20 21#endif /* POINT2_H_ */ Point.cpp\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026#34;Point2.h\u0026#34; 3 4using namespace std; 5 6Point::Point(int x, int y) : x(x), y(y) { } 7 8int Point::getX() const { return x; } 9int Point::getY() const { return y; } 10 11void Point::setX(int x) { this-\u0026gt;x = x; } 12void Point::setY(int y) { this-\u0026gt;y = y; } 13 14ostream \u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp; out, const Point \u0026amp; point) { 15 out \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; point.x \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; point.y \u0026lt;\u0026lt; \u0026#34;)\u0026#34;; // access private data 16 return out; 17} 18 19istream \u0026amp; operator\u0026gt;\u0026gt;(istream \u0026amp; in, Point \u0026amp; point) { 20 cout \u0026lt;\u0026lt; \u0026#34;Enter x and y coord: \u0026#34;; 21 in \u0026gt;\u0026gt; point.x \u0026gt;\u0026gt; point.y; // access private data 22 return in; 23} TestPoint\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026#34;Point2.h\u0026#34; 3 4using namespace std; 5 6int main(int argc, char *argv[]) { 7\tPoint p1(1, 2), p2; 8 9\tcout \u0026lt;\u0026lt; p1 \u0026lt;\u0026lt; endl; 10\toperator\u0026lt;\u0026lt;(cout, p1); 11\tcout \u0026lt;\u0026lt; endl; 12 13\tcin \u0026gt;\u0026gt; p1; 14\tcout \u0026lt;\u0026lt; p1 \u0026lt;\u0026lt; endl; 15\toperator\u0026gt;\u0026gt;(cin, p1); 16\tcout \u0026lt;\u0026lt; p1 \u0026lt;\u0026lt; endl; 17 18\tcin \u0026gt;\u0026gt; p1 \u0026gt;\u0026gt; p2; 19\tcout \u0026lt;\u0026lt; p1 \u0026lt;\u0026lt; endl; 20\tcout \u0026lt;\u0026lt; p2 \u0026lt;\u0026lt; endl; 21 22\treturn 0; 23} 4. 重载二元操作符 C++中除了不能被重载的三元操作符(? :)，其余的不是二元操作符，就是一元操作符。\n假设我们想重载\u0026rdquo;=\u0026ldquo;操作符来比较两个\u0026quot;Point\u0026quot;对象，我们将会使用成员函数和非成员函数的方式来实现。\n成员函数：\n1class Point { 2public: 3\tbool operator==(const Point \u0026amp;rhs) const; 4\t...... 5}; 非成员函数：\n1class Point { 2\tfriend bool operator==(const Point \u0026amp;lhs, const Point \u0026amp;rhs); 3\t...... 4}; 4. 重载一元操作符 大多数一元操作符都是前缀操作符，例如!x, -x。但是，一元操作符自增和自减却有两种形式：前缀(++x, --x)和后缀(x++, x--)。 我们通过一些机制来区别这两种形式。\n4.1 一元前缀操作符 使用友元函数实现\n1class Point { 2\tfriend Point \u0026amp;operator++(Point \u0026amp;point); 3\t...... 4}; 使用成员函数实现：\n1class Point { 2public: 3\tPoint \u0026amp;operator++(); 4\t...... 5}; 你既可以使用非成员函数，也可以使用成员函数来实现，只要它的唯一操作数是该类的对象就可以。\n4.2 一元后缀操作符 自增和自减操作符都有两种形式。重载后缀形式需要一些技巧。因为要跟前缀形式做区分，所以我们使用一个额外的参数来区别于前缀形式：\n1class Point { 2\tfriend const Point operator++(Point \u0026amp;point, int dummy); 3}; 1class Point { 2public: 3\tconst Point operator++(int dummy); 4}; 编译器将会把pt++转换成pt.operator++(0)\n下面是一些示例，省略。\n","date":"March 14, 2018","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/cpp/2018-03-14-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/","series":[],"smallImg":"","tags":[{"title":"C++","url":"/blog/tags/c++/"}],"timestamp":1520985600,"title":"c++编程之操作符重载"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"Programming","url":"/blog/categories/programming/"}],"content":" 1. 简介 我们对传递数值或变量给函数都很熟悉，除了传递变量，我们还能传递类型给模板。传递类型就是大家所熟知的泛型编程，因为 我们可以用泛型编写程序，而用特定的类型调用。\n泛型编程的目的是为了编写的程序不依赖于数据类型。在 C 语言中，所有的代码都需要绑定到确定的数据类型，这样写的代码只能对特定的数据类型起作用。 而模板可以让我们实现泛型编程。你可以将类型作为参数来构建模板函数和类模板。当你的算法需要作用于多种数据类型的时候，模板就显得及其有用了。\nC++的标准模板库(STL)提供了一些常用的容器类模板的实现，例如vector，可以用来存放所有类型的元素。\n2. 示例：STL 中的 vector 类模板 C/C++中的内置数组有一些缺点：\n它的大小是固定的，需要在声明的时候确定大小，不支持动态声明。你不能在执行期给数组扩容； 数组不提供下标边界校验，你可以使用超出边界的下标 你需要自己实现数组比较，和赋值操作 C++提供了一个vector类模板，作为标准模板库(STL)的一部分。vector被定义在\u0026lt;vector\u0026gt;头文件中，属于std命名空间。vector 是最常用的 STL 类，它能够取代数组，并且支持动态分配空间和一些其它操作（例如比较和赋值）。\nvector 是一个类模板，它可以被特定类型的实例化，形如：vector\u0026lt;int\u0026gt;, vector\u0026lt;double\u0026gt;, vector\u0026lt;string\u0026gt;。同一个模板能够用于多种类型，而不必为每种类型都写一套实现。\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026lt;vector\u0026gt; 3#include \u0026lt;string\u0026gt; 4 5using namespace std; 6 7void print(const vector\u0026lt;int\u0026gt; \u0026amp;v); 8 9int main(int argc, char *argv[]) { 10\tvector\u0026lt;int\u0026gt; v1(5); // Create a vector with 5 elements. 11 12\t// Assign values into v1, using array-like index [] 13\t// You can retrieve the size of vector via size() 14\tfor (int i = 0; i \u0026lt; v1.size(); i++) { 15\tv1[i] = (i + 1) * 2; 16\t} 17 18\t// Print vector content, using at() 19\tfor (int i = 0; i \u0026lt; v1.size(); i++) { 20\tcout \u0026lt;\u0026lt; v1.at(i) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 21\t} 22\tcout \u0026lt;\u0026lt; endl; 23 24\tvector\u0026lt;int\u0026gt; v2; 25\t// Assign v1 to v2 memberwise 26\tv2 = v1; 27\tfor (int i = 0; i \u0026lt; v2.size(); i++) { 28\tcout \u0026lt;\u0026lt; v2[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 29\t} 30\tcout \u0026lt;\u0026lt; endl; 31 32\t// Compare 2 vectors memberwise 33\tcout \u0026lt;\u0026lt; boolalpha \u0026lt;\u0026lt; (v1 == v2) \u0026lt;\u0026lt; endl; 34 35\t// Append more elements - synamically allocate memory 36\tv1.push_back(80); 37\tv1.push_back(81); 38\tfor (int i = 0; i \u0026lt; v1.size(); i++) { 39\tcout \u0026lt;\u0026lt; v1[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 40\t} 41\tcout \u0026lt;\u0026lt; endl; 42 43\tvector\u0026lt;string\u0026gt; v3; 44\tv3.push_back(\u0026#34;a for apple\u0026#34;); 45\tv3.push_back(\u0026#34;b for boy\u0026#34;); 46\tfor (int i = 0; i \u0026lt; v3.size(); i++) { 47\tcout \u0026lt;\u0026lt; v3[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 48\t} 49 50\tcout \u0026lt;\u0026lt; endl; 51 52\treturn 0; 53} 说明：\n你可以通过声明vector\u0026lt;int\u0026gt; v1(n)来初始化一个int类型的vector，其中n表示初始化的元素个数 可以使用v1.size()来获取元素个数 可以使用v1[i]或v1.at(i)来访问元素，但是[]操作符不会做边界检查，而at()会 使用push_back()和pop_back()添加和删除元素。vector会自动调整内存分配。 3. 函数模板 把处理不同类型的公共逻辑抽象成函数，就得到了函数模板。\n定义函数模板的定义语法如下：\n1template \u0026lt;typename T\u0026gt; OR template \u0026lt;class T\u0026gt; 2return-type function-name(function-parameter-list) { ...... } Example 1\n1#include \u0026lt;iostream\u0026gt; 2 3using namespace std; 4 5template \u0026lt;typename T\u0026gt; 6void mySwap(T \u0026amp;a, T \u0026amp;b); 7 8int main(int argc, char *argv[]) { 9\tint i1 = 1, i2 = 2; 10\tmySwap(i1, i2); 11\tcout \u0026lt;\u0026lt; \u0026#34;i1 is \u0026#34; \u0026lt;\u0026lt; i1 \u0026lt;\u0026lt; \u0026#34;, i2 is \u0026#34; \u0026lt;\u0026lt; i2 \u0026lt;\u0026lt; endl; 12 13\tchar c1 = \u0026#39;a\u0026#39;, c2 = \u0026#39;b\u0026#39;; 14\tmySwap(c1, c2); 15\tcout \u0026lt;\u0026lt; \u0026#34;c1 is \u0026#34; \u0026lt;\u0026lt; c1 \u0026lt;\u0026lt; \u0026#34;, c2 is \u0026#34; \u0026lt;\u0026lt; c2 \u0026lt;\u0026lt; endl; 16 17\tdouble d1 = 1.1, d2 = 2.2; 18\tmySwap(d1, d2); 19\tcout \u0026lt;\u0026lt; \u0026#34;d1 is \u0026#34; \u0026lt;\u0026lt; d1 \u0026lt;\u0026lt; \u0026#34;, d2 is \u0026#34; \u0026lt;\u0026lt; d2 \u0026lt;\u0026lt; endl; 20 21\treturn 0; 22} 23 24template \u0026lt;typename T\u0026gt; 25void mySwap(T \u0026amp;a, T \u0026amp;b) { 26\tT temp; 27\ttemp = a; 28\ta = b; 29\tb = temp; 30} C++编译器会为每种使用的类型都生成一个对应的函数，例如int型：\n1void mySwap(int \u0026amp;a, int \u0026amp;b) { 2\tint temp; 3\ttemp = a; 4\ta = b; 5\tb = temp; 6} 这样并不能为代码的执行效率和内存使用率带来提升，但是能够大大提高开发效率。\nExample 2\n1#include \u0026lt;iostream\u0026gt; 2 3using namespace std; 4 5template\u0026lt;typename T\u0026gt; 6T abs(T value) { 7\tT result; 8\tresult = (value \u0026gt;= 0) ? value : -value; 9\treturn result; 10} 11 12int main(int argc, char *argv[]) { 13\tint i = -5; 14\tcout \u0026lt;\u0026lt; abs(i) \u0026lt;\u0026lt; endl; 15 16\tdouble d = - 55.5; 17\tcout \u0026lt;\u0026lt; abs(d) \u0026lt;\u0026lt; endl; 18 19\tfloat f = -555.5f; 20\tcout \u0026lt;\u0026lt; abs(f) \u0026lt;\u0026lt; endl; 21 22\treturn 0; 23} 函数模板重载\n1#include \u0026lt;iostream\u0026gt; 2 3using namespace std; 4 5template\u0026lt;typename T\u0026gt; 6void mySwap(T \u0026amp;a, T \u0026amp;b); 7 8template\u0026lt;typename T\u0026gt; 9void mySwap(T a[], T b[], int size); 10 11template\u0026lt;typename T\u0026gt; 12void print(const T *const array, int size); 13 14int main(int argc, char *argv[]) { 15\tint i1 = 1, i2 = 2; 16\tmySwap(i1, i2); 17\tcout \u0026lt;\u0026lt; \u0026#34;i1 is \u0026#34; \u0026lt;\u0026lt; i1 \u0026lt;\u0026lt; \u0026#34;, i2 is \u0026#34; \u0026lt;\u0026lt; i2 \u0026lt;\u0026lt; endl; 18 19\tconst int SIZE = 3; 20\tint arr1[] = {1, 2, 3}, arr2[] = {4, 5, 6}; 21\tmySwap(arr1, arr2, SIZE); 22 23\tprint(arr1, SIZE); 24\tprint(arr2, SIZE); 25\treturn 0; 26} 27 28 29template\u0026lt;typename T\u0026gt; 30void mySwap(T \u0026amp;a, T \u0026amp;b) { 31\tT temp; 32\ttemp = a; 33\ta = b; 34\tb = temp; 35} 36 37template\u0026lt;typename T\u0026gt; 38void mySwap(T a[], T b[], int size) { 39\tT temp; 40\tfor (int i = 0; i \u0026lt; size; i++) { 41\ttemp = a[i]; 42\ta[i] = b[i]; 43\tb[i] = temp; 44\t} 45} 46 47template\u0026lt;typename T\u0026gt; 48void print(const T *const array, int size) { 49\tcout \u0026lt;\u0026lt; \u0026#34;(\u0026#34;; 50\tfor (int i = 0; i \u0026lt; size; i++) { 51\tcout \u0026lt;\u0026lt; array[i]; 52\tif (i \u0026lt; size - 1) cout \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; 53\t} 54\tcout \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; endl; 55} 显式特化\n1#include \u0026lt;iostream\u0026gt; 2 3using namespace std; 4 5template\u0026lt;typename T\u0026gt; 6void mySwap(T \u0026amp;a, T \u0026amp;b); 7 8template\u0026lt;\u0026gt; 9void mySwap\u0026lt;int\u0026gt;(int \u0026amp;a, int \u0026amp;b); 10 11int main(int argc, char *argv[]) { 12\tdouble d1 = 1, d2 = 2; 13\tmySwap(d1, d2); 14 15\tint i1 = 1, i2 = 2; 16\tmySwap(i1, i2); 17 18\treturn 0; 19} 20 21 22template\u0026lt;typename T\u0026gt; 23void mySwap(T \u0026amp;a, T \u0026amp;b) { 24\tcout \u0026lt;\u0026lt; \u0026#34;template\u0026#34; \u0026lt;\u0026lt; endl; 25\tT temp; 26\ttemp = a; 27\ta = b; 28\tb = temp; 29} 30 31template\u0026lt;\u0026gt; 32void mySwap\u0026lt;int\u0026gt;(int \u0026amp;a, int \u0026amp;b) { 33\tcout \u0026lt;\u0026lt; \u0026#34;specilization\u0026#34; \u0026lt;\u0026lt; endl; 34\tint temp; 35\ttemp = a; 36\ta = b; 37\tb = temp; 38} 4. 类模板 定义一个类模板的语法如下：\n1template\u0026lt;class T\u0026gt; 2class ClassName { 3\t...... 4} 关键字\u0026rsquo;class\u0026rsquo;和\u0026rsquo;typename\u0026rsquo;都是用来定义模板的。使用定义好的模板的语法是：ClassName\u0026lt;actual-type\u0026gt;\n例如：\n1#include \u0026lt;iostream\u0026gt; 2using namespace std; 3 4template \u0026lt;typename T\u0026gt; 5class Number { 6private: 7\tT value; 8public: 9\tNumber(T value) { this-\u0026gt;value = value; } 10\tT getValue() const { return this-\u0026gt;value; } 11\tvoid setValue(T value) { this-\u0026gt;value = value; } 12}; 13 14int main(int argc, char *argv[]) { 15\tNumber\u0026lt;int\u0026gt; i(55); 16\tcout \u0026lt;\u0026lt; i.getValue() \u0026lt;\u0026lt; endl; 17 18\tNumber\u0026lt;double\u0026gt; d(55.66); 19\tcout \u0026lt;\u0026lt;d.getValue() \u0026lt;\u0026lt; endl; 20 21\tNumber\u0026lt;string\u0026gt; s(\u0026#34;hello\u0026#34;); 22\tcout \u0026lt;\u0026lt; s.getValue() \u0026lt;\u0026lt; endl; 23\treturn 0; 24} 将模板声明和定义分开\n如果将函数实现和声明分开，就需要在每个函数实现上都使用\u0026quot;template\u0026quot;关键字，例如：\n1template\u0026lt;typename T\u0026gt; 2T Number\u0026lt;T\u0026gt;::getValue() { 3\treturn value; 4} 将所有模板代码都放在头文件中\n多参数类型\n1template\u0026lt;typename T1, typename T2, ...\u0026gt; 2class ClassName { ...... } 默认类型\n1template\u0026lt;typename T = int\u0026gt; 2class ClassName { ...... } 特化\n1// General Template 2template\u0026lt;typename T\u0026gt; 3class Complex { ...... } 4 5// Specialization for type double 6template\u0026lt;\u0026gt; 7class Complex\u0026lt;double\u0026gt; { ...... } 8 9// Specialization for type int 10template\u0026lt;\u0026gt; 11class Complex\u0026lt;int\u0026gt; { ...... } 5. 示例：MyComplex Template Class MyComplex.h\n1/* 2 * The MyComplex template class header (MyComplex.h) 3 * All template codes are kept in the header, to be included in program 4 * (Follow, modified and simplified from GNU GCC complex template class.) 5 */ 6#ifndef MY_COMPLEX_H 7#define MY_COMPLEX_H 8 9#include \u0026lt;iostream\u0026gt; 10 11// Forward declaration 12template \u0026lt;typename T\u0026gt; class MyComplex; 13 14template \u0026lt;typename T\u0026gt; 15std::ostream \u0026amp; operator\u0026lt;\u0026lt; (std::ostream \u0026amp; out, const MyComplex\u0026lt;T\u0026gt; \u0026amp; c); 16template \u0026lt;typename T\u0026gt; 17std::istream \u0026amp; operator\u0026gt;\u0026gt; (std::istream \u0026amp; in, MyComplex\u0026lt;T\u0026gt; \u0026amp; c); 18 19// MyComplex template class declaration 20template \u0026lt;typename T\u0026gt; 21class MyComplex { 22private: 23 T real, imag; 24 25public: 26 // Constructor 27 explicit MyComplex\u0026lt;T\u0026gt; (T real = 0, T imag = 0) 28 : real(real), imag(imag) { } 29 30 // Overload += operator for c1 += c2 31 MyComplex\u0026lt;T\u0026gt; \u0026amp; operator+= (const MyComplex\u0026lt;T\u0026gt; \u0026amp; rhs) { 32 real += rhs.real; 33 imag += rhs.imag; 34 return *this; 35 } 36 37 // Overload += operator for c1 += value 38 MyComplex\u0026lt;T\u0026gt; \u0026amp; operator+= (T value) { 39 real += value; 40 return *this; 41 } 42 43 // Overload comparison == operator for c1 == c2 44 bool operator== (const MyComplex\u0026lt;T\u0026gt; \u0026amp; rhs) const { 45 return (real == rhs.real \u0026amp;\u0026amp; imag == rhs.imag); 46 } 47 48 // Overload comparison != operator for c1 != c2 49 bool operator!= (const MyComplex\u0026lt;T\u0026gt; \u0026amp; rhs) const { 50 return !(*this == rhs); 51 } 52 53 // Overload prefix increment operator ++c 54 // (Separate implementation for illustration) 55 MyComplex\u0026lt;T\u0026gt; \u0026amp; operator++ (); 56 57 // Overload postfix increment operator c++ 58 const MyComplex\u0026lt;T\u0026gt; operator++ (int dummy); 59 60 /* friends */ 61 62 // (Separate implementation for illustration) 63 friend std::ostream \u0026amp; operator\u0026lt;\u0026lt; \u0026lt;\u0026gt;(std::ostream \u0026amp; out, const MyComplex\u0026lt;T\u0026gt; \u0026amp; c); // out \u0026lt;\u0026lt; c 64 friend std::istream \u0026amp; operator\u0026gt;\u0026gt; \u0026lt;\u0026gt;(std::istream \u0026amp; in, MyComplex\u0026lt;T\u0026gt; \u0026amp; c); // in \u0026gt;\u0026gt; c 65 66 // Overloading + operator for c1 + c2 67 // (inline implementation for illustration) 68 friend const MyComplex\u0026lt;T\u0026gt; operator+ (const MyComplex\u0026lt;T\u0026gt; \u0026amp; lhs, const MyComplex\u0026lt;T\u0026gt; \u0026amp; rhs) { 69 MyComplex\u0026lt;T\u0026gt; result(lhs); 70 result += rhs; // uses overload += 71 return result; 72 } 73 74 // Overloading + operator for c + double 75 friend const MyComplex\u0026lt;T\u0026gt; operator+ (const MyComplex\u0026lt;T\u0026gt; \u0026amp; lhs, T value) { 76 MyComplex\u0026lt;T\u0026gt; result(lhs); 77 result += value; // uses overload += 78 return result; 79 } 80 81 // Overloading + operator for double + c 82 friend const MyComplex\u0026lt;T\u0026gt; operator+ (T value, const MyComplex\u0026lt;T\u0026gt; \u0026amp; rhs) { 83 return rhs + value; // swap and use above function 84 } 85}; 86 87// Overload prefix increment operator ++c 88template \u0026lt;typename T\u0026gt; 89MyComplex\u0026lt;T\u0026gt; \u0026amp; MyComplex\u0026lt;T\u0026gt;::operator++ () { 90 ++real; // increment real part only 91 return *this; 92} 93 94// Overload postfix increment operator c++ 95template \u0026lt;typename T\u0026gt; 96const MyComplex\u0026lt;T\u0026gt; MyComplex\u0026lt;T\u0026gt;::operator++ (int dummy) { 97 MyComplex\u0026lt;T\u0026gt; saved(*this); 98 ++real; // increment real part only 99 return saved; 100} 101 102/* Definition of friend functions */ 103 104// Overload stream insertion operator out \u0026lt;\u0026lt; c (friend) 105template \u0026lt;typename T\u0026gt; 106std::ostream \u0026amp; operator\u0026lt;\u0026lt; (std::ostream \u0026amp; out, const MyComplex\u0026lt;T\u0026gt; \u0026amp; c) { 107 out \u0026lt;\u0026lt; \u0026#39;(\u0026#39; \u0026lt;\u0026lt; c.real \u0026lt;\u0026lt; \u0026#39;,\u0026#39; \u0026lt;\u0026lt; c.imag \u0026lt;\u0026lt; \u0026#39;)\u0026#39;; 108 return out; 109} 110 111// Overload stream extraction operator in \u0026gt;\u0026gt; c (friend) 112template \u0026lt;typename T\u0026gt; 113std::istream \u0026amp; operator\u0026gt;\u0026gt; (std::istream \u0026amp; in, MyComplex\u0026lt;T\u0026gt; \u0026amp; c) { 114 T inReal, inImag; 115 char inChar; 116 bool validInput = false; 117 // Input shall be in the format \u0026#34;(real,imag)\u0026#34; 118 in \u0026gt;\u0026gt; inChar; 119 if (inChar == \u0026#39;(\u0026#39;) { 120 in \u0026gt;\u0026gt; inReal \u0026gt;\u0026gt; inChar; 121 if (inChar == \u0026#39;,\u0026#39;) { 122 in \u0026gt;\u0026gt; inImag \u0026gt;\u0026gt; inChar; 123 if (inChar == \u0026#39;)\u0026#39;) { 124 c = MyComplex\u0026lt;T\u0026gt;(inReal, inImag); 125 validInput = true; 126 } 127 } 128 } 129 if (!validInput) in.setstate(std::ios_base::failbit); 130 return in; 131} 132 133#endif TestMyComplex.cpp\n1/* Test Driver for MyComplex template class (TestMyComplex.cpp) */ 2#include \u0026lt;iostream\u0026gt; 3#include \u0026lt;iomanip\u0026gt; 4#include \u0026#34;MyComplex.h\u0026#34; 5 6int main() { 7 std::cout \u0026lt;\u0026lt; std::fixed \u0026lt;\u0026lt; std::setprecision(2); 8 9 MyComplex\u0026lt;double\u0026gt; c1(3.1, 4.2); 10 std::cout \u0026lt;\u0026lt; c1 \u0026lt;\u0026lt; std::endl; // (3.10,4.20) 11 MyComplex\u0026lt;double\u0026gt; c2(3.1); 12 std::cout \u0026lt;\u0026lt; c2 \u0026lt;\u0026lt; std::endl; // (3.10,0.00) 13 14 MyComplex\u0026lt;double\u0026gt; c3 = c1 + c2; 15 std::cout \u0026lt;\u0026lt; c3 \u0026lt;\u0026lt; std::endl; // (6.20,4.20) 16 c3 = c1 + 2.1; 17 std::cout \u0026lt;\u0026lt; c3 \u0026lt;\u0026lt; std::endl; // (5.20,4.20) 18 c3 = 2.2 + c1; 19 std::cout \u0026lt;\u0026lt; c3 \u0026lt;\u0026lt; std::endl; // (5.30,4.20) 20 21 c3 += c1; 22 std::cout \u0026lt;\u0026lt; c3 \u0026lt;\u0026lt; std::endl; // (8.40,8.40) 23 c3 += 2.3; 24 std::cout \u0026lt;\u0026lt; c3 \u0026lt;\u0026lt; std::endl; // (10.70,8.40) 25 26 std::cout \u0026lt;\u0026lt; ++c3 \u0026lt;\u0026lt; std::endl; // (11.70,8.40) 27 std::cout \u0026lt;\u0026lt; c3++ \u0026lt;\u0026lt; std::endl; // (11.70,8.40) 28 std::cout \u0026lt;\u0026lt; c3 \u0026lt;\u0026lt; std::endl; // (12.70,8.40) 29 30// c1+c2 = c3; // error: c1+c2 returns a const 31// c1++++; // error: c1++ returns a const 32 33// MyComplex\u0026lt;int\u0026gt; c4 = 5; // error: implicit conversion disabled 34 MyComplex\u0026lt;int\u0026gt; c4 = (MyComplex\u0026lt;int\u0026gt;)5; // explicit type casting allowed 35 std::cout \u0026lt;\u0026lt; c4 \u0026lt;\u0026lt; std::endl; // (5,0) 36 37 MyComplex\u0026lt;int\u0026gt; c5; 38 std::cout \u0026lt;\u0026lt; \u0026#34;Enter a complex number in (real,imag): \u0026#34;; 39 std::cin \u0026gt;\u0026gt; c5; 40 if (std::cin.good()) { 41 std::cout \u0026lt;\u0026lt; c5 \u0026lt;\u0026lt; std::endl; 42 } else { 43 std::cerr \u0026lt;\u0026lt; \u0026#34;Invalid input\u0026#34; \u0026lt;\u0026lt; std::endl; 44 } 45 return 0; 46} ","date":"March 14, 2018","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/cpp/2018-03-14-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/","series":[],"smallImg":"","tags":[{"title":"C++","url":"/blog/tags/c++/"}],"timestamp":1520985600,"title":"c++编程之模板和泛型编程"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"Programming","url":"/blog/categories/programming/"}],"content":" 1. 继承 1.1 术语 超类（基类）和子类（派生类）：在面向对象程序设计中，我们通常使用继承来避免代码冗余。在 C++中，继承的语法规则如下：\n1class SubclassName : inheritance-access-specifier SuperclassName { 2\t...... 3}; 子类继承了父类所有的成员，子类也可以定义自己的构造器和成员。\n访问标识符：C++支持三种访问标识符：private，public和protected。一个类的 public 成员变量、成员函数，可以通过类的成员函数、类的实例变量进行访问。 一个类的 protected 成员变量、成员函数，无法通过类的实例变量进行访问。但是可以通过类的友元函数、友元类进行访问。一个类的 private 成员变量、成员函数，无法通过类的实例变量进行访问。但是可以通过类的友元函数、友元类进行访问。\n继承访问标识符：public 继承不改变基类成员的访问权限，private 继承使得基类所有成员在子类中的访问权限变为 private，protected 继承将基类中 public 成员变为子类的 protected 成员，其它成员的访问 权限不变。 基类中的 private 成员不受继承方式的影响，子类永远无权访问。\n1.2 一个示例 MovablePoint.h\n1#ifndef MOVING_POINT_H 2#define MOVING_POINT_H 3 4#include \u0026#34;Point.h\u0026#34; 5 6class MoviablePoint : public Point { 7private: 8\tint xSpeed, ySpeed; 9 10public: 11\tMovablePoint(int x, int y, int xSpeed = 0, int ySpeed = 0); 12\tint getXSpeed() const; 13\tint getYSpeed() const; 14\tvoid setXSpeed(int xSpeed); 15\tvoid setYSpeed(int ySpeed); 16\tvoid move(); 17\tvoid print() const; 18} 19#endif MovablePoint.cpp\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026#34;MovablePoint.h\u0026#34; 3 4using namespace std; 5 6MovablePoint::MovablePoint(int x, int y, int xSpeed, int ySpeed) : Point(x, y), xSpeed(xSpeed), ySpeed(ySpeed) { } 7 8// Getters 9int MovablePoint::getXSpeed() const { return xSpeed; } 10int MovablePoint::getYSpeed() const { return ySpeed; } 11 12// Functions 13void MovablePoint::print() const { 14\tcout \u0026lt;\u0026lt; \u0026#34;Movable\u0026#34;; 15\tPoint::print(); 16\tcout \u0026lt;\u0026lt; \u0026#34; Speed=\u0026#34; \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; xSpeed \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; ySpeed \u0026lt;\u0026lt; \u0026#34;)\u0026#34;; 17} 18 19void MovablePoint::move() { 20\tPoint::setX(Point::getX() + xSpeed); 21\tPoint::setY(Point::getY() + ySpeed); 22} 1.3 示例：父类有 protected 成员 再次强调一点，子类不能直接访问父类中被private修饰的成员。例如：\n1void MovablePoint::move() { 2\tx += xSpeed; // error: \u0026#39;int Point::x\u0026#39; is private 3\t... 4} 然而，如果我们把 x 改成protected的话，子类就可以直接访问了。\n1// Superclass Point 2 3class Point { 4protected: 5\tint x, y; 6\t...... 7}; 8 9// Subclass MovablePoint 10class MovablePoint : public Point { 11...... 12}; 13 14void MovablePoint::move() { 15\tx += xSpeed; 16\ty += ySpeed; 17} 2. 多态 多态作用于运行时使用动态绑定的对象指针和引用。多态对普通对象不起作用，因为普通对象是在编译时静态绑定的。\n2.1 替换 子类实例在 public 继承方式下，会继承父类的所有属性。子类能够做父类能做的任何事情，这就是\u0026quot;is-a\u0026quot;关系。因此你可以用父类引用 替换子类实例。\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026#34;MovablePoint.h\u0026#34; 3 4using namespace std; 5 6int main() { 7\tPoint *ptrP1 = new MovablePoint(11, 12, 13, 14); // upcast 8\tptrP1-\u0026gt;print(); 9\t// ptrP1-\u0026gt;move(); // error: \u0026#39;class Point\u0026#39; has no member named \u0026#39;move\u0026#39; 10\tdelete ptrP1; 11 12\tMovablePoint map2(21, 22, 23, 24); 13\tPoint \u0026amp;p2 = map2; 14\tp2.print(); 15\tcout \u0026lt;\u0026lt; endl; 16\t// p2.move(); // error: \u0026#39;class Point\u0026#39; has no member named \u0026#39;move\u0026#39; 17 18\tPoint p3 = MovablePoint(31, 32, 33, 34); 19\tp3.print(); 20\tcout \u0026lt;\u0026lt; endl; 21\t// p3.move(); // error: \u0026#39;class Point\u0026#39; has no member named \u0026#39;move\u0026#39; 22} 被替换的实例能够调用父类的所有方法，但是不能盗用子类中定义的函数，因为该引用是父类引用，不能识别子类成员。\n2.2 多态性 子类实例能够被父类引用替换 一旦被替换，该实例只能调用父类的方法，不能调用子类的 如果子类重写了父类的方法，我们期望调用的是重写后的方法，而不是父类原有的方法 虚函数：为了实现多态机制，我们需要使用virtual关键字来修饰函数。此时，如果父类作用于子类实例，调用被virtual修饰的 函数时，会调用子类中重写的函数，而不是父类中的原始函数。例如：\n1Class Point { 2\t...... 3\tvirtual void print() const; 4} 1/* Test Substituting a subclass instance to a superclass reference. 2 (TestSubstitution.cpp) */ 3#include \u0026lt;iostream\u0026gt; 4#include \u0026#34;MovablePoint.h\u0026#34; // included \u0026#34;Point.h\u0026#34; 5using namespace std; 6 7int main() { 8 // Substitute a subclass instance to a superclass reference 9 10 // Using Object Pointer 11 Point * ptrP1 = new MovablePoint(11, 12, 13, 14); // upcast 12 ptrP1-\u0026gt;print(); // MovablePoint @ (11,12) Speed=(13,14) 13 // - Run subclass version!! 14 cout \u0026lt;\u0026lt; endl; 15 delete ptrP1; 16 17 // Using Object Reference 18 MovablePoint mp2(21, 22, 23, 24); 19 Point \u0026amp; p2 = mp2; // upcast 20 p2.print(); // MovablePoint @ (21,22) Speed=(23,24) 21 // - Run subclass version!! 22 cout \u0026lt;\u0026lt; endl; 23 24 // Using object with explicit constructor 25 Point p3 = MovablePoint(31, 32, 33, 34); // upcast 26 p3.print(); // Point @ (31,32) - Run superclass version!! 27 cout \u0026lt;\u0026lt; endl; 28} 向上转型和向下转型\n通常情况下，C++不允许我们将一种类型的地址赋值给另一种类型的指针（或引用）。例如：\n1int i = 0; 2double *ptr1 = \u0026amp;i; // error: cannot convert \u0026#39;int*\u0026#39; to \u0026#39;double*\u0026#39; in initialization 3 4double \u0026amp;d = i; // error: invalid initialication of reference of type \u0026#39;double\u0026amp;\u0026#39; from expression of type \u0026#39;int\u0026#39; 然而，父类指针或引用能够存放子类对象，而不需要显式的转型：\n1MovablePoint mp(......); 2Point *ptrP1 = \u0026amp;mp; // Okay - Implicit upcast 3Point \u0026amp; p2 = mp; // Okay - Implicit upcast 将子类对象转成父类引用或父类指针被称为向上转型。在 public 继承中，向上转型是一定被允许的，而且不需要显式的转型操作。因为 public 继承是\u0026quot;is-a\u0026quot;关系。子类实例也是父类的一个实例。\n相反，将一个父类对象转成子类引用或指针被称为向下转型。向下转型需要显式操作：\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026#34;MovablePoint\u0026#34; 3 4using namespace std; 5 6int main() { 7\t// Object Pointer 8\tPointer *ptrp1 = new MovablePoint(11, 12, 13, 14); 9\t// Upcast is always permissible and safe 10\tptrP1-\u0026gt;print(); 11 12\t// MovablePoint *ptrMP1 = ptrP1; // error 13\tMovablePoint *ptrMp1 = (MovablePoint *) ptrP1; 14\t// Downcase requires explicit casting operator 15\tdelete ptrP1; 16} dynamic_cast 操作符\nC++提供了一种新的操作符，叫做dynamic_cast\u0026lt;type\u0026gt;(value)，如果操作失败的话，会返回空指针。\n1MovablePoint *ptrMP1 = dynamic_cast\u0026lt;MovablePoint *\u0026gt;(ptrP1); typeid 操作符\ntypeid操作符返回一个type_info的对象（在头文件中定义）的引用，其中包含了它操作的对象的信息。你可以使用 type_info的成员方法name()来获取所操作的类型名称：\n1/* Test typeid operator, which return an object of type_info (TestTypeID.cpp) */ 2#include \u0026lt;iostream\u0026gt; 3#include \u0026lt;typeinfo\u0026gt; // Need for typeid operator 4#include \u0026#34;MovablePoint.h\u0026#34; // included \u0026#34;Point.h\u0026#34; 5using namespace std; 6 7int main() { 8 // Object Pointer 9 Point * ptrP1 = new MovablePoint(11, 12, 13, 14); // upcast 10 cout \u0026lt;\u0026lt; typeid(*ptrP1).name() \u0026lt;\u0026lt; endl; // 12MovablePoint 11 12 MovablePoint * ptrMP1 = dynamic_cast\u0026lt;MovablePoint *\u0026gt;(ptrP1); 13 cout \u0026lt;\u0026lt; typeid(*ptrMP1).name() \u0026lt;\u0026lt; endl; // 12MovablePoint 14 delete ptrP1; 15 16 Point p2; 17 cout \u0026lt;\u0026lt; typeid(p2).name() \u0026lt;\u0026lt; endl; // 5Point 18 19 MovablePoint mp2(1, 2, 3, 4); 20 cout \u0026lt;\u0026lt; typeid(mp2).name() \u0026lt;\u0026lt; endl; // 12MovablePoint 21} 说明：返回的类型名前的数字是该字符串的长度。\n2.3 纯虚函数和抽象父类 纯虚函数的声明语法如下：\n1virtual double getArea() = 0; 纯虚函数通常没有函数体，因为该类不确定如何实现这个函数。一个包含一个或多个纯虚函数的类被成为抽象类。我们不能直接对抽象类进行实例化，因为它的定义是不完整的。\n抽象类只能作为父类，然后派生出子类，重写并实现所有的纯虚函数。\nC++允许纯虚函数有函数体，那么这时候=0就仅仅是使该类为抽象类而已。但是，对于这样的抽象类，你依然不能直接实例化。\n2.4 示例 Shape.h\n1#define SHAPE_H 2#define SHAPE_H 3 4#include \u0026lt;string\u0026gt; 5using namespace std; 6 7class Shape { 8private: 9\tstring color; 10public: 11\tShape(const string \u0026amp;color = \u0026#34;red\u0026#34;); 12\tstring getColor() const; 13\tvoid setColor(const string \u0026amp;color); 14\tvirtual void print() const; 15\t// Purge virtual, to be implemented by subclass 16\t// You cannot create instance of Shape 17\tvirtual double getArea() const = 0; 18}; 19 20#endif Shape.cpp\n1#include \u0026#34;Shape.h\u0026#34; 2#include \u0026lt;iostream\u0026gt; 3 4Shape::Shape(const string \u0026amp;color) { 5\tthis-\u0026gt;color = color; 6} 7 8string Shape::getColor() const { 9\treturn color; 10} 11 12void Shape::setColor(const string \u0026amp;color) { 13\tthis-\u0026gt;color = color; 14} 15 16void Shape::print() const { 17\tstd::cout \u0026lt;\u0026lt; \u0026#34;Shape of color = \u0026#34; \u0026lt;\u0026lt; color; 18} Circle.h\n1#ifndef CIRCLE_H 2#define CIRCLE_H 3 4#include \u0026#34;Shape.h\u0026#34; 5 6class Circle : public Shape { 7private: 8\tint radius; 9public: 10\tCircle(int radius = 1, const String \u0026amp;color = \u0026#34;red\u0026#34;); 11\tint getRadius() const; 12\tvoid setRadius(int radius); 13\tvoid print() const; 14\tdouble getArea() const; 15}; 16 17#endif Circle.cpp\n1/* Implementation for Circle (Circle.cpp) */ 2#include \u0026#34;Circle.h\u0026#34; 3#include \u0026lt;iostream\u0026gt; 4#define PI 3.14159265 5 6// Constructor 7Circle::Circle(int radius, const string \u0026amp; color) 8 : Shape(color), radius(radius) { } 9 10// Getters 11int Circle::getRadius() const { 12 return radius; 13} 14 15// Setters 16void Circle::setRadius(int radius) { 17 this-\u0026gt;radius = radius; 18} 19 20void Circle::print() const { 21 std::cout \u0026lt;\u0026lt; \u0026#34;Circle radius=\u0026#34; \u0026lt;\u0026lt; radius \u0026lt;\u0026lt; \u0026#34;, subclass of \u0026#34;; 22 Shape::print(); 23} 24 25// Implement virtual function inherited for superclass Shape 26double Circle::getArea() const { 27 return radius * radius * PI; 28} Rectangle.h\n1/* Header for Rectangle class (Rectangle.h) */ 2#ifndef RECTANGLE_H 3#define RECTANGLE_H 4 5#include \u0026#34;Shape.h\u0026#34; 6 7// The class Rectangle is a subclass of Shape 8class Rectangle : public Shape { 9private: 10 int length; 11 int width; 12 13public: 14 Rectangle(int length = 1, int width = 1, const string \u0026amp; color = \u0026#34;red\u0026#34;); 15 int getLength() const; 16 void setLength(int length); 17 int getWidth() const; 18 void setWidth(int width); 19 void print() const; // Override the virtual function 20 double getArea() const; // to implement virtual function 21}; 22 23#endif Rectangle.cpp\n1/* Implementation for Rectangle (Rectangle.cpp) */ 2#include \u0026#34;Rectangle.h\u0026#34; 3#include \u0026lt;iostream\u0026gt; 4 5// Constructor 6Rectangle::Rectangle(int length, int width, const string \u0026amp; color) 7 : Shape(color), length(length), width(width) { } 8 9// Getters 10int Rectangle::getLength() const { 11 return length; 12} 13int Rectangle::getWidth() const { 14 return width; 15} 16 17// Setters 18void Rectangle::setLength(int length) { 19 this-\u0026gt;length = length; 20} 21void Rectangle::setWidth(int width) { 22 this-\u0026gt;width = width; 23} 24 25void Rectangle::print() const { 26 std::cout \u0026lt;\u0026lt; \u0026#34;Rectangle length=\u0026#34; \u0026lt;\u0026lt; length \u0026lt;\u0026lt; \u0026#34; width=\u0026#34; \u0026lt;\u0026lt; width \u0026lt;\u0026lt; \u0026#34;, subclass of \u0026#34;; 27 Shape::print(); 28} 29 30// Implement virtual function inherited from superclass Shape 31double Rectangle::getArea() const { 32 return length * width; 33} ","date":"March 5, 2018","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/cpp/2018-03-05-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/","series":[],"smallImg":"","tags":[{"title":"C++","url":"/blog/tags/c++/"}],"timestamp":1520208000,"title":"c++编程之继承和多态"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"Programming","url":"/blog/categories/programming/"}],"content":" 1. 示例：使用引用的\"Time\"类 回到之前版本的\u0026quot;Time\u0026quot;类，假设我们想增加链式操作，例如t.nextSecond().nextSecond().print()，我们就需要让nextSecond()返回this的一个引用。\nTime.h\n1class Time { 2private: 3\t...... 4public: 5\tTime \u0026amp;nextSecond(); // Return a reference to \u0026#34;this\u0026#34; instance 6\t...... 7} 在函数原型中，我们申明了一个nextSecond()的成员函数，返回Time对象的引用。返回的引用可以用来继续调用成员函数。\nTime.cpp\n1// Increase this instance by one second and return this instance by reference. 2Time \u0026amp;Time::nextSecond() { 3\tif (++second == 60) { 4\tsecond = 0; 5\tif (++minute == 60) { 6\tminute = 0; 7\tif (++hour = 24) { 8\thour = 0; 9\t} 10\t} 11\t} 12 13\treturn *this; // Return this instance by reference 14\t// \u0026#34;this\u0026#34; is a pointer to this instance. *this refers to the instance. 15} C++有一个关键字\u0026quot;this\u0026quot;，它保存了一个指向当前实例的指针。也就是说，*this指的是当前实例。\nTestTime.cpp\n1Time t1(23, 59, 58); 2t1.print(); 3t2.nextSecond(); 4t1.print(); 5t1.nextSecond().nextSecond().print(); 6t1.print(); 2. 示例：“Time\"类的第三个版本，异常处理 输入检验是必要的，例如，在setHour(int h)函数中，我们需要检验输入的参数是 0~23 之间的数字。校验参数很简单，但是如果校验失败的话我们该如何处理错误呢，我们是输出一句错误 提示然后终止程序呢，还是输出一个警告，然后继续执行程序直到错误不能被容忍为止呢？这两种方式都不好。\n1void Time::setHour(int h) { 2\tif (h \u0026gt;= 0 \u0026amp;\u0026amp; h \u0026lt;= 23) { 3\thour = h; 4\t} else { 5\tcout \u0026lt;\u0026lt; \u0026#34;Error: Invalid hour! Hour shall be 0~23.\u0026#34; \u0026lt;\u0026lt; endl; 6\texit(1); 7\t} 8} 1void Time::setHour(int h) { 2\tif (h \u0026gt;= 0 \u0026amp;\u0026amp; h \u0026lt;= 23) { 3\thour = h; 4\t} else { 5\tcout \u0026lt;\u0026lt; \u0026#34;Warning: Invalid hour! Hour shall be 0-23.\u0026#34; \u0026lt;\u0026lt; endl; 6\thour = 0; 7\t} 8} 取而代之的是，C++提供了一种异常处理机制（在头文件），这种机制能够优雅地处理异常。\nTime.h\n1#ifndef TIME_H 2#define TIME_H 3 4class Time { 5private: 6\tint hour; 7\tint minute; 8\tint second; 9 10public: 11\tTime(int h = 0, int m = 0, int s = 0); 12\tint getHour() const; 13\tvoid setHour(int h); 14\tint getMinute() const; 15\tvoid setMinute(int m); 16\tint getSecond() const; 17\tvoid setSecond(int s); 18\tvoid setTime(int h, int m, int s); 19\tvoid print() const; 20}; 21 22#endif Time.cpp\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026lt;iomanip\u0026gt; 3#include \u0026lt;stdexcept\u0026gt; 4#include \u0026#34;Time.h\u0026#34; 5 6using namespace std; 7 8Time::Time(int h, int m, int s) { 9\tsetHour(h); 10\tsetMinute(m); 11\tsetSecond(s); 12} 13 14int Time::getHour() const { 15\treturn hour; 16} 17 18void Time::setHour(int h) { 19\tif (h \u0026gt;= 0 \u0026amp;\u0026amp; h \u0026lt;= 23) { 20\thour = h; 21\t} else { 22\tthrow invalid_argument(\u0026#34;Invalid hour! Hour shall be 0~23.\u0026#34;); 23\t} 24} 25 26int Time::getMinute() const { 27\treturn minute; 28} 29 30void Time::setMinute(int m) { 31\tif (m \u0026gt;= 0 \u0026amp;\u0026amp; m \u0026lt;= 59) { 32\tminute = m; 33\t} else { 34\tthrow invalid_argument(\u0026#34;Invalid minute! Minute shall be 0~59.\u0026#34;); 35\t} 36} 37 38int Time::getSecond() const { 39\treturn second; 40} 41 42void Time::setSecond(int s) { 43\tif (s \u0026gt;= 0 \u0026amp;\u0026amp; s \u0026lt;= 59) { 44\tsecond = s; 45\t} else { 46\tthrow invalid_argument(\u0026#34;Invalid second! Second shall be 0~59.\u0026#34;); 47\t} 48} 49 50void Time::setTime(int h, int m, int s) { 51\tsetHour(h); 52\tsetMinute(m); 53\tsetSecond(s); 54} 55 56void Time::print() const { 57\tcout \u0026lt;\u0026lt; setfill(\u0026#39;0\u0026#39;); 58\tcout \u0026lt;\u0026lt; setw(2) \u0026lt;\u0026lt; hour \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; setw(2) \u0026lt;\u0026lt; minute \u0026lt;\u0026lt; \u0026#34;:\u0026#34; 59\t\u0026lt;\u0026lt; setw(2) \u0026lt;\u0026lt; second \u0026lt;\u0026lt; endl; 60} TestTime.cpp\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026lt;stdexcept\u0026gt; 3 4#include \u0026#34;Time.h\u0026#34; 5 6using namespace std; 7 8int main() { 9\ttry { 10\tTime t1(25, 0, 0); 11\tt1.print(); 12\t} catch (invalid_argument \u0026amp;ex) { 13\tcout \u0026lt;\u0026lt; \u0026#34;Exception:\u0026#34; \u0026lt;\u0026lt; ex.what() \u0026lt;\u0026lt; endl; 14\t} 15 16\tcout \u0026lt;\u0026lt; \u0026#34;Next statement after try-catch\u0026#34; \u0026lt;\u0026lt; endl; 17} 3. 对象引用，指针和数组中的动态内存分配（高级） 1#include \u0026lt;iostream\u0026gt; 2#include \u0026#34;Time.h\u0026#34; 3using namespace tsd; 4 5int main() { 6\tTime t1(1, 2, 3); 7\tt1.print(); 8 9\tTime *ptrT1 = \u0026amp;t1; 10\t(*ptrT1).print(); 11\tptrT1-\u0026gt;print(); 12 13\tTime \u0026amp;refT1 = t1; 14\trefT1.print(); 15 16\tTime *ptrT2 = new Time(4, 5, 6); 17\tptrT2-\u0026gt;print(); 18\tdelete ptrT2; 19 20\tTime tArray1[2]; 21\ttArray1[0].print(); 22\ttArray1[1].print(); 23 24\tTime tArray2[2] = {Time(7, 8, 9), Time(10)}; 25\ttArray2[0].print(); 26\ttArray2[1].print(); 27 28\tTime *ptrTarray3 = new Time[2]; 29\tptrTarray3[0].print(); 30\tptrTarray3[1].print(); 31\tdelete[] ptrTarray3; 32 33\t// C++11 syntax, compile with -std=c++0x 34\tTime *ptrTarray4 = new Time[2] {Time(11, 12, 13), Time(14)}; 35\tptrTarray4-\u0026gt;print(); 36\t(ptrTarray4 + 1)-\u0026gt;print(); 37\tdelete[] ptrTarray4; 38} 4. 示例：复数类 下面是复数类的类图\nComplex.h\n1#ifndef COMPLEX_H 2#define COMPLEX_H 3 4class Complex { 5private: 6\tdouble real; 7\tdouble imag; 8 9public: 10\tComplex(double real = 0.0, double imag = 0.0); 11\tdouble getReal() const; 12\tvoid setReal(double real); 13\tdouble getImag() const; 14\tvoid setImag(double imag); 15\tvoid setValue(double real, double imag); 16\tvoid print() const; 17\tbool isReal() const; 18\tbool isImaginary() const; 19 20\tComplex \u0026amp;addInto(const Complex \u0026amp;another); 21\tComplex \u0026amp;addInto(double real, double imag); 22 23\tComplex addReturnNew(const Complex *another) const; 24\tComplex addReturnNew(double real, double imag) const; 25}; 26#endif Complex.cpp\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026#34;Complex.h\u0026#34; 3 4using namespace std; 5 6Complex::Complex(double real, double imag) : real(real), imag(imag) {} 7 8double Complex::getReal() const { 9\treturn real; 10} 11 12void Complex::setReal(double real) { 13\tthis-\u0026gt;real = real; 14} 15 16double Complex::getImag() const { 17\treturn imag; 18} 19 20void Complex::setImag(double imag) { 21\tthis-\u0026gt;imag = imag; 22} 23 24void Complex::setValue(double real, double imag) { 25\tthis-\u0026gt;real = real; 26\tthis-\u0026gt;imag = imag; 27} 28 29void Complex::print() const { 30\tcout \u0026lt;\u0026lt; \u0026#39;(\u0026#39; \u0026lt;\u0026lt; real \u0026lt;\u0026lt; \u0026#39;,\u0026#39; \u0026lt;\u0026lt; imag \u0026lt;\u0026lt; \u0026#39;)\u0026#39; \u0026lt;\u0026lt; endl; 31} 32 33bool Complex::isReal() const { 34\treturn (imag == 0); 35} 36 37bool Complex::isImaginary() const { 38\treturn (imag != 0); 39} 40 41Complex \u0026amp;Complex::addInto(const Complex \u0026amp;another) { 42\treal += another.real; 43\timag += another.imag; 44\treturn *this; 45} 46 47Complex \u0026amp;Complex::addInto(double real, double imag) { 48\tthis-\u0026gt;real += real; 49\tthis-\u0026gt;imag += imag; 50\treturn *this; 51} 52 53Complex Complex::addReturnNew(const Complex \u0026amp;another) const { 54\treturn Complex(real + another.real, imag + another.imag); 55} 56 57Complex Complex::addReturnNew(double real, double imag) const { 58\treturn Complex(this-\u0026gt;real + real, this-\u0026gt;imag + imag); 59} TestComplex.cpp\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026lt;iomanip\u0026gt; 3#include \u0026#34;Complex.h\u0026#34; 4 5using namespace std; 6 7int main() { 8\tComplex c1, c2(4, 5); 9\tc1.print(); 10\tc2.print(); 11 12\tc1.setValue(6, 7); 13\tc1.print(); 14 15\tc1.setReal(0); 16\tc1.setImag(8); 17\tc1.print(); 18 19\tcout \u0026lt;\u0026lt; boolalpha; // print true/false instead of 0/1 20\tcout \u0026lt;\u0026lt; \u0026#34;Is real?\u0026#34; \u0026lt;\u0026lt; c1.isReal() \u0026lt;\u0026lt; endl; 21\tcout \u0026lt;\u0026lt; \u0026#34;Is Imaginary?\u0026#34; \u0026lt;\u0026lt; c1.isImaginary() \u0026lt;\u0026lt; endl; 22 23\tc1.addInto(c2).addInto(1, 1).print(); 24\tc1.print(); 25 26\tc1.addReturnNew(c2).print(); 27\tc1.print(); 28\tc1.addReturnNew(1, 1).print(); 29\tc1.print(); 30 31\treturn 0; 32} **注意：**不要返回一个局部变量的引用！\n假设我们将addReturnNew函数修改为下面的样子：\n1Complex \u0026amp;Complex::addReturnNew(const Complex \u0026amp;another) const { 2\treturn Complex(real + another.real, imag + another.imag); 3} 那么在编译的时候会报以下错误：\u0026ldquo;invalid initialization of non-const reference of type \u0026lsquo;Complex\u0026amp;\u0026rsquo; from an rvalue of type \u0026lsquo;Complex\u0026rsquo;\u0026quot;。 这是因为临时变量是在函数体内构造的，不能作用于函数体外，从而外部调用的引用就是非法的。\n5. 示例：“Date\"类 Date.h\n1#ifndef DATE_H 2#define DATE_H 3 4#include \u0026lt;string\u0026gt; 5 6using namespace std; 7 8class Date { 9private: 10\tint year; 11\tint month; 12\tint day; 13\tconst static string STR_MONTHS[]; 14\tconst static string STR_DAYS[]; 15\tconst static int DAYS_IN_MONTHS[]; 16\tconst static int YRER_MIN = 1753; 17\tconst static int YRER_MAX = 9999; 18 19public: 20\tstatic bool isLeapYear(int y); 21\tstatic bool isValidDate(int y, int m, int d); 22\tstatic int getDayOfWeek(int y, int m, int d); 23 24\tDate(int y, int m, int d); 25\tvoid setDate(int y, int m, int d); 26\tint getYear() const; 27\tint getMonth() const; 28\tint getDay() const; 29\tvoid setYear(int y); 30\tvoid setMonth(int m); 31\tvoid setDay(int d); 32\tvoid print() const; 33 34\tDate \u0026amp;nextDay(); 35\tDate \u0026amp;previousDay(); 36\tDate \u0026amp;nextMonth(); 37\tDate \u0026amp;previousMonth(); 38\tDate \u0026amp;nextYear(); 39\tDate \u0026amp;previousYear(); 40}; 41#endif Date.cpp\n1/* Implementation for Date Class (Date.cpp) */ 2#include \u0026lt;iostream\u0026gt; 3#include \u0026lt;stdexcept\u0026gt; 4#include \u0026#34;Date.h\u0026#34; 5using namespace std; 6 7// Initialize static non-integer variable (must be done outside the class declaration) 8const string Date::STR_MONTHS[] = {\u0026#34;Jan\u0026#34;, \u0026#34;Feb\u0026#34;, \u0026#34;Mar\u0026#34;, \u0026#34;Apr\u0026#34;, \u0026#34;May\u0026#34;, \u0026#34;Jun\u0026#34;, 9 \u0026#34;Jul\u0026#34;, \u0026#34;Aug\u0026#34;, \u0026#34;Sep\u0026#34;, \u0026#34;Oct\u0026#34;, \u0026#34;Nov\u0026#34;, \u0026#34;Dec\u0026#34;}; 10 11const int Date::DAYS_IN_MONTHS[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; 12 13const string Date::STR_DAYS[] = {\u0026#34;Sunday\u0026#34;, \u0026#34;Monday\u0026#34;, \u0026#34;Tuesday\u0026#34;, \u0026#34;Wednesday\u0026#34;, 14 \u0026#34;Thursday\u0026#34;, \u0026#34;Friday\u0026#34;, \u0026#34;Saturday\u0026#34;}; 15 16// A static function that returns true if the given year is a leap year 17bool Date::isLeapYear(int year) { 18 return ((year % 4 == 0 \u0026amp;\u0026amp; year % 100 != 0) || (year % 400 == 0)); 19} 20 21// A static function that returns true if the given y, m, d constitutes a valid date 22bool Date::isValidDate(int y, int m, int d) { 23 if (y \u0026gt;= YEAR_MIN \u0026amp;\u0026amp; y \u0026lt;= YEAR_MAX \u0026amp;\u0026amp; m \u0026gt;= 1 \u0026amp;\u0026amp; m \u0026lt;= 12) { 24 int lastDayOfMonth = DAYS_IN_MONTHS[m-1]; 25 if (m == 2 \u0026amp;\u0026amp; isLeapYear(y)) { 26 lastDayOfMonth = 29; 27 } 28 return (d \u0026gt;= 1 \u0026amp;\u0026amp; d \u0026lt;= lastDayOfMonth); 29 } else { 30 return false; 31 } 32} 33 34// A static function that returns the day of the week (0:Sun, 6:Sat) for the given date 35// Wiki \u0026#34;Determination of the day of the week\u0026#34; for the algorithm 36int Date::getDayOfWeek(int y, int m, int d) { 37 int centuryTable[] = {4, 2, 0, 6, 4, 2, 0, 6}; // 17xx, 18xx, ... 38 int MonthTable[] = {0, 3, 3, 6, 1, 4, 6, 2, 5, 0, 3, 5}; 39 int MonthLeapYearTable[] = {6, 2, 3, 6, 1, 4, 6, 2, 5, 0, 3, 5}; 40 41 int century = y / 100; 42 int twoDigitYear = y % 100; 43 int centuryTableIndex = (century - 17) % 8; 44 // Date before 17xx are not valid, but needed to prevent negative index 45 if (centuryTableIndex \u0026lt; 0) { 46 centuryTableIndex += 8; 47 } 48 int sum = centuryTable[centuryTableIndex] + twoDigitYear + twoDigitYear / 4; 49 if (isLeapYear(y)) { 50 sum += MonthLeapYearTable[m-1]; 51 } else { 52 sum += MonthTable[m-1]; 53 } 54 sum += d; 55 return sum % 7; 56} 57 58// Constructor 59Date::Date(int y, int m, int d) { 60 setDate(y, m, d); 61} 62 63// With Input validation 64void Date::setDate(int y, int m, int d) { 65 setYear(y); 66 setMonth(m); 67 setDay(d); // need to set the day after year and month 68} 69 70int Date::getYear() const { 71 return year; 72} 73 74void Date::setYear(int y) { 75 if (y \u0026gt;= YEAR_MIN \u0026amp;\u0026amp; y \u0026lt;= YEAR_MAX) { 76 year = y; 77 } else { 78 throw invalid_argument(\u0026#34;Error: Invalid year (1753-9999)!\u0026#34;); 79 } 80} 81 82int Date::getMonth() const { 83 return month; 84} 85 86void Date::setMonth(int m) { 87 if (m \u0026gt;= 1 \u0026amp;\u0026amp; m \u0026lt;= 12) { 88 month = m; 89 } else { 90 throw invalid_argument(\u0026#34;Error: Invalid month (1-12)!\u0026#34;); 91 } 92} 93 94int Date::getDay() const { 95 return day; 96} 97 98// Assuming that the year and month are already set 99void Date::setDay(int d) { 100 int lastDayOfMonth = DAYS_IN_MONTHS[month-1]; 101 if (month == 2 \u0026amp;\u0026amp; isLeapYear(year)) { 102 lastDayOfMonth = 29; 103 } 104 if (d \u0026gt;= 1 \u0026amp;\u0026amp; d \u0026lt;= lastDayOfMonth) { 105 day = d; 106 } else { 107 throw invalid_argument(\u0026#34;Error: Invalid day (1-28|29|30|31)!\u0026#34;); 108 } 109} 110 111// Print this instance in the format \u0026#34;xxxday, d mmm yyyy\u0026#34;. 112void Date::print() const { 113 cout \u0026lt;\u0026lt; STR_DAYS[getDayOfWeek(year, month, day)] \u0026lt;\u0026lt; \u0026#34;, \u0026#34; 114 \u0026lt;\u0026lt; day \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; STR_MONTHS[month-1] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; year \u0026lt;\u0026lt; endl; 115} 116 117// Increment this instance to the next day and return this instance by reference 118Date\u0026amp; Date::nextDay() { 119 int lastDayOfMonth = DAYS_IN_MONTHS[month-1]; 120 if (month == 2 \u0026amp;\u0026amp; isLeapYear(year)) { 121 lastDayOfMonth = 29; 122 } 123 124 // check day against the end of month 125 if (++day \u0026gt; lastDayOfMonth) { 126 day = 1; 127 if (++month \u0026gt; 12) { 128 month = 1; 129 if (++year \u0026gt; YEAR_MAX) { 130 throw out_of_range(\u0026#34;Error: Next day is out of range!\u0026#34;); 131 } 132 } 133 } 134 return *this; 135} 136 137// Decrement this instance to the previous day and return this instance by reference 138Date\u0026amp; Date::previousDay() { 139 int lastDayOfMonth = DAYS_IN_MONTHS[month-1]; 140 if (month == 2 \u0026amp;\u0026amp; isLeapYear(year)) { 141 lastDayOfMonth = 29; 142 } 143 144 // check day against the end of month 145 if (--day \u0026lt; 1) { 146 day = lastDayOfMonth; 147 if (--month \u0026lt; 1) { 148 month = 12; 149 if (--year \u0026lt; YEAR_MIN) { 150 throw out_of_range(\u0026#34;Error: Previous day is out of range!\u0026#34;); 151 } 152 } 153 } 154 return *this; 155} 156 157// Increment this instance to the next month and return this instance by reference 158Date\u0026amp; Date::nextMonth() { 159 if (++month \u0026gt; 12) { 160 month = 1; 161 if (++year \u0026gt; YEAR_MAX) { 162 throw out_of_range(\u0026#34;Error: Next month is out of range!\u0026#34;); 163 } 164 } 165 // may need to adjust the last day of the month 166 int lastDayOfMonth = DAYS_IN_MONTHS[month-1]; 167 if (month == 2 \u0026amp;\u0026amp; isLeapYear(year)) { 168 lastDayOfMonth = 29; 169 } 170 if (day \u0026gt; lastDayOfMonth) { 171 day = lastDayOfMonth; 172 } 173 return *this; 174} 175 176// Decrement this instance to the previous month and return this instance by reference 177Date\u0026amp; Date::previousMonth() { 178 if (--month \u0026lt; 1) { 179 month = 12; 180 if (--year \u0026lt; YEAR_MIN) { 181 throw out_of_range(\u0026#34;Error: Previous month is out of range!\u0026#34;); 182 } 183 } 184 // may need to adjust the last day of the month 185 int lastDayOfMonth = DAYS_IN_MONTHS[month-1]; 186 if (month == 2 \u0026amp;\u0026amp; isLeapYear(year)) { 187 lastDayOfMonth = 29; 188 } 189 if (day \u0026gt; lastDayOfMonth) { 190 day = lastDayOfMonth; 191 } 192 return *this; 193} 194 195// Increment this instance to the next year and return this instance by reference 196Date\u0026amp; Date::nextYear() { 197 if (++year \u0026gt; YEAR_MAX) { 198 throw out_of_range(\u0026#34;Error: Next year is out of range!\u0026#34;); 199 } 200 // may need to adjust the last day of the month for leap year (29 Feb) 201 // to non-leap year (28 Feb) 202 if (month == 2 \u0026amp;\u0026amp; day == 29 \u0026amp;\u0026amp; !isLeapYear(year)) { 203 day = 28; 204 } 205 return *this; 206} 207 208// Decrement this instance to the previous year and return this instance by reference 209Date\u0026amp; Date::previousYear() { 210 if (--year \u0026lt; YEAR_MIN) { 211 throw out_of_range(\u0026#34;Error: Previous year is out of range!\u0026#34;); 212 } 213 // may need to adjust the last day of the month for leap year (29 Feb) 214 // to non-leap year (28 Feb) 215 if (month == 2 \u0026amp;\u0026amp; day == 29 \u0026amp;\u0026amp; !isLeapYear(year)) { 216 day = 28; 217 } 218 return *this; 219} TestDate.cpp\n1/* Test Driver Program (TestDate.cpp) */ 2#include \u0026lt;iostream\u0026gt; 3#include \u0026lt;stdexcept\u0026gt; 4#include \u0026#34;Date.h\u0026#34; 5 6int main() { 7 Date d1(2012, 1, 1); 8 d1.print(); // Sunday, 1 Jan 2012 9 d1.nextDay().print(); // Monday, 2 Jan 2012 10 d1.print(); // Monday, 2 Jan 2012 11 12 d1.setDate(2012, 1, 31); 13 d1.print(); // Tuesday, 31 Jan 2012 14 d1.nextDay().print(); // Wednesday, 1 Feb 2012 15 16 d1.setDate(2012, 2, 28); 17 d1.print(); // Tuesday, 28 Feb 2012 18 d1.nextDay().print(); // Wednesday, 29 Feb 2012 19 20 d1.setDate(2012, 12, 31); 21 d1.print(); // Monday, 31 Dec 2012 22 d1.nextDay().print(); // Tuesday, 1 Jan 2013 23 24// Date d2(2011, 2, 29); // abrupt termination! 25// d2.print(); 26 27 try { // graceful handling of exception 28 Date d3(2011, 2, 29); 29 d3.print(); 30 } catch (invalid_argument \u0026amp;ex) { 31 cout \u0026lt;\u0026lt; ex.what() \u0026lt;\u0026lt; endl; // Error: Invalid day (1-28|29|30|31)! 32 } 33 cout \u0026lt;\u0026lt; \u0026#34;Next Statement after try-catch\u0026#34; \u0026lt;\u0026lt; endl; 34 35 try { // graceful handling of exception 36 Date d4(9999, 12, 30); 37 d4.nextDay().print(); // Friday, 31 Dec 9999 38 d4.nextDay(); 39 d4.print(); 40 } catch (out_of_range \u0026amp;ex) { 41 cout \u0026lt;\u0026lt; ex.what() \u0026lt;\u0026lt; endl; // Error: Next day is outside the valid range! 42 } 43 44 Date d5(2012, 1, 1); 45 d5.previousDay().print(); // Saturday, 31 Dec 2011 46 47 Date d6(2012, 3, 31); 48 d6.nextMonth().print(); // Monday, 30 Apr 2012 49 50 Date d7(2012, 3, 31); 51 d7.previousMonth().print(); // Wednesday, 29 Feb 2012 52 53 Date d8(2012, 2, 29); 54 d8.nextYear().print(); // Thursday, 28 Feb 2013 55 56 Date d9(2012, 2, 29); 57 d9.previousYear().print(); // Monday, 28 Feb 2011 58} ","date":"March 2, 2018","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/cpp/2018-03-02-c++%E7%BC%96%E7%A8%8B%E4%B9%8Boop%E7%A4%BA%E4%BE%8B/","series":[],"smallImg":"","tags":[{"title":"C++","url":"/blog/tags/c++/"}],"timestamp":1519948800,"title":"c++编程之OOP示例"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"Programming","url":"/blog/categories/programming/"}],"content":"指针，引用和动态分配内存是 C/C++语言中最强大的特性，这些特性使得程序员能够直接操作计算机中非常珍贵的记忆体资源，进而对内存进行最大性能和高效的使用。 然而指针也是一把双刃剑，它也是 C/C++编程语言中最复杂和最难的特性。\n指针之所以这么强大，是因为它允许你通过地址来访问和操作对应记忆体中存储的内容。但是指针也很难被驾驭，使用好的话确实能够大大提升性能，而用的 不好的话，也会导致很多问题，例如著名的内存泄漏和缓冲区溢出，这些 bug 会致使系统发生紊乱。一些新的编程语言（例如 Java 和 C#），将指针从它的语法 中去掉，通过提供自动内存管理的方式来避免使用指针导致的许多问题。\n虽然你在编写 C/C++代码的时候可以不使用指针，但是在学习 C/C++的时候很难不提及指针。指针也许不是为新手和笨蛋而设计的。\n1. 指针变量 计算机记忆体位置有一个地址，对应地址处保存数据。记忆体地址通常是一个数字（一般用十六进制表示），这个数字很难被程序员直接使用。通常一个地址位置 的容量是 8-bit（也就是 1-byte），里面可以存储整数，实数，字符或者字符串，这完全取决于程序员如何解析。\n为了减轻程序员使用数字地址和解析数据的负担，早期的编程语言（例如 C 语言）中产生了一种新的变量——这种变量是一个被命名了的变量的位置，它可以存储一个特定类型的值。 取代数字地址的是用名字（或者标识符）直接关联到确定的地址上，而且变量类型（如int, double, char）与之关联，从而简化了对数据的解析。\n每个内存地址占 8 位（也就是 1 个字节），一个 4 个字节的int值需要 4 个内存位置。一个 32 位的系统通常使用 32 位的地址。同样的，存储这个 32 位的地址也需要 4 个内存位置。\n下面的插图形象的描绘了计算机内存地址，内存中数据，变量名，变量类型以及变量值之间的关系。\n1.1 指针变量 指针变量（简称指针）基本上跟其他变量一样，都可以用来存放数据，但是跟普通变量不同的是，普通变量存储的是数值，而指针存放的是内存地址。\n1.2 申明指针 指针在使用前必须先申明。申明指针的语法是在指针名前加上一个*符号。指针必须跟类型关联。\n1type *ptr; 2// or 3type* ptr; 4// or 5type * ptr; 例如：\n1int * iPtr; 2double *dPtr; 需要注意的是，*必须放在指针变量名前面，一个*只作用于跟在它后面的指针变量名。*在申明语句中不是一个操作符，仅仅表明跟在它后门的变量是一个指针变量。\n例如：\n1int *p1, *p2, i; 2int* p1, p2, i; 3int * p1, * p2, i; 指针变量名的命名规则：用\u0026quot;p\u0026quot;或者\u0026quot;ptr\u0026quot;作为前缀或后缀。\n1.3 使用取址操作符(\u0026)初始化指针 当你申明一个指针的时候，它并没有被初始化。也就是说，它指向一个不确定的非法地址，这是很危险的。你需要通过给它赋值为一个合法地址来对它进行初始化，而要完成这一 操作，需要使用取址操作符(\u0026amp;)。\n取址操作符(\u0026amp;)作用于变量，返回该变量的地址。例如，如果number是一个int类型的变量，那么\u0026amp;number返回的就是这个变量的地址。\n1int number = 80; 2int *pNumber; 3pNumber = \u0026amp;number; 4 5int *pAnother = \u0026amp;number; 如上图所示，int型变量number的起始地址是0x22ccec，其中存放了一个int值 88。表达式\u0026amp;number返回该变量的地址，也就是0x22ccec，然后赋值给了指针变量pNumber。 取址操作符只能用在 RHS(right hand side).\n1.4 间接寻址或解引操作符(\\*) 间接寻址操作符（或解引操作符）(*)作用于指针变量，返回存放在指针指向地址处的数据。例如，如果pNumber是一个int型指针，*pNumber返回指针pNumber指向的int数值。\n1int number = 88; 2int *pNumber = \u0026amp;number; 3cout \u0026lt;\u0026lt; pNumber \u0026lt;\u0026lt; endl; 4cout \u0026lt;\u0026lt; *pNumber \u0026lt;\u0026lt; endl; 5*pNumber = 99; 6cout \u0026lt;\u0026lt; *pNumber \u0026lt;\u0026lt; endl; 7cout \u0026lt;\u0026lt; number \u0026lt;\u0026lt; endl; 需要注意的是pNumber存放的是内存地址，也就是说*pNumber是指指针存放的地址处存放的数值，或者也可以说是指针指向的数值。\n正如前面插图描绘的，变量直接引用数值，而指针通过内存地址间接引用数值。而这种间接引用被称为间接寻址或解引。\n解引操作符既能被用于 RHS(temp = *pNumber)，也可以被用于 LHS(*pNumber = 99).\n注意：*在申明语句中和表达式中有不同的含义，在申明语句中，它表示跟在它后门的变量是一个指针变量，而在表达式中，它指的是指针指向的数值。\n1.5 指针也有类型 指针在申明的时候就要确定它所关联的类型。指针只能保存它所申明的类型的变量的地址。\n1int i = 88; 2double d = 55.66; 3int *iPtr = \u0026amp;i; 4double *dPtr = \u0026amp;d; 5 6iPtr = \u0026amp;d; // ERROR, cannot hold address of different type 7dPtr = \u0026amp;i; // ERROR 8iPtr = i; // ERROR, pointer holds address of an int , NOT int value 9 10int j = 99; 11iPtr = \u0026amp;j; // You can change the address stored in a pointer. 示例\n1#include \u0026lt;iostream\u0026gt; 2 3using namespace std; 4 5int main(int argc, char *argv[]) 6{ 7\tint number = 88; 8\tint *pNumber; 9\tpNumber = \u0026amp;number; 10 11\tcout \u0026lt;\u0026lt; pNumber \u0026lt;\u0026lt; endl; 12\tcout \u0026lt;\u0026lt; \u0026amp;number \u0026lt;\u0026lt; endl; 13\tcout \u0026lt;\u0026lt; *pNumber \u0026lt;\u0026lt; endl; 14\tcout \u0026lt;\u0026lt; number \u0026lt;\u0026lt; endl; 15 16\t*pNumber = 99; 17\tcout \u0026lt;\u0026lt; pNumber \u0026lt;\u0026lt; endl; 18\tcout \u0026lt;\u0026lt; \u0026amp;number \u0026lt;\u0026lt; endl; 19\tcout \u0026lt;\u0026lt; *pNumber \u0026lt;\u0026lt; endl; 20\tcout \u0026lt;\u0026lt; number \u0026lt;\u0026lt; endl; 21 22\tcout \u0026lt;\u0026lt; \u0026amp;pNumber \u0026lt;\u0026lt; endl; 23\treturn 0; 24} 运行结果为：\n1→ g++ test_pointer.cpp \u0026amp;\u0026amp; ./a.out 20x7ffee123c04c 30x7ffee123c04c 488 588 60x7ffee123c04c 70x7ffee123c04c 899 999 100x7ffee123c040 注意：你得到的地址可能跟我得到的不同，操作系统将程序加载到可用的空闲地址，而不是固定的地址。\n1.7 空指针 你可以将指针初始化为0或者NULL，那么它将指向空，我们称之为空指针。解引空指针会引发STATUS_ACCESS_VIOLATION异常。\n1int *iPtr = 0; 2cout \u0026lt;\u0026lt; *iPtr \u0026lt;\u0026lt; endl; // ERROR! STATUS_ACCESS_VIOLATION exception 3 4int *p = NULL; 2. 引用变量 C++增加了一种叫做引用变量（或者简称为引用）的特性。一个引用就是一个已有变量的别名。例如，假设给paul起了个引用（别名）peter，那么peter和paul都指的是同一个人。\n引用的主要作用就是作为函数的形参以实现按引用传递(pass-by-reference)的特性。当一个引用变量传递给函数的时候，函数作用于该变量的原始值（而不是变量的拷贝）。对于该变量的操作 会同时反映到函数内和函数外部。\n引用类似于指针，在一些情况下，引用可以取代指针，尤其是作为函数参数的时候。\n2.1 引用（别名）(\u0026) 回顾前面讲到的，C/C++使用\u0026amp;符号在表达式中作为取址操作符，而 C++赋予了它额外的含义，在 C++的申明语句中，可以用\u0026amp;申明一个引用变量。\n当\u0026amp;用于申明语句（包括函数形参）中的时候，它是类型标识符的一部分，用于申明一个引用变量。\n1type \u0026amp;newName = existingName; 2// or 3type\u0026amp; newName = existingName; 4// or 5type \u0026amp; newName = existingName; \u0026ldquo;newName\u0026quot;被称为\u0026quot;existingName\u0026quot;的引用或别名。此时，你可以通过\u0026quot;newName\u0026quot;或\u0026quot;existingName\u0026quot;访问变量。\n1#include \u0026lt;iostream\u0026gt; 2 3using namespace std; 4 5int main(int argc, char *argv[]) 6{ 7\tint number = 88; 8\tint \u0026amp;refNumber = number; 9 10\tcout \u0026lt;\u0026lt; number \u0026lt;\u0026lt; endl; 11\tcout \u0026lt;\u0026lt; refNumber \u0026lt;\u0026lt; endl; 12 13\trefNumber = 99; 14\tcout \u0026lt;\u0026lt; number \u0026lt;\u0026lt; endl; 15\tcout \u0026lt;\u0026lt; refNumber \u0026lt;\u0026lt; endl; 16 17\tnumber = 55; 18\tcout \u0026lt;\u0026lt; number \u0026lt;\u0026lt; endl; 19\tcout \u0026lt;\u0026lt; refNumber \u0026lt;\u0026lt; endl; 20 21\treturn 0; 22} 编译运行结果为：\n1→ g++ test_reference.cpp \u0026amp;\u0026amp; ./a.out 288 388 499 599 655 755 2.2 引用是如何工作的？ 引用跟指针的工作原理一样，如图说是，引用保存的是变量的地址：\n2.3 引用 vs. 指针 指针和引用是等价的，除了以下几种情况：\n1 引用是一个地址的名字常量，声明的时候必须初始化\n1int \u0026amp; iRef; // ERROR: \u0026#39;iRef\u0026#39; declared as reference but not initialized 引用一旦建立，不能修改。\n2 获取指针指向的数据，需要使用解引操作，而给指针赋值，需要用到取址操作符。而在引用中，引用和解引都是隐式的。\n1#include \u0026lt;iostream\u0026gt; 2 3using namespace std; 4 5int main(int argc, char *argv[]) 6{ 7\tint number1 = 88, number2 = 22; 8 9\t// Create a pointer pointing to number1; 10\tint *pNumber1 = \u0026amp;number1; 11\t*pNumber1 = 99; 12\tcout \u0026lt;\u0026lt; *pNumber1 \u0026lt;\u0026lt; endl; 13\tcout \u0026lt;\u0026lt; \u0026amp;number1 \u0026lt;\u0026lt; endl; 14\tcout \u0026lt;\u0026lt; pNumber1 \u0026lt;\u0026lt; endl; 15\tcout \u0026lt;\u0026lt; \u0026amp;pNumber1 \u0026lt;\u0026lt; endl; 16 17\tpNumber1 = \u0026amp;number2; 18 19\t// Create a reference (alias) to number1 20\tint \u0026amp;refNumber1 = number1; 21\trefNumber1 = 11; 22\tcout \u0026lt;\u0026lt; refNumber1 \u0026lt;\u0026lt; endl; 23\tcout \u0026lt;\u0026lt; \u0026amp;number1 \u0026lt;\u0026lt; endl; 24\tcout \u0026lt;\u0026lt; \u0026amp;refNumber1 \u0026lt;\u0026lt; endl; 25 26\t// refNumber1 = \u0026amp;number2; // Error! Reference cannot be re-assigned 27 28\trefNumber1 = number2; 29\tnumber2++; 30\tcout \u0026lt;\u0026lt; refNumber1 \u0026lt;\u0026lt; endl; 31\tcout \u0026lt;\u0026lt; number1 \u0026lt;\u0026lt; endl; 32\tcout \u0026lt;\u0026lt; number2 \u0026lt;\u0026lt; endl; 33\treturn 0; 34} 编译运行结果：\n1→ g++ test_pointer_reference.cpp \u0026amp;\u0026amp; ./a.out 299 30x7ffeeacc503c 40x7ffeeacc503c 50x7ffeeacc5030 611 70x7ffeeacc503c 80x7ffeeacc503c 922 1022 1123 引用为已有的变量提供了一个别名。引用包含了隐式的解引操作，所以不需要使用*操作符来显式解引。而指针变量存储的是地址，你可以修改它存储的地址，访问指针指向的数据需要显式解引操作。引用可以被视为常量指针，它在申明的时候必须初始化，而且它的值不能被修改。 引用很接近于指针，在一些情况下，引用可以代替指针。引用允许你通过指针管理对象而不需要使用指针的语法。\n2.4 引用参数 vs. 指针参数，两种实现 Pass-By-Reference 的方式 Pass-by-Value\n在 C/C++中，默认情况下，函数参数是按值传递给函数的。也就是说，函数中接收的是参数的一份拷贝，在函数体内对参数的操作不会影响到函数体外部，换句话说，被呼叫的函数没有访问呼叫者的变量：\n1#include \u0026lt;iostream\u0026gt; 2 3using namespace std; 4 5int square(int); 6 7int main(int argc, char *argv[]) 8{ 9\tint number = 8; 10\tcout \u0026lt;\u0026lt; \u0026#34;In main():\u0026#34; \u0026lt;\u0026lt; \u0026amp;number \u0026lt;\u0026lt; endl; 11\tcout \u0026lt;\u0026lt; number \u0026lt;\u0026lt; endl; 12\tcout \u0026lt;\u0026lt; square(number) \u0026lt;\u0026lt; endl; 13\tcout \u0026lt;\u0026lt; number \u0026lt;\u0026lt; endl; 14\treturn 0; 15} 16 17int square(int n) { 18\tcout \u0026lt;\u0026lt; \u0026#34;In square():\u0026#34; \u0026lt;\u0026lt; \u0026amp;n \u0026lt;\u0026lt; endl; 19\tn *= n; 20\treturn n; 21} 编译运行：\n1→ g++ call_by_value.cpp \u0026amp;\u0026amp; ./a.out 2In main():0x7ffee38b909c 38 4In square():0x7ffee38b904c 564 68 通过指针参数实现 Pass-by-Reference\n有时候，我们希望直接修改原始对象来避免没必要的拷贝，这样就需要使用到 pass-by-reference，下面是使用指针实现 pass-by-reference 的例子：\n1#include \u0026lt;iostream\u0026gt; 2 3using namespace std; 4 5void square(int *); 6 7int main(int argc, char *argv[]) 8{ 9\tint number = 8; 10\tcout \u0026lt;\u0026lt; \u0026#34;In main():\u0026#34; \u0026lt;\u0026lt; \u0026amp;number \u0026lt;\u0026lt; endl; 11\tcout \u0026lt;\u0026lt; number \u0026lt;\u0026lt; endl; 12\tsquare(\u0026amp;number); 13\tcout \u0026lt;\u0026lt; number \u0026lt;\u0026lt; endl; 14\treturn 0; 15} 16 17void square(int *pNumber) { 18\tcout \u0026lt;\u0026lt; \u0026#34;In square():\u0026#34; \u0026lt;\u0026lt; pNumber \u0026lt;\u0026lt; endl; 19\t*pNumber *= *pNumber; 20} 编译运行：\n1→ g++ call_by_ref_with_pointer.cpp \u0026amp;\u0026amp; ./a.out 2In main():0x7ffee23e20ac 38 4In square():0x7ffee23e20ac 564 译者注：\n在 C/C++中，使用指针参数并不能称作Pass-by-Reference，因为指针作为参数的实质还是call-by-value，因为指针存放的是地址， 所以指针的拷贝中存放的也是同样的地址，对指针指向的数据的操作会改变到函数外部的数值。验证函数是否为call-by-ref，实参的地址，内外是否相同：\n1#include \u0026lt;iostream\u0026gt; 2 3using namespace std; 4 5void foo(int *pNumber); 6 7int main(int argc, char *argv[]) 8{ 9\tint a = 10; 10\tint *pNumber = \u0026amp;a; 11\tcout \u0026lt;\u0026lt; \u0026amp;pNumber \u0026lt;\u0026lt; endl; 12\tfoo(pNumber); 13\treturn 0; 14} 15 16void foo(int *pNumber) { 17\tcout \u0026lt;\u0026lt; \u0026amp;pNumber \u0026lt;\u0026lt; endl; 18} 运行结果为：\n1→ g++ test.cpp \u0026amp;\u0026amp; ./a.out 20x7ffee59c80c0 30x7ffee59c8088 使用引用实现 Pass-by-reference\n除了上面使用指针的方式实现 Pass-by-Reference，你还可以使用引用实现。\n1#include \u0026lt;iostream\u0026gt; 2 3using namespace std; 4 5void square(int \u0026amp;); 6 7int main() { 8\tint number = 8; 9\tcout \u0026lt;\u0026lt; \u0026#34;In main():\u0026#34; \u0026lt;\u0026lt; \u0026amp;number \u0026lt;\u0026lt; endl; 10\tcout \u0026lt;\u0026lt; number \u0026lt;\u0026lt; endl; 11\tsquare(number); 12\tcout \u0026lt;\u0026lt; number \u0026lt;\u0026lt; endl; 13} 14 15void square(int \u0026amp;rNumber) { 16\tcout \u0026lt;\u0026lt; \u0026#34;In square():\u0026#34; \u0026lt;\u0026lt; \u0026amp;rNumber \u0026lt;\u0026lt; endl; 17\trNumber *= rNumber; 18} \u0026ldquo;const\u0026rdquo; 参数\n函数的形式参数如果被\u0026quot;const\u0026quot;修饰的话，那么实参在函数体内部是不能被修改的。 被\u0026quot;const\u0026quot;修饰的形参既能接收\u0026quot;const\u0026quot;类型的实参也能接收非\u0026quot;const\u0026quot;类型的实参，而一个非\u0026quot;const\u0026quot;类型的引用/指针参数，只能接收 非\u0026quot;const\u0026quot;类型的实参：\n1#include \u0026lt;iostream\u0026gt; 2 3using namespace std; 4 5int squareConst(const int number) { 6\t// number *= number; // error: assignment of read-only parameter 7\treturn number * number; 8} 9 10int squareNonConst(int number) { 11\tnumber *= number; 12\treturn number; 13} 14 15int squareConstRef(const int \u0026amp; number) { 16\treturn number * number; 17} 18 19int squareNonConstRef(int * number) { 20\treturn number * number; 21} 22 23int main() { 24\tint number = 8; 25\tcout int constNumber = 9; 26\tcout \u0026lt;\u0026lt; squareConst(number) \u0026lt;\u0026lt; endl; 27\tcout \u0026lt;\u0026lt; squareConst(constNumber) \u0026lt;\u0026lt; endl; 28\tcout \u0026lt;\u0026lt; squareNonConst(number) \u0026lt;\u0026lt; endl; 29\tcout \u0026lt;\u0026lt; squareNonConstRef(constNumber) \u0026lt;\u0026lt; endl; 30\tcout \u0026lt;\u0026lt; squareConstRef(number) \u0026lt;\u0026lt; endl; 31 32\tcout \u0026lt;\u0026lt; squareConstRef(constNumber) \u0026lt;\u0026lt; endl; 33\tcout \u0026lt;\u0026lt; squareNonConstRef(number) \u0026lt;\u0026lt; endl; 34\t// cout \u0026lt;\u0026lt; squareNonConstRef(constNumber) \u0026lt;\u0026lt; endl; 35 // error: invalid initialization of reference of 36 // type \u0026#39;int\u0026amp;\u0026#39; from expression of type \u0026#39;const int\u0026#39; 37 38\treturn 0; 39} 2.5 函数的返回值 函数返回引用\n函数的返回值既可以是引用也可以是指针，例如：\n1/* Passing back return value using reference (TestPassByReferenceReturn.cpp) */ 2#include \u0026lt;iostream\u0026gt; 3using namespace std; 4 5int \u0026amp; squareRef(int \u0026amp;); 6int * squarePtr(int *); 7 8int main() { 9 int number1 = 8; 10 cout \u0026lt;\u0026lt; \u0026#34;In main() \u0026amp;number1: \u0026#34; \u0026lt;\u0026lt; \u0026amp;number1 \u0026lt;\u0026lt; endl; // 0x22ff14 11 int \u0026amp; result = squareRef(number1); 12 cout \u0026lt;\u0026lt; \u0026#34;In main() \u0026amp;result: \u0026#34; \u0026lt;\u0026lt; \u0026amp;result \u0026lt;\u0026lt; endl; // 0x22ff14 13 cout \u0026lt;\u0026lt; result \u0026lt;\u0026lt; endl; // 64 14 cout \u0026lt;\u0026lt; number1 \u0026lt;\u0026lt; endl; // 64 15 16 int number2 = 9; 17 cout \u0026lt;\u0026lt; \u0026#34;In main() \u0026amp;number2: \u0026#34; \u0026lt;\u0026lt; \u0026amp;number2 \u0026lt;\u0026lt; endl; // 0x22ff10 18 int * pResult = squarePtr(\u0026amp;number2); 19 cout \u0026lt;\u0026lt; \u0026#34;In main() pResult: \u0026#34; \u0026lt;\u0026lt; pResult \u0026lt;\u0026lt; endl; // 0x22ff10 20 cout \u0026lt;\u0026lt; *pResult \u0026lt;\u0026lt; endl; // 81 21 cout \u0026lt;\u0026lt; number2 \u0026lt;\u0026lt; endl; // 81 22} 23 24int \u0026amp; squareRef(int \u0026amp; rNumber) { 25 cout \u0026lt;\u0026lt; \u0026#34;In squareRef(): \u0026#34; \u0026lt;\u0026lt; \u0026amp;rNumber \u0026lt;\u0026lt; endl; // 0x22ff14 26 rNumber *= rNumber; 27 return rNumber; 28} 29 30int * squarePtr(int * pNumber) { 31 cout \u0026lt;\u0026lt; \u0026#34;In squarePtr(): \u0026#34; \u0026lt;\u0026lt; pNumber \u0026lt;\u0026lt; endl; // 0x22ff10 32 *pNumber *= *pNumber; 33 return pNumber; 34} 不要返回函数体内本地变量的引用\n1/* Test passing the result (TestPassResultLocal.cpp) */ 2#include \u0026lt;iostream\u0026gt; 3using namespace std; 4 5int * squarePtr(int); 6int \u0026amp; squareRef(int); 7 8int main() { 9 int number = 8; 10 cout \u0026lt;\u0026lt; number \u0026lt;\u0026lt; endl; // 8 11 cout \u0026lt;\u0026lt; *squarePtr(number) \u0026lt;\u0026lt; endl; // ?? 12 cout \u0026lt;\u0026lt; squareRef(number) \u0026lt;\u0026lt; endl; // ?? 13} 14 15int * squarePtr(int number) { 16 int localResult = number * number; 17 return \u0026amp;localResult; 18 // warning: address of local variable \u0026#39;localResult\u0026#39; returned 19} 20 21int \u0026amp; squareRef(int number) { 22 int localResult = number * number; 23 return localResult; 24 // warning: reference of local variable \u0026#39;localResult\u0026#39; returned 25} 上面的程序有一个严重的逻辑错误，因为函数体内的本地变量的引用被函数返回。本地变量的作用于只在函数体内 ��������������� 放函数退出的时候，函数体内的本地变量就会被销毁。 GCC 编译器足够聪明，在编译上述代码的时候会给出警告（但不是错误）。\n将动态申请的内存作为引用返回\n1/* Test passing the result (TestPassResultNew.cpp) */ 2#include \u0026lt;iostream\u0026gt; 3using namespace std; 4 5int * squarePtr(int); 6int \u0026amp; squareRef(int); 7 8int main() { 9 int number = 8; 10 cout \u0026lt;\u0026lt; number \u0026lt;\u0026lt; endl; // 8 11 cout \u0026lt;\u0026lt; *squarePtr(number) \u0026lt;\u0026lt; endl; // 64 12 cout \u0026lt;\u0026lt; squareRef(number) \u0026lt;\u0026lt; endl; // 64 13} 14 15int * squarePtr(int number) { 16 int * dynamicAllocatedResult = new int(number * number); 17 return dynamicAllocatedResult; 18} 19 20int \u0026amp; squareRef(int number) { 21 int * dynamicAllocatedResult = new int(number * number); 22 return *dynamicAllocatedResult; 23} 2.6 总结 指针和引用掌握起来都很复杂，但是它们能提高程序的效率。所以一定要深入理解，合理使用。\n3. 动态内存分配 3.1 new 和 delete 操作符 除了定义一个int型变量，然后将其地址赋值给int指针，记忆体也可以在运行时通过new操作符动态分配。 在 C++里，但凡只用new动态分配的记忆体，都需要使用delete来释放，也就是将内存返还给堆。\nnew操作符返回指向分配的记忆体的指针，delete操作符需要一个指针作为唯一参数。\n1// Static allocation 2int number = 88; 3int * p1 = \u0026amp;number; // Assign a \u0026#34;valid\u0026#34; address into pointer 4 5// Dynamic Allocation 6int * p2; // Not initialize, points to somewhere which is invalid 7cout \u0026lt;\u0026lt; p2 \u0026lt;\u0026lt; endl; // Print address before allocation 8p2 = new int; // Dynamically allocate an int and assign its address to pointer 9 // The pointer gets a valid address with memory allocated 10*p2 = 99; 11cout \u0026lt;\u0026lt; p2 \u0026lt;\u0026lt; endl; // Print address after allocation 12cout \u0026lt;\u0026lt; *p2 \u0026lt;\u0026lt; endl; // Print value point-to 13delete p2; // Remove the dynamically allocated storage 注意到，new和delete都作用于指针。\n初始化一个动态分配的记忆体，可以使用基本数据类型的初始化，也可以调用构造函数来初始化对象。\n1// use an initializer to initialize a fundamental type (such as int, double) 2int * p1 = new int(88); 3double * p2 = new double(1.23); 4 5// C++11 brace initialization syntax 6int * p1 = new int {88}; 7double * p2 = new double {1.23}; 8 9// invoke a constructor to initialize an object (such as Date, Time) 10Date * date1 = new Date(1999, 1, 1); 11Time * time1 = new Time(12, 34, 56); 你也可以在函数内动态分配一个全局指针变量。动态分配的记忆体在函数调用后一直被占用，直到被释放。\n1// Dynamically allocate global pointers (TestDynamicAllocation.cpp) 2#include \u0026lt;iostream\u0026gt; 3using namespace std; 4 5int * p1, * p2; // Global int pointers 6 7// This function allocates storage for the int* 8// which is available outside the function 9void allocate() { 10 p1 = new int; // Allocate memory, initial content unknown 11 *p1 = 88; // Assign value into location pointed to by pointer 12 p2 = new int(99); // Allocate and initialize 13} 14 15int main() { 16 allocate(); 17 cout \u0026lt;\u0026lt; *p1 \u0026lt;\u0026lt; endl; // 88 18 cout \u0026lt;\u0026lt; *p2 \u0026lt;\u0026lt; endl; // 99 19 delete p1; // Deallocate 20 delete p2; 21 return 0; 22} 静态分配和动态分配的主要区别：\n静态分配是编译器通过内存管理器自动完成的，而动态分配，是程序员自己操作的。对于动态分配的记忆体，程序员有对这段记忆体的全部控制权。 静态分配是通过变量名管理的，而动态分配是通过指针。 3.2 new[] 和 delete[] 操作符 动态数组是在运行时通过new[]操作符动态分配的。相应的通过delete[]操作符释放。\n1/* Test dynamic allocation of array (TestDynamicArray.cpp) */ 2#include \u0026lt;iostream\u0026gt; 3#include \u0026lt;cstdlib\u0026gt; 4using namespace std; 5 6int main() { 7 const int SIZE = 5; 8 int * pArray; 9 10 pArray = new int[SIZE]; // Allocate array via new[] operator 11 12 // Assign random numbers between 0 and 99 13 for (int i = 0; i \u0026lt; SIZE; ++i) { 14 *(pArray + i) = rand() % 100; 15 } 16 // Print array 17 for (int i = 0; i \u0026lt; SIZE; ++i) { 18 cout \u0026lt;\u0026lt; *(pArray + i) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 19 } 20 cout \u0026lt;\u0026lt; endl; 21 22 delete[] pArray; // Deallocate array via delete[] operator 23 return 0; 24} C++03 不允许初始化动态分配的数组，C++11 中可以用下面的方式对动态数组初始化：\n1int *p = new int[5] {1, 2, 3, 4, 5}; 4 指针，数组和函数 4.1 数组被视为指针 在 C/C++中，数组的名字就是指向数组第一个元素的地址的指针。例如有一个int类型数组\u0026quot;numbers\u0026rdquo;，\u0026ldquo;numbers\u0026quot;就是\u0026amp;numbers[0]，相应地，*numbers是numbers[0], *(numbers + i) 是 numbers[i]\n1/* Pointer and Array (TestPointerArray.cpp) */ 2#include \u0026lt;iostream\u0026gt; 3using namespace std; 4 5int main() { 6 const int SIZE = 5; 7 int numbers[SIZE] = {11, 22, 44, 21, 41}; // An int array 8 9 // The array name numbers is an int pointer, pointing at the 10 // first item of the array, i.e., numbers = \u0026amp;numbers[0] 11 cout \u0026lt;\u0026lt; \u0026amp;numbers[0] \u0026lt;\u0026lt; endl; // Print address of first element (0x22fef8) 12 cout \u0026lt;\u0026lt; numbers \u0026lt;\u0026lt; endl; // Same as above (0x22fef8) 13 cout \u0026lt;\u0026lt; *numbers \u0026lt;\u0026lt; endl; // Same as numbers[0] (11) 14 cout \u0026lt;\u0026lt; *(numbers + 1) \u0026lt;\u0026lt; endl; // Same as numbers[1] (22) 15 cout \u0026lt;\u0026lt; *(numbers + 4) \u0026lt;\u0026lt; endl; // Same as numbers[4] (41) 16} 4.2 指针运算 正如上一节中提到的，如果\u0026rsquo;numbers\u0026rsquo;是一个int型的数组，它可以被视为int型的指针，指向这个数组的第一个元素。(numbers + 1)指向下一个元素，需要注意的是， int通常占 4 字节，也就是说(numbers + 1)会增加 4 个地址位置，或者sizeof(int)个步长。\n1int numbers[] = {11, 22, 33}; 2int * iPtr = numbers; 3cout \u0026lt;\u0026lt; iPtr \u0026lt;\u0026lt; endl; // 0x22cd30 4cout \u0026lt;\u0026lt; iPtr + 1 \u0026lt;\u0026lt; endl; // 0x22cd34 (increase by 4 - sizeof int) 5cout \u0026lt;\u0026lt; *iPtr \u0026lt;\u0026lt; endl; // 11 6cout \u0026lt;\u0026lt; *(iPtr + 1) \u0026lt;\u0026lt; endl; // 22 7cout \u0026lt;\u0026lt; *iPtr + 1 \u0026lt;\u0026lt; endl; // 12 4.3 sizeof 数组 对数组执行sizeof操作会返回该数组所占用的字节数。你可以通过数组总字节数除以单个元素字节数来计算数组长度。\n1int numbers[100]; 2cout \u0026lt;\u0026lt; sizeof(numbers) \u0026lt;\u0026lt; endl; // Size of entire array in bytes (400) 3cout \u0026lt;\u0026lt; sizeof(numbers[0]) \u0026lt;\u0026lt; endl; // Size of first element of the array in bytes (4) 4cout \u0026lt;\u0026lt; \u0026#34;Array size is \u0026#34; \u0026lt;\u0026lt; sizeof(numbers) / sizeof(numbers[0]) \u0026lt;\u0026lt; endl; // (100) 4.4 数组作为函数参数或返回值 将数组传递给函数实际上传递的是数组第一个元素的指针。在申明函数的时候既可以使用数组形式，也可以使用指针形式，例如下面的申明是等效的：\n1int max(int numbers[], int size); 2int max(int *numbers, int size); 3int max(int number[50], int size); 上面的申明中参数都会被编译器视为int *，给定的数组大小会被忽略。\n数组的大小不是数组参数的一部分，所以需要传递另一个整数参数来指定数组长度。编译器不能根据数组指针推断数组长度，也不会检查数组边界。\n下面是使用数组申明的例子：\n1/* Passing array in/out function (TestArrayPassing.cpp) */ 2#include \u0026lt;iostream\u0026gt; 3using namespace std; 4 5// Function prototypes 6int max(const int arr[], int size); 7void replaceByMax(int arr[], int size); 8void print(const int arr[], int size); 9 10int main() { 11 const int SIZE = 4; 12 int numbers[SIZE] = {11, 22, 33, 22}; 13 print(numbers, SIZE); 14 cout \u0026lt;\u0026lt; max(numbers, SIZE) \u0026lt;\u0026lt; endl; 15 replaceByMax(numbers, SIZE); 16 print(numbers, SIZE); 17} 18 19// Return the maximum value of the given array. 20// The array is declared const, and cannot be modified inside the function. 21int max(const int arr[], int size) { 22 int max = arr[0]; 23 for (int i = 1; i \u0026lt; size; ++i) { 24 if (max \u0026lt; arr[i]) max = arr[i]; 25 } 26 return max; 27} 28 29// Replace all elements of the given array by its maximum value 30// Array is passed by reference. Modify the caller\u0026#39;s copy. 31void replaceByMax(int arr[], int size) { 32 int maxValue = max(arr, size); 33 for (int i = 0; i \u0026lt; size; ++i) { 34 arr[i] = maxValue; 35 } 36} 37 38// Print the array\u0026#39;s content 39void print(const int arr[], int size) { 40 cout \u0026lt;\u0026lt; \u0026#34;{\u0026#34;; 41 for (int i = 0; i \u0026lt; size; ++i) { 42 cout \u0026lt;\u0026lt; arr[i]; 43 if (i \u0026lt; size - 1) cout \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; 44 } 45 cout \u0026lt;\u0026lt; \u0026#34;}\u0026#34; \u0026lt;\u0026lt; endl; 46} 接着是使用指针申明的例子：\n1/* Passing array in/out function using pointer (TestArrayPassingPointer.cpp) */ 2#include \u0026lt;iostream\u0026gt; 3using namespace std; 4 5// Function prototype 6int max(const int *arr, int size); 7 8int main() { 9 const int SIZE = 5; 10 int numbers[SIZE] = {10, 20, 90, 76, 22}; 11 cout \u0026lt;\u0026lt; max(numbers, SIZE) \u0026lt;\u0026lt; endl; 12} 13 14// Return the maximum value of the given array 15int max(const int *arr, int size) { 16 int max = *arr; 17 for (int i = 1; i \u0026lt; size; ++i) { 18 if (max \u0026lt; *(arr+i)) max = *(arr+i); 19 } 20 return max; 21} 4.5 Pass-by-Reference 和 sizeof 1/* Test sizeof array (TestSizeofArray.cpp) */ 2#include \u0026lt;iostream\u0026gt; 3using namespace std; 4 5// Function prototypes 6void fun(const int *arr, int size); 7 8// Test Driver 9int main() { 10 const int SIZE = 5; 11 int a[SIZE] = {8, 4, 5, 3, 2}; 12 cout \u0026lt;\u0026lt; \u0026#34;sizeof in main() is \u0026#34; \u0026lt;\u0026lt; sizeof(a) \u0026lt;\u0026lt; endl; 13 cout \u0026lt;\u0026lt; \u0026#34;address in main() is \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; 14 fun(a, SIZE); 15} 16 17// Function definitions 18void fun(const int *arr, int size) { 19 cout \u0026lt;\u0026lt; \u0026#34;sizeof in function is \u0026#34; \u0026lt;\u0026lt; sizeof(arr) \u0026lt;\u0026lt; endl; 20 cout \u0026lt;\u0026lt; \u0026#34;address in function is \u0026#34; \u0026lt;\u0026lt; arr \u0026lt;\u0026lt; endl; 21} 编译运行：\n1→ g++ test_sizeof_array.cpp \u0026amp;\u0026amp; ./a.out 2sizeof in main() is 20 3address in main() is 0x7ffeeab9d0d0 4sizeof in function is 8 5address in function is 0x7ffeeab9d0d0 看到这个结果是不是很不可思议，在main函数和fun中打印的地址相同，但是sizeof的结果却不一样，这是为什么呢？ 因为在main中sizeof是对数组操作的，而在fun中，sizeof操作的是指针，指针变量占的字节数是 4。\n4.6 数组的遍历操作 1/* Function to compute the sum of a range of an array (SumArrayRange.cpp) */ 2#include \u0026lt;iostream\u0026gt; 3using namespace std; 4 5// Function prototype 6int sum(const int *begin, const int *end); 7 8// Test Driver 9int main() { 10 int a[] = {8, 4, 5, 3, 2, 1, 4, 8}; 11 cout \u0026lt;\u0026lt; sum(a, a+8) \u0026lt;\u0026lt; endl; // a[0] to a[7] 12 cout \u0026lt;\u0026lt; sum(a+2, a+5) \u0026lt;\u0026lt; endl; // a[2] to a[4] 13 cout \u0026lt;\u0026lt; sum(\u0026amp;a[2], \u0026amp;a[5]) \u0026lt;\u0026lt; endl; // a[2] to a[4] 14} 15 16// Function definition 17// Return the sum of the given array of the range from 18// begin to end, exclude end. 19int sum(const int *begin, const int *end) { 20 int sum = 0; 21 for (const int *p = begin; p != end; ++p) { 22 sum += *p; 23 } 24 return sum; 25} 4.7 C-String 和 指针 C-String (在 C 语言中)是一个以字符'\\0'结尾的字符数组：\n1/* Testing C-string (TestCString.cpp) */ 2#include \u0026lt;iostream\u0026gt; 3#include \u0026lt;cstring\u0026gt; 4using namespace std; 5 6int main() { 7 char msg1[] = \u0026#34;Hello\u0026#34;; 8 char *msg2 = \u0026#34;Hello\u0026#34;; 9 // warning: deprecated conversion from string constant to \u0026#39;char*\u0026#39; 10 11 cout \u0026lt;\u0026lt; strlen(msg1) \u0026lt;\u0026lt; endl; // 5 12 cout \u0026lt;\u0026lt; strlen(msg2) \u0026lt;\u0026lt; endl; 13 cout \u0026lt;\u0026lt; strlen(\u0026#34;Hello\u0026#34;) \u0026lt;\u0026lt; endl; 14 15 int size = sizeof(msg1)/sizeof(char); 16 cout \u0026lt;\u0026lt; size \u0026lt;\u0026lt; endl; // 6 - including the terminating \u0026#39;\\0\u0026#39; 17 for (int i = 0; msg1[i] != \u0026#39;\\0\u0026#39;; ++i) { 18 cout \u0026lt;\u0026lt; msg1[i]; 19 } 20 cout \u0026lt;\u0026lt; endl; 21 22 for (char *p = msg1; *p != \u0026#39;\\0\u0026#39;; ++p) { 23 // *p != \u0026#39;\\0\u0026#39; is the same as *p != 0, is the same as *p 24 cout \u0026lt;\u0026lt; *p; 25 } 26 cout \u0026lt;\u0026lt; endl; 27} 需要注意的是，像strlen()这样的 C-String 函数，不需要传递数组长度。因为 C-String 以'\\0'结尾，这些函数可以 遍历字符数组直到遇到字符'\\0'.\n1/* Function to count the occurrence of a char in a string (CountChar.cpp) */ 2#include \u0026lt;iostream\u0026gt; 3#include \u0026lt;cstring\u0026gt; 4using namespace std; 5 6int count(const char *str, const char c); // No need to pass the array size 7 8int main() { 9 char msg1[] = \u0026#34;Hello, world\u0026#34;; 10 char *msg2 = \u0026#34;Hello, world\u0026#34;; 11 12 cout \u0026lt;\u0026lt; count(msg1, \u0026#39;l\u0026#39;) \u0026lt;\u0026lt; endl; 13 cout \u0026lt;\u0026lt; count(msg2, \u0026#39;l\u0026#39;) \u0026lt;\u0026lt; endl; 14 cout \u0026lt;\u0026lt; count(\u0026#34;Hello, world\u0026#34;, \u0026#39;l\u0026#39;) \u0026lt;\u0026lt; endl; 15} 16 17// Count the occurrence of c in str 18// No need to pass the size of char[] as C-string is terminated with \u0026#39;\\0\u0026#39; 19int count(const char *str, const char c) { 20 int count = 0; 21 while (*str) { // same as (*str != \u0026#39;\\0\u0026#39;) 22 if (*str == c) ++count; 23 ++str; 24 } 25 return count; 26} 5 指针的其他方面 5.1 函数指针 在 C/C++中，函数跟其他数据一样，都有自己的地址。函数名就是函数在记忆体中的起始地址，因此函数名可以被视为指针。 我们可以给函数传递一个函数指针，语法如下：\n1// Function-pointer declaration 2return-type (* function-ptr-name) (parameter-list) 3 4// Example 5double (*fp)(int, int) // fp points to a function that takes two ints and returns a double (function-pointer) 6double *dp; // dp points to a double (double-pointer) 7double *fun(int, int) // fun is a function that takes two ints and returns a double-pointer 8 9double f(int, int); // f is a function that takes two ints and returns a double 10fp = f; // Assign function f to fp function-pointer 1/* Test Function Pointers (TestFunctionPointer.cpp) */ 2#include \u0026lt;iostream\u0026gt; 3using namespace std; 4 5int arithmetic(int, int, int (*)(int, int)); 6 // Take 3 arguments, 2 int\u0026#39;s and a function pointer 7 // int (*)(int, int), which takes two int\u0026#39;s and return an int 8int add(int, int); 9int sub(int, int); 10 11int add(int n1, int n2) { return n1 + n2; } 12int sub(int n1, int n2) { return n1 - n2; } 13 14int arithmetic(int n1, int n2, int (*operation) (int, int)) { 15 return (*operation)(n1, n2); 16} 17 18int main() { 19 int number1 = 5, number2 = 6; 20 21 // add 22 cout \u0026lt;\u0026lt; arithmetic(number1, number2, add) \u0026lt;\u0026lt; endl; 23 // subtract 24 cout \u0026lt;\u0026lt; arithmetic(number1, number2, sub) \u0026lt;\u0026lt; endl; 25} 5.2 通用指针或者 void 指针(void \\*) void指针可以用来存放任何数据类型的地址（除了函数指针）。我们不能对void指针执行操作，因为它的类型是未知的。 但是我们可以使用void指针来跟其他地址做比较。\n5.3 常数的指针 vs. 指针是常数 非常数指针指向常数：指针指向的数据不能修改，但是指针本身可以修改为指向其他数据，例如：\n1int i1 = 8, i2 = 9; 2const int *iptr = \u0026amp;i1; // non-constant pointer pointing to constant data 3// *iptr = 9; // error: assignment of read-only location 4iptr = \u0026amp;i2; // ok 常数指针指向非常量数据：指向的数据可以被修改，但是指针本身不能修改：\n1int i1 = 8, i2 = 9; 2int * const iptr = \u0026amp;i1; 3*iptr = 9; // ok 4// iptr = \u0026amp;i2; // error: assignment of read-only variable 常数指针指向常量：指向的数据和指针本身都不能修改：\n1int i1 = 8, i2 = 9; 2const int * const iptr = \u0026amp;i1; // constant pointer pointing to constant data 3// *iptr = 9; // error: assignment of read-only variable 4// iptr = \u0026amp;i2; // error: assignment of read-only variable 非常数指针指向非常数：指向的数据和指针都能被修改\n1int i1 = 8, i2 = 9; 2int * iptr = \u0026amp;i1; // non-constant pointer pointing to non-constant data 3*iptr = 9; // okay 4iptr = \u0026amp;i2; // okay ","date":"February 23, 2018","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/cpp/2018-02-23-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D/","series":[],"smallImg":"","tags":[{"title":"C++","url":"/blog/tags/c++/"}],"timestamp":1519344000,"title":"c++编程之指针，引用和内存动态分配"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"Programming","url":"/blog/categories/programming/"}],"content":" 1. 为什么要使用 OOP？ 假如你想组装一台电脑，你会去硬件商店购买主板、处理器、内存条、硬盘、机箱、电源，然后将它们组装在一起，然后打开电源，电脑就能运行。 你不用考虑主板是 4 重板还是 6 重板，硬盘是什么尺寸，内存是哪里生产的诸如此类的问题。你只需要将这些硬件单元组合在一起，就能期待电脑能够运行。 当然，你需要保证你有正确的接口，比如，如果你的主板只支持 IDE 接口，而你需要购买一个 IDE 的硬盘而不是 SCSI 硬盘，又例如你需要选择一个合适速率的 内存。即便如此，将硬件组件组装成一台机器也没有任何难度。\n同样的，一辆车也是由多个部分组装起来的，例如底盘、车门、引擎、车轮、刹车和传动装置。这些组件都是可复用的。比如车轮，就能够被用于很多辆同型号的骑车上。\n像电脑和汽车这样的硬件能够用可复用的部分组装起来。那么软件是否也是如此呢？我们是否能够将不同地方的程序片段“组装”起来，然后期待程序能正常运行呢？ 答案显然是 no！跟硬件不同的是，很难从软件片段中“组装”一个应用。自从计算机 60 年前问世以来，人们写了大量的程式码。然而，对于每一个新的应用程序，我们都需要 重新造轮子。\n为什么要重新造轮子呢？\n1.1 传统的面向过程的编程语言 传统的面向过程的编程语言（例如 C 和 Pascal）在创建可重用组件方面遇到了一些显著的缺陷：\n程序是由函数组织起来的。函数通常是不可重用的，我们很难将一个函数直接拷贝到别的地方去使用，因为函数很有可能引用了头文件，或者全局变量，或者调用了其他函数。 换句话说，函数不能很好的封装成一个独立的可重用单元。\n面向过程的语言不适合高层抽象来解决现实生活中的问题。例如 c 程序使用\u0026quot;if-else\u0026quot;, \u0026ldquo;for-loop\u0026rdquo;, \u0026ldquo;array\u0026rdquo;, \u0026ldquo;function\u0026rdquo;, \u0026ldquo;pointer\u0026quot;等结构，这些结构很低阶而且很难抽象形如 Customer Relationship Management (CRM) 系统或者电脑足球游戏。\n简而言之，传统的面向过程的编程语言将数据结构和算法单元分开了。\n1.2 面向对象的编程语言 面向对象的编程语言就是被设计来克服这些问题的。\nOOP 的基础单元是类。类将静态属性和动态行为封装在一起，同时指定一些公开的接口来供人使用。由于相比于函数，类有很好的封装性，所以很容易重用。换句话说，类将数据和算法结合在了一起。\n面向对象的编程语言为解决现实问题的高阶抽象提供了保证。面向过程的编程语言迫使人们把注意力放在计算机结构（如：内存，位，字节，数组）上，而不是放在要解决的问题本身。面向对象的编程语言 能够让我们更专注于问题本身，使用程序对象来表示和抽象问题中的各种实体。\n举个例子，假设你要写一个足球游戏，很难用面向过程的语言建立模型。但是使用 OOP，可以很容易将现实事物同程序之间建立模型：\nPlayer：属性包含 name, number, location 等待，操作有 run, jump, kick-the-ball\u0026hellip; Ball: Reference: Field: Audience: Weather: 最重要的是，这其中的一些类（例如：Ball 和 Audience）可以在其他程序中复用。\n1.3 OOP 带来的优点 面向过程的编程语言注重于过程，函数是它的基础单元。你需要在一开始就规划好所有的函数，然后考虑如何去表示数据。\n面向对象的编程语言注重于用户所认知的组件，类是它的基础单元。你只需要将所有数据和数据交互的操作放进对应的类中即可。\n面向对象编程技术有很多优点：\n易于设计和开发 易于维护 可复用 2. OOP 基础 2.1 类和实例 类：类是对同种事物的抽象。换句话说，类是蓝图，是模板，或者是一种协议，类用来定义和描述同种对象共有的静态属性和动态行为。\n实例：实例是一个类的特定实现。换句话说，实例是类的实例化。类的所有实例都具有类似的属性，如类定义中所描述的那样。\n2.2 类是一个封装数据和操作的三室盒 一个类可以被形象的比喻成一个三室盒：\nClassname(identifier)：标识类 Data Members or Variables(or attributes, states, fields)：包含了类的静态属性 Member Functions(or methods, behaviors, operations)：包含了类的动态操作 2.3 定义类 在 C++种，使用关键字class来定义一个类。在申明类的时候可以有两张选项：public和private，稍后会具体说明。\n1class Circle { 2private: 3\tdouble radius; 4\tstring color; 5 6public: 7\tdouble getRadius(); 8\tdouble getArea(); 9} 1class SoccerPlayer { 2private: 3\tint number; 4\tstring name; 5\tint x, y; 6 7public: 8\tvoid run(); 9\tvoid kickBall(); 10} 类命名约定：一个类名必须是一个名词或者一个名词短语，所有单词首字母大写（驼峰），使用名词单数形式，类名必须要有 意义，能够清楚描述自己。\n2.4 创建类实例 创建一个类实例，你需要：\n申明一个特定实例的标识符。 调用类的构造函数来构造类的实例 假如我们有一个名为Circle的类，我们可以通过如下方式来创建实例：\n1Circle c1(1.2, \u0026#34;red\u0026#34;); 2Circle c2(3.4); 3Circle c3(); 另外，你也可以显示调用构造函数：\n1Circle c1 = Circle(1.2, \u0026#34;red\u0026#34;); 2Circle c2 = Circle(3.4); 3Circle c3 = Circle; 2.5 点(.)操作符 引用一个对象的成员，你需要：\n首先确定是哪个实例，然后 使用点操作符来引用成员 同样的，假如我们有一个名为Circle的类，其中有两个数据成员和两个函数，我们已经创建了三个实例，分别为c1, c2, c3。\n1//创建实例 2Circle c1(1.2, \u0026#34;blue\u0026#34;); 3Circle c2(3.4, \u0026#34;green\u0026#34;); 4 5//调用成员方法 6cout \u0026lt;\u0026lt; c1.getArea() \u0026lt;\u0026lt; endl; 7cout \u0026lt;\u0026lt; c2.getArea() \u0026lt;\u0026lt; endl; 8 9//引用数据成员 10c1.radius = 5.5; 11c2.radius = 6.6; 2.6 数据成员（变量） 成员变量有一个变量名和变量类型，用以存放一个特定类型的值。成员变量也可以是一个特定类的实例。\n2.7 成员方法 一个成员方法：\n从调用者接收参数 执行定义好的操作 返回结果给调用者 2.8 将它们合在一起：一个 OOP 的例子 在这个例子中，我们会将所有代码放在一个源文件中CircleAIO.cpp\n1/* 2 * The Circle class (All source code in one file) (CircleAIO.cpp) 3 */ 4 5 6#include \u0026lt;iostream\u0026gt; // using IO functions 7#include \u0026lt;cstring\u0026gt; // using string 8 9using namespace std; 10 11class Circle { 12private: 13\tdouble radius;\t// Data member (Variable) 14\tstring color;\t// Data member (Variable) 15 16public: 17\t// Constructor with default values for data members. 18\tCircle(double r = 1.0, string c = \u0026#34;red\u0026#34;) { 19\tradius = r; 20\tcolor = c; 21\t} 22 23\t// Member function (Getter) 24\tdouble getRadius() { 25\treturn radius; 26\t} 27 28\t// Member function (Getter) 29\tstring getColor() { 30\treturn color; 31\t} 32 33\t// Member function 34\tdouble getArea() { 35\treturn radius * radius * 3.14; 36\t} 37}; // need to end the class declaration with a semi-colon 38 39// Test driver function 40int main(int argc, char *argv[]) 41{ 42\tCircle c1(1.2, \u0026#34;blue\u0026#34;); 43\tcout \u0026lt;\u0026lt; \u0026#34;Radius=\u0026#34; \u0026lt;\u0026lt; c1.getRadius() \u0026lt;\u0026lt; \u0026#34; Area=\u0026#34; \u0026lt;\u0026lt; c1.getArea() 44\t\u0026lt;\u0026lt; \u0026#34; Color=\u0026#34; \u0026lt;\u0026lt; c1.getColor() \u0026lt;\u0026lt; endl; 45 46\tCircle c2(3.4); 47\tcout \u0026lt;\u0026lt; \u0026#34;Radius=\u0026#34; \u0026lt;\u0026lt; c2.getRadius() \u0026lt;\u0026lt; \u0026#34; Area=\u0026#34; \u0026lt;\u0026lt; c2.getArea() 48\t\u0026lt;\u0026lt; \u0026#34; Color=\u0026#34; \u0026lt;\u0026lt; c2.getColor() \u0026lt;\u0026lt; endl; 49 50\tCircle c3; 51\tcout \u0026lt;\u0026lt; \u0026#34;Radius=\u0026#34; \u0026lt;\u0026lt; c3.getRadius() \u0026lt;\u0026lt; \u0026#34; Area=\u0026#34; \u0026lt;\u0026lt; c3.getArea() 52\t\u0026lt;\u0026lt; \u0026#34; Color=\u0026#34; \u0026lt;\u0026lt; c3.getColor() \u0026lt;\u0026lt; endl; 53\treturn 0; 54} 2.9 构造器 构造器是一个跟类名同名的特定方法。在上述的Circle类中，我们是这样定义构造器的：\n1// Constructor has the same name as the class 2Circle(double r = 1.0, string c = \u0026#34;red\u0026#34;) { 3\tradius = r; 4\tcolor = c; 5} 构造器是用来构造和初始化数据成员的。创建一个类的新实例，你需要申明一个实例的标识符然后调用构造器：\n1Circle c1(1.2, \u0026#34;blue\u0026#34;); 2Circle c2(3.4); 3Circle c3; 构造器和普通方法的区别在于下面几个方面：\n构造器函数跟类同名 构造器没有返回值（或者说是返回void类型）。也就是说，构造器中允许缺省return语句。 构造器只能在初始化实例的时候被调用一次 构造器不能被继承 2.10 函数的默认值 在 C++中，你可以给函数参数指定默认值：\n1/* Test function default arguments (TestFnDefault.cpp) */ 2#include \u0026lt;iostream\u0026gt; 3 4using namespace std; 5 6// Function prototype 7int sum(int n1, int n2, int n3 = 0, int n4 = 0, int n5 = 0); 8 9int main() { 10\tcout \u0026lt;\u0026lt; sum(1, 1, 1, 1, 1) \u0026lt;\u0026lt; endl;\t// 5 11\tcout \u0026lt;\u0026lt; sum(1, 1, 1, 1) \u0026lt;\u0026lt; endl;\t// 4 12\tcout \u0026lt;\u0026lt; sum(1, 1, 1) \u0026lt;\u0026lt; endl;\t// 3 13\tcout \u0026lt;\u0026lt; sum(1, 1) \u0026lt;\u0026lt; endl;\t// 2 14\tcout \u0026lt;\u0026lt; sum(1) \u0026lt;\u0026lt; endl;\t// error: too few arguments 15} 16 17// Function definition 18// The default values shell be specified in function prototype, 19// not the function implementation. 20int sum(int n1, int n2, int n3, int n4, int n5) { 21\treturn n1 + n2 + n3 + n4 + n5; 22} 2.11 “public” vs . “private” 访问控制符 访问控制符用来控制成员变量和成员方法的可见性。\npublic：成员可见 private：成员只能在类中可见 2.12 封装 2.13 Getters 和 Setters 为了让外部访问到private修饰的成员变量，你需要提供 get 函数，通常命名为getXxx()。getter 不必讲数据原样暴露出来， 它可以对数据视图做一些限制。Getters 不能修改成员属性。\n为了让外部能够修改被private修饰的成员变量，你需要提供 set 函数，通常命名为setXxx()，setter 函数需要保证数据的合法性， 然后将其转换成类内部展示的形式。\n2.14 “this\"关键字 我们可以使用\u0026quot;this\u0026quot;关键字在当前类内部引用当前实例。\n\u0026ldquo;this\u0026quot;的一个主要作用就是解决函数参数名和成员变量名冲突的问题.\n1class Circle { 2private: 3\tdouble radius; 4 5public: 6\tvoid setRadius(double radius) { 7\tthis-\u0026gt;radius = radius; 8\t} 9} 2.15 “const\"成员函数 被const关键字修饰的成员函数不能修改任何成员属性，例如：\n1double getRadius() const { 2\tradius = 0; 3\t// error: assignment of data-member \u0026#39;Circle::radius\u0026#39; in read-only structure 4\treturn radius; 5} 2.16 Getters/Setters 和 Constructors 的命名规则 假设在类Aaa中有一个T类型的私有属性xxx，那么该类的 getter，setter 和 constructor 遵循以下规则：\n1class Aaa { 2private: 3\t// A private variable named xxx of type T 4\tT xxx; 5 6public: 7\t// Constructor 8\tAaa(T x) { xxx = x; } 9\t// OR 10\tAaa(T xxx) { this-\u0026gt;xxx = xxx; } 11\t// OR using member initializer list 12\tAaa(T xxx) : xxx(xxx) { } 13 14\t// A getter for variable xxx of type T receives no argument and return a value of type T 15\tT getXxx() const { return xxx; } 16 17\t// A setter for variable xxx of type T receives a parameter of type T and return void 18\tvoid setXxx(T x) { xxx = x; } 19\t// OR 20\tvoid setXxxx(T xxx) { this-\u0026gt;xxx = xxx; } 21} 对于bool类型的变量xxx，其 getter 函数应该命名为isXxx()，而不是getXxx()：\n1private: 2\tbool xxx; 3public: 4\t// Getter 5\tbool isXxx() const { return xxx; } 6\t// Setter 7\tvoid setXxx(bool x) { xxx = x; } 8\t// OR 9\tvoid setXxx(bool xxx) { this-\u0026gt;xxx = xxx; } 2.17 默认构造器 默认构造器就是没有任何参数的构造器，或者是所有参数都有默认值的构造器。\n1Circle c1; // Declare c1 as an instance of Circle, and invoke the default constructor 2Circle c1(); // Error! 3\t// (This declares c1 as a function that takes no parameters and return a Circle) 说明： 注意上述代码中的区别，Circle c1;申明了一个Circle类的实例，并且调用了默认构造器，而Circle c1();则是申明了一个名为c1的函数，该 函数不需要参数，而且返回值为Circle类型的对象。\n在 C++中，如果你没有提供任何构造器，那么编译器会自动提供一个没有任何操作的默认构造器：\n1ClassName::ClassName() { } // Take no argument and do nothing. 而一旦你提供了构造器，编译器就不会再提供默认构造器了。也就是说，如果你提供的所有构造器都是有参数的，那么再去调用无参构造器就会报错。\n2.18 构造器的成员初始化列表 除了像下面这样在构造器函数体中初始化私有属性：\n1Circle(double r = 1.0, string c = \u0026#34;red\u0026#34;) { 2\tradius = r; 3\tcolor = c; 4} 还有一种可选的语法叫做成员初始化列表：\n1Circle(double r = 1.0, string c = \u0026#34;red\u0026#34;) : radius(r), color(c) { } 2.19 析构函数 析构函数跟构造函数类似，都跟类同名，不同的是析构函数名前需要加上~前缀，例如：~Circle()。析构函数在对象销毁的时候被调用。 如果你没有提供析构函数，编译器会提供一个不做任何操作的默认析构函数。\n1class MyClass { 2public: 3\t// The default destructor that dose nothing. 4\t~MyClass() { } 5} 注意： 如果你的类成员包含了动态分配的（通过new或者new[]）的数据，那么你需要通过delete或者delete[]来释放内存。\n2.20 拷贝构造函数 拷贝构造函数通过拷贝一个已经存在的同类型对象来创建一个新的对象。也就是说，需要向拷贝构造函数传递一个同类型的对象作为参数。\n1Circle c4(7.8, \u0026#34;blue\u0026#34;); 2cout \u0026lt;\u0026lt; \u0026#34;Radius=\u0026#34; \u0026lt;\u0026lt; c4.getRadius() \u0026lt;\u0026lt; \u0026#34; Area=\u0026#34; \u0026lt;\u0026lt; c4.getArea() 3\t\u0026lt;\u0026lt; \u0026#34; Color=\u0026#34; \u0026lt;\u0026lt; c4.getColor() \u0026lt;\u0026lt; endl; 4 5// Costruct a new object by copying an existing object 6// via the so-called default copy constructor 7Circle c5(c4); 8cout \u0026lt;\u0026lt; \u0026#34;Radius=\u0026#34; \u0026lt;\u0026lt; c5.getRadius() \u0026lt;\u0026lt; \u0026#34; Area=\u0026#34; \u0026lt;\u0026lt; c5.getArea() 9\t\u0026lt;\u0026lt; \u0026#34; Color=\u0026#34; \u0026lt;\u0026lt; c5.getColor() \u0026lt;\u0026lt; endl; 当我们想将一个对象按值传递给一个函数作为参数的时候，就需要使用拷贝构造函数。\n2.21 拷贝赋值操作符 编译器还提供了一种默认的赋值操作符(=)，可以通过成员拷贝的方式将一个对象赋值给另一个同类的对象。\n1Circle c6(5.6, \u0026#34;orange\u0026#34;), c7; 2 3c7 = c6; // memberwise copy assignment 说明\n可以通过重载赋值操作符来覆盖默认操作 在声明对象的时候用使用的拷贝构造函数而不是拷贝赋值操作： 1Circle c8 = c6; // Invoke the copy constructor, NOT copy assignment operator 2\t// Same as Circle c8(c6); 默认的拷贝赋值表现为shadow copy，它并不能拷贝通过new或者new[]动态声明的成员。 拷贝赋值操作符的结构如下： 1class MyClass { 2private: 3\tT1 member1; 4\tT2 member2; 5public: 6\t// The default copy assignment operator which assigns an object via memberwise copy 7\tMyClass \u0026amp; operator=(const MyClass \u0026amp; rhs) { 8\tmember1 = rhs.member1; 9\tmember2 = rhs.member2; 10\treturn *this; 11\t} 12} 拷贝赋值不同于拷贝构造的地方在于拷贝赋值必须释放动态申请的空间，而且需要防止自赋值。拷贝赋值返回自引用，以实现 链式赋值操作：x = y = z 默认构造器，默认析构函数，默认拷贝构造函数，默认拷贝赋值操作符都是常见的特殊成员函数，如果没有被定义的话，编译器会自动生生成 3. 将声明和实现分离 为了更好的组织软件工程，强烈建议将类的声明和实现分别放在 2 个文件中：声明放在头文件(.h)里，实现放在\u0026rdquo;.cpp\u0026quot;文件中。 这样做就是公开接口，隐藏实现，而且一旦接口定义好，可以有多种不同的实现。\n4. 一个示例 Circle.h - Header\n1/* The Circle class Header (Circle.h) */ 2#include \u0026lt;string\u0026gt; 3using namespace std; 4 5// Circle class declaration 6class Circle { 7private: 8\tdouble radius; 9\tstring color; 10public: 11\tCircle(double raidus = 1.0, string color = \u0026#34;red\u0026#34;); 12 13\tdouble getRadius() const; 14\tvoid setRadius(double radius); 15\tstring getColor() const; 16\tvoid setColor(string color); 17 18\tdouble getArea() const; 19}; Circle.cpp - Implementation\n1#include \u0026#34;Circle.h\u0026#34; 2 3Circle::Circle(double r, string c) { 4\tradius = r; 5\tcolor = c; 6} 7 8double Circle::getRadius() const { 9\treturn radius; 10} 11 12void Circle::setRadius(double r) { 13\tradius = r; 14} 15 16string Circle::getColor() const { 17\treturn color; 18} 19 20void Circle::setColor(string c) { 21\tcolor = c; 22} 23 24double Circle::getArea() const { 25\treturn radius * radius * 3.14; 26} 编译Circle类只需要将Circle.cpp编译成Circle.o文件\n1g++ -c Circle.cpp TestCircle.cpp - Test Driver\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026#34;Circle.h\u0026#34; 3 4using namespace std; 5 6int main() { 7\tCircle c1(1.2, \u0026#34;red\u0026#34;); 8 9\tc1.setRadius(2.1); 10\tc1.setColor(\u0026#34;blue\u0026#34;); 11 12\treturn 0; 13} 编译测试文件\n1g++ -o TestCircle TestCircle.cpp Circle.o 你也可以\n1g++ -o TestCircle TestCircle.cpp Circle.cpp 剩下的例子省略。。。\n","date":"February 13, 2018","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/cpp/2018-02-13-c++%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","series":[],"smallImg":"","tags":[{"title":"C++","url":"/blog/tags/c++/"}],"timestamp":1518480000,"title":"c++编程之面向对象"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"Programming","url":"/blog/categories/programming/"}],"content":"原文地址http://nikic.github.io/2017/04/14/PHP-7-Virtual-machine.html\n写这篇文章的目的是基于 php7，阐述 Zend Virtual Machine 的内部实现。这不是一篇综合描述，我将尽可能地覆盖到所有重要的部分和细节。\n本文的描述对象是 php7.2 版本，但是几乎所有的特性都已经应用在了 php7.0/7.1 中了。然而，它们同 php5.x 系列 VM 的不同之处同样也很重要，我会很有耐心的同步描述。\n这篇文章主要是从指令的角度来阐述，只有在末尾花了少量篇幅描述了 C 语言实现 VM 的细节。但是在文章开始之前，我想先提供一些实现 VM 的主要代码文件：\nzend_vm_def.h: VM 定义文件 zend_vm_execute.h: 生成的 VM zend_vm_gen.php: VM 生成脚本 zend_execute.c: 大多数直接支持的代码 Opcodes 首先我们来聊聊 opcode。\u0026ldquo;Opcode\u0026quot;是用来表示整个 VM 指令集（包括操作数）的，但是也可能仅仅就是指“真实的”操作码，这些操作码是一个很小的整数用来区分不同的指令类型。其具体的含义需要结合代码的上下文才能清楚。在程式码中，指令通常被称作\u0026quot;oplines\u0026rdquo;。\n下面是zend_op的结构\n1struct _zend_op { 2 const void *handler; 3 znode_op op1; 4 znode_op op2; 5 znode_op result; 6 uint32_t extended_value; 7 uint32_t lineno; 8 zend_uchar opcode; 9 zend_uchar op1_type; 10 zend_uchar op2_type; 11 zend_uchar result_type; 12}; 由此看来，opcodes 本质上就是一个“三地址码”格式的指令。有一个opcode代表指令的类型，有两个输入操作数op1和op2和一个输出操作数result。\n并不是所有的指令都一定会使用全部的操作数。ADD指令（表示+操作符）会使用全部的操作数，BOOL_NOT指令（表示!操作符）只会用到op1和result。而ECHO 指令只会用到op1。还有一些指令既可能用到也可能用不到操作数，例如DO_FCALL有没有结果操作数都是有可能的，这取决于调用的函数是否有返回值。还有一些指令 可能会需要使用超过２个输入操作数，在这种情况下，它们将使用一个虚设的指令(OP_DATA)来传递额外的操作数。\n紧跟着三个标准操作数后面的是一个额外的数值字段extended_value，它可以用来存放一些额外的指令标识，例如CAST指令，它需要保存将要转换的目标类型。\n每一个操作数都有一个类型，分别存放在op1_type，op2_type，result_type当中。所有可能的类型有IS_UNUSED，IS_CONST，IS_TMPVAR，IS_VAR，IS_CV。 后三种类型用来指明变量操作数类型（有三种不同类型的 VM 变量），IS_COUNT表示一个常量操作数，而IS_UNUSED表示一个操作数是否被使用，或者操作数被用作一个 32 位数字类型（一个立即数，汇编中的术语）。例如 Jump 指令会将跳转的目标存放在一个UNUSED操作数中。\n输出 Opcode 接下来，我将会频繁展示一些 php 示例代码生成的 opcode 序列。目前有三种方式来打印出 opcode.\n1# Opcache, since PHP 7.1 2php -d opcache.opt_debug_level=0x10000 test.php 3 4# phpdbg, since PHP 5.6 5phpdbg -p* test.php 6 7# vld, third-party extension 8php -d vld.active=1 test.php 上述方法中，opcache 输出的 opcode 质量更高。本文使用的 opcode 就是基于 opcache 输出的，其中一些 opcode 做了少量的语法的调整。魔法数字0x10000表示“优化前”，使用这个级别输出的是 php 编译器直接生成的 opcodes，而0x20000会输出优化过的 opcodes。Opcache 还能生成更多的信息，例如使用0x40000将会生成CFG(Control flow graph)，使用0x200000将会生成类型和范围推断的 SSA form(Static single assignment form，静态单赋值形式，常见于编译器原理)，但是这些已经超出了本文的探讨范围，所以最原始的 opcodes 才最符合我们的需求。\n变量类型 可能在处理 PHP 虚拟机时要理解的最重要的一点就是 VM 使用了三种不同的变量类型。在 PHP5 中，TMPVAR，VAR和CV在虚拟机栈中不仅含义上有着明显的区别，连访问方式都不一样。但是到了 PHP7，公用一套存储机制使得它们变得非常相似。而然，它们所包含的数值和它们的语义上却存在重要的差异。\nCV是compiled variable的简写，代表的是真正的 PHP 变量。如果一个函数使用变量$a，就会使用CV类型的操作数表示$a。CVs 也可以有UNDEF类型，用以表示没有定义的变量。如果一个指令使用了 UNDEF CV，（在大多数情况下）会抛出一个熟悉的“undefined variable”警告。在 function entry 中，所有非参数 CVs 都会被初始化为 UNDEF。\nCVs 不是被指令消费的，例如一个指令ADD $a, $b不会销毁存放在 CVs$a，$b中的数据，取而代之的是 CVs 在作用域结束的时候一起被销毁。也就是说，所有 CVs“存活”于 整个函数期间，这里的“存活”指的是其包含一个合法的数值（并非存活于数据流层面）。\nTMPVARs和VARs从某种意义上说其实就是虚拟机的临时变量。他们通常产生于作为一些操作的结果操作数。例如$a = $b + $c + $d将会生成一个如下所示的 opcode 的序列\n1T0 = ADD $b, $c 2T1 = ADD t0, $d 3ASSIGN $a, T1 TMP/VARs总是在使用前被定义，所以不能持有UNDEF类型。不同于CVs，它们的值是被指令直接消费的。在上面的例子中，第二个 ADD 会销毁 T0 操作数中的值，至此以后 T0 将不能再被使用。同样的，ASSIGN 将会消费 T1 中的数值，然后并释放掉。\n上述表明TMP/VARs通常都很短命。在多数情况下，临时变量仅仅存活于单个指令空间。在这个短暂的存活间隔之外，临时变量的值就是垃圾数据。 那么 TMP 和 VAR 的区别到底是什么呢？其实区别并不多，其差异继承自 PHP5，在 PHP5 中，TMPs 是存放在虚拟机栈中的，VMRs 是存放在堆中的。而 PHP7 中的所有变量都是存放在栈 当中的。因此，至今 TMPs 和 VARs 的主要区别是只有后者允许包含REFERENCEs。此外，VARSs 也能够存放两种特殊类型的数据，一个是 namely class entries，另一个是 INDIRECT values。后者也通常被用来处理非普通的赋值操作。\n下表总结了三种数据类型的主要区别:\n1 | UNDEF | REF | INDIRECT | Consumed? | Named? | 2-------|-------|-----|----------|-----------|--------| 3CV | yes | yes | no | no | yes | 4TMPVAR | no | no | no | yes | no | 5VAR | no | yes | yes | yes | no | Op arrays 所有的 PHP 函数都代表了一个拥有相同zend_functionheader 的结构体。\u0026ldquo;Function\u0026quot;在这里被理解的很宽泛，包括了真实函数的所有一切，从方法到独立的伪代码，到 evel 代码。 用户层的函数使用zend_op_array结构体。它有超过 30 个成员，所以这里从一个简化版开始研究：\n1struct _zend_op_array { 2 /* Common zend_function header here */ 3 4 /* ... */ 5 uint32_t last; 6 zend_op *opcodes; 7 int last_var; 8 uint32_t T; 9 zend_string **vars; 10 /* ... */ 11 int last_literal; 12 zval *literals; 13 /* ... */ 14}; 这里边最重要的部分当然是opcodes了，它是一个 opcodes（指令）的数组。last表示 opcode 数组中元素的个数。说到这里你也许会感到非常的疑惑，last看起来像是 最后一个 opcode 的索引，然而它真的是 opcodes 的个数（比最后一个 opcode 的索引值大１）。同样的规则适用于其他以last_开头的字段。\nlast_var是 CVs 的数量，T表示 TMPs 和 VARs 的数量（在大多数情况下，我们并没有对它们做明显的区分）。vars是一个 CVs 的名字数组。literals是用于存放代码中字面量的值的数组，这个数组会被CONST操作数引用。根据 ABI(application binary interface)，每一个CONST操作数要么存储一个字面量表的指针，要么存储一个相对于字面量表的起始位置的偏移量。\n关于 op array 结构还有很多内容，将会在后边描述。\n栈帧布局 不考虑一些 executor globals(EG)，所有的执行状态都是存储在虚拟机栈中的。VM 栈每页 256KB，页与页通过链表连接起来。在每个函数调用中，会在 VM 栈中分配一个新的栈帧，它们的布局如下：\n1+----------------------------------------+ 2| zend_execute_data | 3+----------------------------------------+ 4| VAR[0] = ARG[1] | arguments 5| ... | 6| VAR[num_args-1] = ARG[N] | 7| VAR[num_args] = CV[num_args] | remaining CVs 8| ... | 9| VAR[last_var-1] = CV[last_var-1] | 10| VAR[last_var] = TMP[0] | TMP/VARs 11| ... | 12| VAR[last_var+T-1] = TMP[T] | 13| ARG[N+1] (extra_args) | extra arguments 14| ... | 15+----------------------------------------+ 栈帧以一个zend_execute_data结构开始，后边跟着一个存放变量的数组。数组中的每个位置存放的数据都是一样的（简单的 zval 数值），但是它们却有着不同的用途。第一个last_var之前存放的都是 CVs，第一个num_args之前存放的是函数参数。紧挨着 CV 后边的是T槽，用以存放 TMP/VARs。最后，如果有一些“额外的”参数的话会存放在栈帧的末尾，它们通常用来处理func_get_args()。\nCV 和 TMP/VAR 操作数在指令中会被编码成相对于栈帧起始位置的偏移量，因此访问一个确定的变量将变得非常容易，仅仅访问execute_data中的偏移位置。下面是zend_execute_data的结构：\n1struct _zend_execute_data { 2 const zend_op *opline; 3 zend_execute_data *call; 4 zval *return_value; 5 zend_function *func; 6 zval This; /* this + call_info + num_args */ 7 zend_class_entry *called_scope; 8 zend_execute_data *prev_execute_data; 9 zend_array *symbol_table; 10 void **run_time_cache; /* cache op_array-\u0026gt;run_time_cache */ 11 zval *literals; /* cache op_array-\u0026gt;literals */ 12}; 其中最重要的是，这个结构体中包含了一个opline字段，它代表当前执行的指令，func是当前执行的函数。此外：\nreturn_value是一个指向存放返回值变量的指针 This就是$this对象，但是同时也编码了函数参数个数和一些调用的元数据标记存放在此 zval 中没有使用的空间里 called_scope是static::指向的 PHP 代码作用域 prev_execute_data指向前一个栈帧，以便当前函数执行完毕后返回到外层调用 symbol_table是一个典型的没有使用的符号表，用于某些疯狂的人实际使用中会用到变量或相关特性 run_time_cache缓存 op array 运行时缓存，用来防止指针通过间接寻址的方式来访问当前结构 literals缓存 op array 字面量表，目的同上 函数调用(Function call) 在介绍 execute_data 结构的时候，我跳过了call字段，因为在介绍它之前还需要先了解函数调用是如何工作的。\n所有调用都使用同一指令序列上的变量。一个var_dump($1, $b)在全局作用域中会被编译成下面的指令序列：\n1INIT_FCALL (2 args) \u0026#34;var_dump\u0026#34; 2SEND_VAR $a 3SEND_VAR $b 4V0 = DO_ICALL # or just DO_ICALL if retval unused 根据不同的调用类型，总共有８种不同类型的 INIT 指令。INIT_FCALL用于调用后立即释放的函数调用。同理根据不同的参数类型和函数类型，共有 10 种不同的 SEND 指令。DO_CALL 指令只有区区 4 种，ICALL 用于调用内部函数。\n尽管特定的指令不同，但是整个流程却一直如此：INIT,SEND,DO。现在调用序列需要解决的主要问题是嵌套调用，它们编译后的指令形如以下：\n1# var_dump(foo($a), bar($b)) 2INIT_FCALL (2 args) \u0026#34;var_dump\u0026#34; 3 INIT_FCALL (1 arg) \u0026#34;foo\u0026#34; 4 SEND_VAR $a 5 V0 = DO_UCALL 6SEND_VAR V0 7 INIT_FCALL (1 arg) \u0026#34;bar\u0026#34; 8 SEND_VAR $b 9 V1 = DO_UCALL 10SEND_VAR V1 11V2 = DO_ICALL 我使用缩进来区分哪个指令代表哪个调用。\nINIT opcode 将一个调用栈帧 push 到栈中，栈帧中包含了充足的空间来存放函数中的所有变量和已知数量的参数(如果涉及到参数解包，我们可能会得到更多参数)。这个调用栈帧伴随着函数调用被初始化，$this和called_scope（在上面情况下都是 NULL，因为它们是调用后就释放的函数）。\n一个新的栈帧的指针被存放在execute_data-\u0026gt;call中，其中execute_data是调用函数的栈帧。下面我们将分析一个形如EX(call)的访问形式。特别地，新栈帧的prev_execute_data会被设置成旧的EX(call)。例如，对于foo的INIT_FCALL会把其prev_execute_data设置成var_dump的栈帧，如此以来，prev_execute_data 在这种形式下构成了一个未完成调用的链表，从而形成了一个回溯链。\nSEND opcode 接下来将参数 push 到EX(call)的变量槽中。在这种情况下，参数都是连续的，而且也可能超出参数预设的存放区域到达 CVs 或 TMPs 区域，但是它们会在后边被修复。\n接着 DO_FCALL 才是进行真正的调用。此时EX(call)变成当前执行的函数而prev_execute_data则重新指向外层调用函数。除此之外，调用过程也取决于被调用函数的类型。内部函数只需要执行一个 handler 函数，而用户层函数需要先初始化栈帧。初始化过程包含了对参数栈的修复。PHP 允许向一个函数传递的参数超过预期参数个数。然而，只有被声明过的参数才会对应到 CVs，超出的参数将会被写到记忆体中其他 CVs 和 TMPs 的位置，但是像这样的参数随后会被移动到 TMPs 后面的位置，最终的结果就是函数参数位于两个不连续的记忆体区块中。\n这里需要清楚的是，用户端的函数调用不涉及到虚拟机级别的递归。它们只是从一个 execute_data 切换到另一个，但虚拟机在线性循环中继续运行。虚拟机级别的递归仅仅出现在内部函数中包含用户端回调的时候（例如：通过array_map）。这就是为什么在 PHP 中无限递归通常会导致内存限制或 OOM 错误，但是通过回调函数或魔术方法可能会引发栈溢出。\n传送参数(Argument sending) PHP 使用大量不同的参数传递 opcode，多亏了那些不幸的名字，让我们对它们的区别感到困惑。\nSEND_VAL 和 SEND_VAR 是最简单的两个，它们用来传递按值传递的参数。SEND_VAL 用于 CONST 和 TMP 操作数，而 SEND_VAR 用于 VARs 和 CVs 的传递。\n相反地，SEND_REF 用来处理按引用传递的参数。因为只有变量才能按引用传递，所以此 opcode 只能接收 VARs 和 CVs。\nSEND_VAL_EX 和 SEND_VAR_EX 是 SEND_VAL 和 SEND_VAR 的变种，用于不能确定参数到底是按值传递还是按引用传递的情况。这两个 opcode 会根据 arginfo 来检查参数的类型然后进行相应操作。大多数情况下，arginfo 结构并没有使用，取而代之的是函数结构中的一个压缩的位向量。\n接着是 SEND_VAR_NO_REF_EX。不要视图从它的名字里去获取什么信息，因为它完全是一个谎言。这个 opcode 用于当传递一个不是真实变量，但是会返回一个不确定参数类型的 VAR 的时候。两个典型的例子就是将一个函数调用的结果作为参数传递，或者将赋值的结果作为参数传递。这些情况下需要一个单独的 opcode 主要有两个原因：其一，如果你试图将类似于赋值操作的表达式按引用传递，它会生成熟悉的\u0026quot;Only variables should be passed by reference\u0026quot;警告（如果使用 SEND_VAR_EX 的话，就会悄悄的允许）。其二，这个 opcode 可以处理我们想把一个返回引用类型数据类型函数的返回值传递给按引用传递的参数的情况(它不会抛出任何信息)。这个 opcode 的一个变种 SEND_VAR_NO_REF 是一个特殊的用来处理我们明确知道参数是一个引用类型的情况。\nSEND_UNPACK 和 SEND_ARRAY 这两个 opcodes 分别用来处理参数解包和内敛call_user_func_array调用。它们都能够将数组中的元素 push 到参数栈中，但是在处理细节上有一些不同（例如：unpacking 支持遍历，而 call_user_func_array 不支持）。如果 unpacking/cufa 被使用，就有可能适当地去扩展栈帧的大小。通常，可以通过移动栈帧顶部指针来扩展。然而，如果达到了栈 page 的边界，就需要分配一个新的 page，然后将整个调用栈帧拷贝到新的 page 当中（我们不能处理跨 page 的栈帧）\n最后一个 opcode 是 SEND_USER，它是用于内敛函数call_user_func调用。\n至此我们还没有讨论过不同的变量查询模式，这里是一个不错的地方来介绍 FUNC_ARG 查询模式。思考形如func($a[0][1][2])的调用，我们不知道在编译时期传入的参数是按值传递还是按引用传递。这两个情况下的行为是不同的。如果是按值传递，而且$a之前为空，那么会产生一些\u0026quot;undefined index\u0026quot;警告。如果按引用传递，那么会悄悄的初始化嵌套数组。FUNC_ARG 访问模式通过检查当前的EX(call)函数的 arginfo 来动态选择两种行为(R 或 W)中的一种，对于上面的例子，opcode 序列如下：\n1INIT_FCALL_BY_NAME \u0026#34;func\u0026#34; 2V0 = FETCH_DIM_FUNC_ARG (arg 1) $a, 0 3V1 = FETCH_DIM_FUNC_ARG (arg 1) V0, 1 4V2 = FETCH_DIM_FUNC_ARG (arg 1) V1, 2 5SEND_VAR_EX V2 6DO_FCALL 查询模式(Fetch modes) PHP 虚拟机有四类用于查询的 opcodes:\n1FETCH_* // $_GET, $$var 2FETCH_DIM_* // $arr[0] 3FETCH_OBJ_* // $obj-\u0026gt;prop 4FETCH_STATIC_PROP_* // A::$prop 如注释中说明的，基础的FETCH_*用来访问变量变量和超全局变量。这些 fetch opcodes 每一类又分 6 种：\n1_R 2_RW 3_W 4_IS 5_UNSET 6_FUNC_ARG 我们已经知道_FUNC_ARG会根据函数是按值传递还是按引用传递来选择_R和_W模式。下面我们来举一些出现不同查询模式的例子：\n1// $arr[0]; 2V2 = FETCH_DIM_R $arr int(0) 3FREE V2 4 5// $arr[0] = $val; 6ASSIGN_DIM $arr int(0) 7OP_DATA $val 8 9// $arr[0] += 1; 10ASSIGN_ADD (dim) $arr int(0) 11OP_DATA int(1) 12 13// isset($arr[0]); 14T5 = ISSET_ISEMPTY_DIM_OBJ (isset) $arr int(0) 15FREE T5 16 17// unset($arr[0]); 18UNSET_DIM $arr int(0) 不幸的是，实际上产生的唯一查询就是FETCH_DIM_R：其他的操作都是通过特定的 opcodes 处理的。注意到ASSIGN_DIM和ASSIGN_ADD都使用一个额外的OP_DATA，因为它们都需要超过 2 个操作数。之所以用到像ASSIGN_DIM这样的特殊 opcodes 而没有用到FETCH_DIM_W+ASSIGN的原因是这些操作可能会被覆盖，例如，通过一个对象实现ArrayAccess::offsetSet()的方式构成ASSIGN_DIM的情形。为了真正产生不同的 fetch types，我们需要增加嵌套层级：\n1// $arr[0][1]; 2V2 = FETCH_DIM_R $arr int(0) 3V3 = FETCH_DIM_R V2 int(1) 4FREE V3 5 6// $arr[0][1] = $val; 7V4 = FETCH_DIM_W $arr int(0) 8ASSIGN_DIM V4 int(1) 9OP_DATA $val 10 11// $arr[0][1] += 1; 12V6 = FETCH_DIM_RW $arr int(0) 13ASSIGN_ADD (dim) V6 int(1) 14OP_DATA int(1) 15 16// isset($arr[0][1]); 17V8 = FETCH_DIM_IS $arr int(0) 18T9 = ISSET_ISEMPTY_DIM_OBJ (isset) V8 int(1) 19FREE T9 20 21// unset($arr[0][1]); 22V10 = FETCH_DIM_UNSET $arr int(0) 23UNSET_DIM V10 int(1) 这里我们看到，最外层的访问通过特定的 opcodes，而嵌套的索引则使用特定模式的 FETCHes。访问不存在的索引是否产生\u0026quot;undefined offset\u0026quot;警告和是否会对查询的数据执行写操作，对于不同的 fetch modes 来说也是不同的：\n1 | Notice? | Write? 2R | yes | no 3W | no | yes 4RW | yes | yes 5IS | no | no 6UNSET | no | yes-ish UNSET 的情况有点特殊，它只会对存在的索引值进行写操作，而跳过没有定义的部分。而一个普通的 write-fetch 操作会先初始化没有定义的变量。\nWrites and memory safety 写查询模式会返回包含一个普通 zval 或者一个指向另一个 zval 的 INDIRECT 指针的 VARs。当然，前面任何对该 zval 的改变都是不可见的，因为这个值只能通过虚拟机临时变量访问。尽管 PHP 禁止形如[][0] = 42这样的表达式，但是我们仍然需要处理类似于call()[0] = 42这种操作。这取决于call()是否返回一个数值还是一个数值的引用。\n另个一个更加特殊的情形是查询返回一个 INDIRECT，其中包含的指向一个记忆体的指针被修改了，例如 hashtable 数组中一个确定的位置，不行的是，这样的指针是很脆弱的，很容易被失效：任何对于该数组并发写操作都可能触发 reallocation，留下一个迷途(dangling)指针，因此在创建 INDIRECT 值的地方和它被消费之间阻止用户代码执行是至关重要的。\n考虑如下例子：\n1$arr[a()][b()] = c(); 将会产生如下 opcode 序列：\n1INIT_FCALL_BY_NAME (0 args) \u0026#34;a\u0026#34; 2V1 = DO_FCALL_BY_NAME 3INIT_FCALL_BY_NAME (0 args) \u0026#34;b\u0026#34; 4V3 = DO_FCALL_BY_NAME 5INIT_FCALL_BY_NAME (0 args) \u0026#34;c\u0026#34; 6V5 = DO_FCALL_BY_NAME 7V2 = FETCH_DIM_W $arr V1 8ASSIGN_DIM V2 V3 9OP_DATA V5 显然，上述 opcode 序列先是从左到右执行函数调用，然后才执行一些必要的写查询操作（我们称这里的 FETCH_DIM_W 操作是“延迟操作”）。这样能确保写查询操作和消费指令能够直接相邻。\n再来思考另一个例子：\n1$arr[0] = \u0026amp;$arr[1]; 这里有一个小问题：赋值语句两边都必须使用写查询操作。然而，如果我们先查询$arr[0]进行写操作，然后再对$arr[1]进行写操作，后者将会使前者失效。这个问题的解决如下：\n1v2 = FETCH_DIM_W $arr 1 2v3 = MAKE_REF V2 3V1 = FETCH_DIM_W $arr 0 4ASSIGN_REF V1 V3 这里首先对$arr[1]进行写查询操作，然后通过使用MAKE_REF转换成一个引用，转换的结果不再是一个 INDIRECT，也不会遵循失效的规则，这样的话，查询$arr[0]就变得很安全。\n异常处理(Exception handling) 异常是万恶之源。\n异常是通过向EG(exception)中写入异常而产生的，这里EG代表的是执行全局变量(executor globals)。在 C 语言中抛出异常并不会导致堆栈展开，相反，错误信息会通过返回失败值或检查EG(exception)向上传播。异常只有当控制权重新进入到虚拟机代码中的时候才会被处理。几乎所有的 VM 指令都能够在某些情形下直接或间接产生异常。例如一些\u0026quot;undefined variable\u0026quot;警告可能会产生异常，如果使用了自定义的错误处理的话。我们想避免在每一个 VM 指令执行后都去检查EG(exception)是否被设置，这里用到了一个小技巧：\n当异常被抛出的时候，当前的执行数据中的 opline 会被替换成一个虚设的HANDLE_EXCEPTIONopline（这显然不会改变 op array，它仅仅是一个直接的指针）。搜集 exception 处的 opline 会回到EG(opline_before_exception)。也就是说，当控制权返回到虚拟机调度循环中的时候，HANDLE_EXCEPTIONopline 会被执行。这种模式下有一个小问题：存放在 execute data 中的 opline 必须是当前执行的 opline（否则的话 opline_before_exception 就是错的），其次虚拟机使用 execute data 中的 opline 来继续执行（否则 HANDLE_EXCEPTION 将不会被执行）。\n尽管这些条件看起来不那么重要，其实不然。原因就是虚拟机可能因为存储在 execute data 中的变量跟 opline 不同步而工作在不同的 opline。在 PHP7 之前，只有少数 GOTO 和 SWITCH 可能导致上述情况，而在 PHP7 中，这是操作的默认模式：如果编译器支持的话，opline 被存放在全局寄存器中。\n在执行一些操作之前可能会抛出异常，本地 opline 必须被写回到 execute data（SAVE_OPLINE 操作）。类似的，潜在的异常抛出之后，本地 opline 必须从 execute data 中移出（通常是一个 CHECK_EXCEPTION 操作）。\n现在我们知道了当一个异常抛出后，通过执行 HANDLE_EXCEPTION opcode 的机制来处理，但是它到底做了些什么呢？首先，它会确定异常是否在一个 try 代码块中抛出。为此，op array 包含了一个数组来跟踪 opline 相对于 try,catche,和 finally 代码块的偏移。\n1typedef struct _zend_try_catch_element { 2\tuint32_t try_op; 3\tuint32_t catch_op; /* ketchup! */ 4\tuint32_t finally_op; 5\tuint32_t finally_end; 6} zend_try_catch_element; 我们假设 finally 代码块不存在，因为它是一个完全不同的兔子洞(rabbit hole)。假如我们确实在一个 try 代码块中，VM 需要清理从开始抛出异常之后 try 代码块结束之前的所有的未完成的操作。这个操作会释放栈帧和相关正在执使用的数据，同时也会释放活跃状态的临时变量。大多数临时变量都是短命的，因为消费指令通常紧跟产生临时变量指令之后。然而可能会有临时变量生存期跨越多个指令的时候，潜在的异常被抛出：\n1# (array)[] + throwing() 2L0: T0 = CAST (array) [] 3L1: INIT_FCALL (0 args) \u0026#34;throwing\u0026#34; 4L2: V1 = DO_FCALL 5L3: T2 = ADD T0, V1 在上面的例子中，变量T0存活于指令L1和L2，在这种情况下，如果抛出异常，就需要将其释放。有一种典型的情况会产生长命的临时变量，那就是迭代中的变量，例如：\n1# foreach ($array as $value) throw $ex; 2L0: V0 = FE_RESET_R $array, -\u0026gt;L4 3L1: FE_FETCH_R V0, $value, -\u0026gt;L4 4L2: THROW $ex 5L3: JMP -\u0026gt;L1 6L4: FE_FREE V0 这里有一个\u0026quot;loop variable\u0026rdquo; V0，从L1一直到L3（通常会延续整个迭代体内）。临时变量的生命周期使用如下的结构存放在 op array 中：\n1typedef struct _zend_live_range { 2 uint32_t var; /* low bits are used for variable type (ZEND_LIVE_* macros) */ 3 uint32_t start; 4 uint32_t end; 5} zend_live_range; 这里var是这个周期描述的（operand encoded）变量，start是起始 opline 偏移量（不包括自动生成的指令），end是终止 opline 的偏移（包括消费指令）。当然只有当临时变量没有被立即消费的时候才会有声明周期存在。\nvar的低位被用来存放变量类型，它们可能是下面类型中的一种：\nZEND_LIVE_TEMVAR：这是一个普通的变量。它里边包含了一个原始的 zval 值。释放这种变量的行为类似于FREEopcode ZEND_LIVE_LOOP：这是一个 foreach 迭代变量，它包含的不仅仅是一个简单的 zval。它的释放对应的是FE_FREEopcode ZEND_LIVE_SILENCE：这种类型的变量用于实现错误抑制操作。将一个旧的错误备份到一个临时变量中，如果后边有异常抛出，显然我们希望能够还原它。这种临时变量的释放对应的是END_SILENCE ZEND_LIVE_ROPE：这中类型的变量是用来连接一串字符串的，在这种情况下临时变量是一个位于栈中的存放zend_string*指针的固定大小的数组，从中移出的 strings 必须被释放。对应的释放操作大约是END_ROPE。 有一个很滑稽的问题需要考虑，就是当临时变量的产生和消费操作之一抛出异常了，那么这个临时变量还需要被释放吗。例如下面的简单代码：\n1T2 = ADD T0, T1 2ASSIGN $v, T2 如果ADD中抛出异常，临时变量T2会被自动释放吗，或者说ADD指令对它负责吗？同理如果ASSIGN抛出异常，T2会自动释放吗，或者ASSIGN必须考虑做这件事？后面的情况中，答案是很显然的：指令总是负责释放它的操作数，即使有异常抛出。而对于产生操作数的情况，就不那么寻常，因为在 PHP7.1 和 PHP7.2 中，答案是不一样的：在 PHP7.1 中指令负责在产生异常的时候释放临时变量，而在 PHP7.2 中，它们会被自动释放（而指令总是负责确保临时变量总是被移出栈）。这种改变的原因是这种方式能够实现许多基本指令（例如 ADD），它们通常的结构如下：\n11. 读取输入操作数 22. 执行操作，将结果写入result操作数中 33. 释放输入操作数（如果有必要的话） 这里是有问题的，因为 PHP 有一个很不幸的地方就是它不仅支持异常处理和析构，还支持在析构中抛出异常（这也正式令编译器工程师们感到恐惧的地方）。如此以来，在第三步中可以抛出异常，此时的结果已经移出栈，为了避免这种临界情况下造成内存泄露，释放结果操作数的责任就从指令转移给了异常处理机制。\n一旦我们执行了那些清理操作，我们就能继续执行 catch 代码块。如果没有 catch（也没有 finally）的话，就会展开堆栈，也就是说销毁当前栈帧，并且在异常处理时给父栈帧一个快照（原文： i.e. destroy the current stack frame and give the parent frame a shot at handling the exception.）。\n你已经欣赏到了异常处理的整个丑态，我将介绍另一个跟析构函数异常处理相关的部分，虽然这跟实践无关，但是我们仍然需要保证它处理的正确性。看下面代码：\n1foreach (new Dtor as $value) { 2 try { 3 echo \u0026#34;Return\u0026#34;; 4 return; 5 } catch (Exception $e) { 6 echo \u0026#34;Catch\u0026#34;; 7 } 8} 想象一下，Dtor是一个可遍历的类，并且有一个可能抛出异常的析构函数。上面的代码将会得到下面的 opcode 序列：\n1L0: V0 = NEW \u0026#39;Dtor\u0026#39;, -\u0026gt;L2 2L1: DO_FCALL 3L2: V2 = FE_RESET_R V0, -\u0026gt;L11 4L3: FE_FETCH_R V2, $value 5L4: ECHO \u0026#39;Return\u0026#39; 6L5: FE_FREE (free on return) V2 # \u0026lt;- return 7L6: RETURN null # \u0026lt;- return 8L7: JMP -\u0026gt;L10 9L8: CATCH \u0026#39;Exception\u0026#39; $e 10L9: ECHO \u0026#39;Catch\u0026#39; 11L10: JMP -\u0026gt;L3 12L11: FE_FREE V2 # \u0026lt;- the duplicated instr 特别注意的是，\u0026ldquo;return\u0026quot;被编译成了一个FE_FREE和一个RETURN。由于Dtor有一个能够抛出异常的析构函数，如果FE_FREE抛出异常会发生什么呢？通常情况下，我们可能会说这个指令在 try 代码块内部，所以会执行 catch。然而，这种情况下，循环变量已经被销毁了。catch 丢弃了异常然后尝试继续遍历一个已经破坏掉的循环变量。造成这种情况的原因是因为当抛出的FE_FREE在 try 代码块内部的时候，它其实是 L11 中FE_RETURN的一个拷贝，逻辑上来说，那才是异常真正发生的地方。这就是为什么中断产生的FE_FREE被注释为FREE_ON_RETURN，这样能指示异常处理机制将异常代码移动到最初的释放指令。因此上书代码不会执行 catch 代码块，而是会生成一个未捕获的异常。\nFinally handling PHP 中 finally 的历史可谓是历经坎坷。在 PHP5.5 中首次实现 finally 特性，然而那实在是一个 bug 很多的实现。随后在 PHP5.6，7.0，7.1 每一次版本变更的时候，对 finally 的核心代码都进行了重构，每一次都修复了一些 bug，但是却没有达到完全正确的 finally 实现。看起来 PHP7.1 终于成功了。\n当我在写这一节的时候，我惊奇的发现，透过当前 PHP 的实现和我的理解，finally 处理并不是那么复杂。而且，通过不同的迭代来实现从某种成都上使得问题变得更加简单而不是更复杂。下面我来告诉大家对问题的不充分理解是如何导致一个既复杂又 bug 居多的结果的（虽然，公平的说，PHP5 中实现的一部分复杂性是由于缺乏 AST（abstract syntax tree，抽象语法树）直接造成的）。\n无论是正常的（例如：使用 return）还是不正常的（例如抛出异常）运行流程下，Finally 代码块总是运行在 try 代码块之后。有一些临界情况需要考虑，在描述实现原理之前我会做一些简单说明：\n1try { 2\tthrow new Exception(); 3} finally { 4\treturn 42; 5} 上面的代码会有怎样的执行结果呢？Finally 赢了，最后会返回 42。那么再思考下面的代码：\n1try { 2\treturn 24; 3} finally { 4\treturn 42; 5} 同样的还是 Finally 赢了，结果依然是 42，Finally 总是会赢。\nPHP 会禁止跳出 finally 代码块。例如下面的代码是不允许的：\n1foreach ($array as $value) { 2\ttry { 3\treturn 42; 4\t} finally { 5\tcontinue; 6\t} 7} 上面代码中的\u0026quot;continue\u0026quot;会产生一个编译错误。但是需要理解的是，这种限制其实就是一种装饰，因为我们很容易使用一种众所周知的 catch 控制代理模式来绕过它：\n1foreach ($array as $value) { 2\ttry { 3\ttry { 4\treturn 42; 5\t} finally { 6\tthrow new JumpException; 7\t} 8\t} catch (JumpException $e) { 9\tcontinue; 10\t} 11} 唯一真正存在的限制就是我们不能跳到一个 finally 代码块中，例如使用一个 goto 语句从 finally 外部跳到一个 finally 内部的标签是不允许的。\n通过一些简单的方式，我们可以看到 finally 是如何工作的。它的实现上是使用了两个 opcodes，FAST_CALL和FAST_RET。大体上，FAST_CALL是用来跳到 finally 代码块中，而FAST_RET是用来跳出的。我们来分析下面的例子：\n1try { 2\techo \u0026#34;try\u0026#34;; 3} finally { 4\techo \u0026#34;finally\u0026#34;; 5} 6 7echo \u0026#34;finished\u0026#34;; 上述代码会生成下面的 opcode 序列：\n1L0: ECHO string(\u0026#34;try\u0026#34;) 2L1: T0 = FAST_CALL -\u0026gt;L3 3L2: JMP -\u0026gt;L5 4L3: ECHO string(\u0026#34;finally\u0026#34;) 5L4: FAST_RET T0 6L5: ECHO string(\u0026#34;finished\u0026#34;) 7L6: RETURN int(1) FAST_CALL将它自己的位置保存在T0中，然后跳到 finally 代码块L3处。当执行到FAST_RET的时候，它会跳到之前保存在T0的位置之后一个位置，也就是上述代码中的L2处。这就是一个最基本的情况，没有 return 和 exception 发生。下面我们来分析下异常发生的情况：\n1try { 2 throw new Exception(\u0026#34;try\u0026#34;); 3} catch (Exception $e) { 4 throw new Exception(\u0026#34;catch\u0026#34;); 5} finally { 6 throw new Exception(\u0026#34;finally\u0026#34;); 7} 当处理异常的时候，我们需要考虑抛出异常的位置相对于 try/catch/finally 代码块的偏移：\n如果在 try 中抛出异常：移出$e然后跳到 catch. 如果在 catch 中或者在 try 中抛出但是没有匹配到合适的 catch，如果有 finally 代码块：跳到 finally 代码块，然后将 exception 备份到FAST_CALL临时变量中 如果在 finally 中抛出异常：如果有一个备份的异常存在于FAST_CALL临时变量中，将其关联到成当前异常的上一个异常。继续向外抛出异常到下一个 try/catch/finally。 否则：继续向外抛出异常到下一个 try/catch/finally。 前面的小例子能够覆盖到前三步：先 try，抛出异常，触发一个 jump 到 catch，catch 中继续抛出异常，触发一个 jump 到 finally，并且将 catch 中的异常备份到 FAST_CALL 中。finally 中续集抛出，\u0026ldquo;finally\u0026quot;异常会将\u0026quot;catch\u0026quot;链接成自己前一个异常继续向外抛出。\n我们对上面的代码做一些小的改动：\n1try { 2 try { 3 throw new Exception(\u0026#34;try\u0026#34;); 4 } finally {} 5} catch (Exception $e) { 6 try { 7 throw new Exception(\u0026#34;catch\u0026#34;); 8 } finally {} 9} finally { 10 try { 11 throw new Exception(\u0026#34;finally\u0026#34;); 12 } finally {} 13} 上面代码中，所有的内层 finally 都有异常进入，但是都正常退出了（通过 FAST_RET）。在这种情况下，前面描述的异常处理过程从外层 try/catch/finally 处恢复执行。外层的 try/catch 被存放在 FAST_RET opcode 中。\n了解到了 finally 和异常互动的本质，那么 return 和 finally 又会是什么样的呢？\n1try { 2 throw new Exception(\u0026#34;try\u0026#34;); 3} finally { 4 return 42; 5} 上面的代码会生成下面的 opcode 序列：\n1L4: T0 = FAST_CALL -\u0026gt;L6 2L5: JMP -\u0026gt;L9 3L6: DISCARD_EXCEPTION T0 4L7: RETURN 42 5L8: FAST_RET T0 这里的DISCARD_EXCEPTION opcode 是用来忽略 try 代码块中的异常的（记住：最终 finally 中的 return 赢了）。那么如果 return 在 try 里边呢？\n1try { 2 $a = 42; 3 return $a; 4} finally { 5 ++$a; 6} 这里返回的值是 42 而不是 43。返回值发生在return $a这行，任何后续对$a的修改都不用考虑。生成的 opcode 序列如下：\n1L0: ASSIGN $a, 42 2L1: T3 = QM_ASSIGN $a 3L2: T1 = FAST_CALL -\u0026gt;L6, T3 4L3: RETURN T3 5L4: T1 = FAST_CALL -\u0026gt;L6 # unreachable 6L5: JMP -\u0026gt;L8 # unreachable 7L6: PRE_INC $a 8L7: FAST_RET T1 9L8: RETURN null 有两个 opcodes 是不可达的，因为它们发生在 return 之后，通过优化将会移除它们，但是这里展示的是没有优化过的代码。这里有两个很有意思的地方：首先$a通过QM_ASSIGN（这是一个基本的拷贝到临时变量的指令）拷贝到T3中，这就是为什么能防止后续对$a的操作影响到返回值，其次就是T3也被传递给了FAST_CALL，它的值会在T1中备份，如果 try 中的 return 在后面的操作中被忽略了（例如 finally 中抛出异常或出现 return），这种机制将会用来释放没有使用的返回值。\n所有的这些案例机制都很简单，但是当他们组合到一起的时候就需要注意了。考虑下面的例子，如果Dtor又是一个可遍历的类，而且有一个会抛出异常的析构函数：\n1try { 2 foreach (new Dtor as $v) { 3 try { 4 return 1; 5 } finally { 6 return 2; 7 } 8 } 9} finally { 10 echo \u0026#34;finally\u0026#34;; 11} 生成的 opcode 序列为：\n1L0: V2 = NEW (0 args) \u0026#34;Dtor\u0026#34; 2L1: DO_FCALL 3L2: V4 = FE_RESET_R V2 -\u0026gt;L16 4L3: FE_FETCH_R V4 $v -\u0026gt;L16 5L4: T5 = FAST_CALL -\u0026gt;L10 # inner try 6L5: FE_FREE (free on return) V4 7L6: T1 = FAST_CALL -\u0026gt;L19 8L7: RETURN 1 9L8: T5 = FAST_CALL -\u0026gt;L10 # unreachable 10L9: JMP -\u0026gt;L15 11L10: DISCARD_EXCEPTION T5 # inner finally 12L11: FE_FREE (free on return) V4 13L12: T1 = FAST_CALL -\u0026gt;L19 14L13: RETURN 2 15L14: FAST_RET T5 try-catch(0) 16L15: JMP -\u0026gt;L3 17L16: FE_FREE V4 18L17: T1 = FAST_CALL -\u0026gt;L19 19L18: JMP -\u0026gt;L21 20L19: ECHO \u0026#34;finally\u0026#34; # outer finally 21L20: FAST_RET T1 执行第一个 return 的序列是FAST_CALL，L10，FE_FREE V4，FAST_CALL L19，RETURN，然后就会执行到内部的 finally 中，接着释放 foreach loop variable，然后进入到外层的 finally，然后再 return。执行第二次 return 的序列是DISCARD_EXCEPTION T5，FE_FREE V4，FAST_CALL L19。这里先忽略了内部 try 代码块中的 exception（或者这里是 return value），然后释放了 foreach loop variable 最后执行外部的 finally 代码块。要注意的是到所有情况中这些指令的顺序相对于实际的代码块是如何颠倒的。\n生成器 (Generators) 生成器函数可以暂停和恢复执行，而且需要特殊的 VM 栈来管理。下面是一个简单的生成器：\n1function gen($x) { 2 foo(yield $x); 3} 生成如下 opcode 序列：\n1$x = RECV 1 2GENERATOR_CREATE 3INIT_FCALL_BY_NAME (1 args) string(\u0026#34;foo\u0026#34;) 4V1 = YIELD $x 5SEND_VAR_NO_REF_EX V1 1 6DO_FCALL_BY_NAME 7GENERATOR_RETURN null 在GENERATOR_CREATE到达之前，代码在普通的函数中执行在普通的 VM 栈里。接着GENERATOR_CREATE创建一个Generator对象，同时创建一个堆分配的 execute_data 结构，里边拷贝了 VM 栈中 execute_data。当生成器再次恢复的时候，执行器会使用堆分配的 execute_data，否则的话就继续将调用栈帧压入主 VM 栈中。一个明显的问题就是当一个调用正在进行的时候，可能会中断生成器，正如前面的例子中展示的那样，YIELD执行的时候调用foo()的栈帧已经被压入到 VM 栈中。这些相关的不常见的情形都是通过在控制权让出的时候将当前活跃的调用栈帧拷贝到生成器结构中，在生成器恢复的时候再恢复它们来处理的。\n这种设计直到 PHP7.1 才被使用，之前的版本中每个生成器都有它自己的 4KB 大小的虚拟机 page，它们会在生成器恢复的时候交换到执行器里。这样避免了对调用栈帧的拷贝，否则就需要使用更多的记忆体。\nSmart branches 一个比较指令后面跟一个跳转指令的情况很常见，就想下面这样：\n1L0: T2 = IS_EQUAL $a, $b 2L1: JMPZ T2 -\u0026gt;L3 3L2: ECHO \u0026#34;equal\u0026#34; 由于这种模式太常见了，所有的比较指令（例如 IS_EQUAL）实现了一个只能分支机制：它们会检查它们后面的指令是否是 JMPZ 或 JMPNZ 指令，如果是的话，自动执行后续的相应的跳转指令。\n智能分支机制只会校验跟在它后面的指令是否为 JMPZ/JMPNZ，而不会校验它们的操作数是否是比较指令的结果。需要特别注意的是比较操作和跳转操作并不是直接相邻的情况，例如：($a == $b) + ($d ? $e : $f)会生成下面的执行序列：\n1L0: T5 = IS_EQUAL $a, $b 2L1: NOP 3L2: JMPZ $d -\u0026gt;L5 4L3: T6 = QM_ASSIGN $e 5L4: JMP -\u0026gt;L6 6L5: T6 = QM_ASSIGN $f 7L6: T7 = ADD T5 T6 8L7: FREE T7 注意到NOP被插入到了IS_EQUAL和JMPZ之间。如果没有这里的NOP的话，分支最终就会使用IS_EQUAL的结果，而不是 JMPZ 操作数。\nRuntime cache 由于 opcode array 在多进程中是共享的（没有锁），它们是绝度不可变的。但是，运行时的数值可能会被缓存在独立的“runtime cache”中，它们基本上就是一个指针数组。字面量通常有一个相关的 runtime cache 的入口（也可能是多个），被存放在它们的 u2 槽中。\nruntime cache entries 有两种类型：一个是原始的 cache entries，例如 INIT_FCALL 使用的那种，当 INIT_FCALL 查找到调用的函数后，函数指针就会被缓存在一个相关的 runtime cache 里。另一个是 polymorphic cache entries，它有两个连续的缓存槽，第一个存放 class entry，第二个用来存放资料。像 FETCH_OBJ_R 这样的操作会使用这种 cache entry。当一个确定类的属性相对于属性表的偏移被缓存后，如果接下来有对这个类有同样的访问时，就会使用缓存，否则就会再次执行昂贵的查找操作，然后将新的结果缓存起来。\nVM interrupts 在 PHP7.0 以前，执行超时通常的处理是使用一个longjump直接从信号处理跳转到 shutdown 执行序。你也许能够想象到，这样造成了各种不愉快的行为。直到 PHP7.0，超时会延迟直到控制权重新还给虚拟机。如果它不在一定宽限的时期返回，进程就会终止。到了 PHP7.1，pcntl 信号处理使用同样的机制来处理执行超时。\n当收到一个等待信号，VM 中断标记就会被设置，而且此标记会在一个确定的地方被虚拟机校验。校验只会在 jumps 和 calls 指令中进行，而不会在所有指令中发生。因此，中断并不会立刻被处理并返回控制权给 VM，而是在线性控制流的当前段结束的时候处理。\nSpecialization 如果你看过 VM 的定义文件，你就会发现 opcode handler 的定义长得是这个样子的：\n1ZEND_VM_HANDLER(1, ZEND_ADD, CONST|TMPVAR|CV, CONST|TMPVAR|CV) 这里的1是 opcode number，ZEND_ADD是名字，其他两个参数是可接受的操作数类型。自动生成的虚拟机代码会包含所有可能的操作数类型的 handler，它们会被大致命名为形如ZEND_ADD_SPEC_CONST_CONST_HANDLER的格式。\n特定的 handlers 在自动生成的时候，handler body 里会被替换成一些特殊的宏，一个很明显的例子就是OP1_TYPE和OP2_TYPE，而像GET_OP1_ZVAL_PTR()和FREE_OP1()这样的操作同样是特定的。\nADD handler 接收CONST|TMPVAR|CV类型的操作数。TMPVAR在这里表示 opcode 既能接收TMPs也能接收VARs，只是没有将他们特别的区分开。再强调一遍，大多数情况下，TMP和VAR的唯一区别在于后者能够包含引用类型的数据。对于像ADD这样的操作，将它们区分开是没有意义的。其他一些确实需要将它们区分对待的操作会在它们的操作数列表中使用TMP|VAR。\n不仅可以特定操作数类型，handlers 也可以特定其他的元素，例如它是否有返回值。例如ASSIGN_DIM：\n1ZEND_VM_HANDLER(147, ZEND_ASSIGN_DIM, 2 VAR|CV, CONST|TMPVAR|UNUSED|NEXT|CV, SPEC(OP_DATA=CONST|TMP|VAR|CV)) 在这样的签名下，$ 2 * 4 * 4 $种不同的ASSIGN_DIM会被自动生成。在上面的定义中，第二个操作数包含了一个NEXT，它跟限定因素无关，而是表明一个UNUSED操作数存在于它的上下文中：也就是说这是一个 append 操作（$arr[]）。另一个例子：\n1ZEND_VM_HANDLER(23, ZEND_ASSIGN_ADD, 2 VAR|UNUSED|THIS|CV, CONST|TMPVAR|UNUSED|NEXT|CV, DIM_OBJ, SPEC(DIM_OBJ)) 这里我们的第一个操作数有一个UNUSED标识通常表示访问一个$this。这是对象相关 opcode 的惯例，例如FETCH_OBJ_R_UNUSED, 'prop'表示的是$this-\u0026gt;prop。而第二个UNUSED操作数表示一个 append 操作。这里的第三个参数是扩展操作数：它包含了用以区分$a += 1，$a[$b] += 1，$a-\u0026gt;b +=1的标记。最后的SPEC(DIM_OBJ)表明应该为它们每一个都生成一个专门的 handler。（这种情况下生成的 handler 的数量是未知的，因为 VM 不可能知道确定的组合，例如一个UNUSED op1 只能和 OBJ 相关）\n最后虚拟机生成器还会做一些额外的支持和更加复杂的特定机制。在 VM 定义文件的最后，你可以发现一些类似于下面的 handlers:\n1ZEND_VM_TYPE_SPEC_HANDLER( 2 ZEND_ADD, 3 (res_info == MAY_BE_LONG \u0026amp;\u0026amp; op1_info == MAY_BE_LONG \u0026amp;\u0026amp; op2_info == MAY_BE_LONG), 4 ZEND_ADD_LONG_NO_OVERFLOW, 5 CONST|TMPVARCV, CONST|TMPVARCV, SPEC(NO_CONST_CONST,COMMUTATIVE) 6) 这些特定的 handler 不仅根据 VM 操作数类型，还会根据操作数在运行时可能存在的类型。这种可能的操作数类型机制属于 opcache 优化设施的一部分而且已经超出了本文的范围。但是，假设这个信息可以被获取到，那么我们就能清楚明白这是一个形如int + int -\u0026gt; int的额外 handler。此外，SPEC声明说明两种 CONST 操作数类型的 handler 不被生成，而且两个操作数可以交换（加法交换律），因此，如果我们已经有一个CONST+TEMPVARCV的设定，就不必再生成一个TMPVARCV+CONST了。\nFast-path / slow-path split 一些 opcode handlers 的实现都做了 fast-path 和 slow-path 的区分，首先会处理一些常见案例，其次才会进入到泛型实现中。是时候看看真实的代码是如何实现的了，下面是我粘贴的关于 SL(shift-left)的实现：\n1ZEND_VM_HANDLER(6, ZEND_SL, CONST|TMPVAR|CV, CONST|TMPVAR|CV) 2{ 3\tUSE_OPLINE 4\tzend_free_op free_op1, free_op2; 5\tzval *op1, *op2; 6 7\top1 = GET_OP1_ZVAL_PTR_UNDEF(BP_VAR_R); 8\top2 = GET_OP2_ZVAL_PTR_UNDEF(BP_VAR_R); 9\tif (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG) 10\t\u0026amp;\u0026amp; EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG) 11\t\u0026amp;\u0026amp; EXPECTED((zend_ulong)Z_LVAL_P(op2) \u0026lt; SIZEOF_ZEND_LONG * 8)) { 12\tZVAL_LONG(EX_VAR(opline-\u0026gt;result.var), Z_LVAL_P(op1) \u0026lt;\u0026lt; Z_LVAL_P(op2)); 13\tZEND_VM_NEXT_OPCODE(); 14\t} 15 16\tSAVE_OPLINE(); 17\tif (OP1_TYPE == IS_CV \u0026amp;\u0026amp; UNEXPECTED(Z_TYPE_INFO_P(op1) == IS_UNDEF)) { 18\top1 = GET_OP1_UNDEF_CV(op1, BP_VAR_R); 19\t} 20\tif (OP2_TYPE == IS_CV \u0026amp;\u0026amp; UNEXPECTED(Z_TYPE_INFO_P(op2) == IS_UNDEF)) { 21\top2 = GET_OP2_UNDEF_CV(op2, BP_VAR_R); 22\t} 23\tshift_left_function(EX_VAR(opline-\u0026gt;result.var), op1, op2); 24\tFREE_OP1(); 25\tFREE_OP2(); 26\tZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION(); 27} 实现以使用GET_OPn_ZVAL_PTR_UNDEF在BP_VAR_R模式下查询操作数开始，这里的UNDEF部分表示的是在处理 CV 的时候不需要检查变量是否被定义，而是只需要返回一个 UNDEF 数值。当我们拿到了操作数，我们校验它们是否都是整数类型和移动的长度是超出范围，然后操作的结果会被直接计算出来，我们会继续执行下一个 opcode。因为这里的类型校验不会处理 UNDEF 的操作数，所以这里使用GET_OPn_ZVAL_PTR_UNDEF是恰当的。\n如果操作数不能满足 fast-path，我们就会进入到一般的实现当中，这种实现以SAVE_OPLINE()开始，这就是一个信号表明了“潜在的操作如下”。在进行其他操作之前，需要处理未定义的变量的强开。GET_OPn_UNDEF_CV在这种情况下会发出一个未定义变量的警告并且返回 NULL。接着普通的shift_left_function被调用，并且将结果写入到EX_VAR(opline-\u0026gt;result.var)中，最后将输入操作数释放掉（如果有必要的话），然后检查异常后推进执行下一个 opcode（这表明，在推进前 opline 会被重置）。\n对于上面的代码，fast-path 节省了两次对未定义变量的校验和一次函数调用，释放操作，还有保存和重置 opline 给异常处理的操作。大多数对性能敏感的 opcode 都是以这种方式呈现的。\nVM macros 正如前面代码清单中看到的那样，虚拟机实现了许多可以自由使用的宏。其中一些是普通的 C 语言宏，另一些在虚拟机被生成的时候才会确定。特别地，这些宏包含了一些查找和释放指令的操作：\n1OPn_TYPE 2OP_DATA_TYPE 3 4GET_OPn_ZVAL_PTR(BP_VAR_*) 5GET_OPn_ZVAL_PTR_DEREF(BP_VAR_*) 6GET_OPn_ZVAL_PTR_UNDEF(BP_VAR_*) 7GET_OPn_ZVAL_PTR_PTR(BP_VAR_*) 8GET_OPn_ZVAL_PTR_PTR_UNDEF(BP_VAR_*) 9GET_OPn_OBJ_ZVAL_PTR(BP_VAR_*) 10GET_OPn_OBJ_ZVAL_PTR_UNDEF(BP_VAR_*) 11GET_OPn_OBJ_ZVAL_PTR_DEREF(BP_VAR_*) 12GET_OPn_OBJ_ZVAL_PTR_PTR(BP_VAR_*) 13GET_OPn_OBJ_ZVAL_PTR_PTR_UNDEF(BP_VAR_*) 14GET_OP_DATA_ZVAL_PTR() 15GET_OP_DATA_ZVAL_PTR_DEREF() 16 17FREE_OPn() 18FREE_OPn_IF_VAR() 19FREE_OPn_VAR_PTR() 20FREE_UNFETCHED_OPn() 21FREE_OP_DATA() 22FREE_UNFETCHED_OP_DATA() 如你所见，这些宏有很多类型。BP_VAR_*参数指定了查找模式，支持同样模式的还有FETCH_*指令。\nGET_OPn_ZVAL_PTR()是一个基本的操作数查找指令。如果遇到未定义的 CV，会抛出一个警告，并且不会解引操作数。GET_OPn_ZVAL_PTR_UNDEF()不会校验 CVs 是否为未定义，GET_OPn_ZVAL_PTR_DEREF()包含了对 zval 的DEREF操作，这是 GET 操作的一部分，因为解引对 CVs 和 VARs 是很有必要的，但是不适用于 CONSTs 和 TMPs。由于这个宏需要区分 TMPs 和 VARs，所以只能被用于TMP|VAR类型操作数中（而不能用于TMPVAR）。\nGET_OPn_OBJ_ZVAL_PTR*()是一类会额外处理 UNUSED 操作数的宏。正如前面提到的，在访问$this的情况下，使用一个 UNUSED 操作数，GET_OPn_OBJ_ZVAL_PTR*()宏会为 UNUSED 操作数返回一个EX(This)的引用。\n最后，还有一类PTR_PTR的宏，这种名字是 PHP5 时代的残存物，它们实际上用于对 zval 双重取址的指针。这些宏在被用于写操作的时候只适用于 CV 和 VAR 类型的操作数（其他的一律返回 NULL）。\nFREE_OP*()宏用于释放查询到的操作数。操作的时候，它们需要一个定义为zend_free_op free_opN的变量，其中 GET 操作存放的数据会被释放。FREE_OPn()操作会释放 TMPs 和 VARs，但是不会释放 CONSTs 和 CVs。FREE_OPn_IF_VAR()顾名思义：如果操作数是一个 VAR 的话就释放。\nFREE_OP*_VAR_PTR()是跟PTR_PTR查询结合使用的，它只会释放 VAR 操作数并且它们不能是 INDIRECTed。\nFREE_UNFETCHED_OP*()用于操作数在被 GET 查找之前就必须被释放的情况。典型的使用场景就是当异常发生在操作数查找前面的时候。\n除了这些特定的宏，还有一些更普通的宏。VM 定义了一些用于控制一个 opcode handler 执行完之后的行为的宏：\n1ZEND_VM_CONTINUE() 2ZEND_VM_ENTER() 3ZEND_VM_LEAVE() 4ZEND_VM_RETURN() CONTINUE 会继续执行正常的 opcodes，ENTER/LEAVE 用于进入或退出一个嵌套函数调用。这些操作的具体细节取决于编译器是如何编译的。从广义上讲，它们在继续执行前会同步一些全局状态。RETURN 用于退出主 VM 循环。\nZEND_VM_CONTINUE()要求 opline 事先更新完。当然也有一些其他的相关的宏：\n1 | Continue? | Check exception? | Check interrupt? 2ZEND_VM_NEXT_OPCODE() | yes | no | no 3ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION() | yes | yes | no 4ZEND_VM_SET_NEXT_OPCODE(op) | no | no | no 5ZEND_VM_SET_OPCODE(op) | no | no | yes 6ZEND_VM_SET_RELATIVE_OPCODE(op, offset) | no | no | yes 7ZEND_VM_JMP(op) | yes | yes | yes 这个表格展示了哪些宏当中隐含了 ZEND_VM_CONTINUE()操作，它们是否需要做异常校验和是否校验 VM 中断。\n接着是SAVE_OPLINE()，LOAD_OPLINE()和HANDLE_EXCEPTION()。正如前面提到的，SAVE_OPLINE()用于 opcode handler 中第一次进入 slow-path 操作之前。如果有必要的话，它会将 VM 使用的 opline 备份（通常在一个全局寄存器）到 execute data 里。LOAD_OPLINE()是一个逆操作，但是现今它已经很少被使用，因为它被有效的柔和到 ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION()和 ZEND_VM_JMP()里了。\nHANDLE_EXCEPTION()用于当你在一个 opcode handler 返回前已经明确知道有异常被抛出的情况下。它会同时执行 LOAD_OPLINE 和 CONTINUE，它们被有效的分配到了 HANDLE_EXCEPTION opcode 里。\n当然，还有很多宏没有介绍到，但是我想这里应该已经覆盖到最重要的部分了吧。\n","date":"November 29, 2017","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/php/2017-11-29-php7%E8%99%9A%E6%8B%9F%E6%9C%BA/","series":[],"smallImg":"","tags":[{"title":"C","url":"/blog/tags/c/"},{"title":"Php","url":"/blog/tags/php/"},{"title":"Compiler","url":"/blog/tags/compiler/"}],"timestamp":1511913600,"title":"PHP7虚拟机"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"Programming","url":"/blog/categories/programming/"}],"content":"原文地址http://blog.jpauli.tech/2017/01/12/threads-and-php.html\n前言 PHP 和线程，单凭这简短的几个字，就足以写一本书。像往常一样，我们不会这么做，但是会给出一定程度上跟这个话题相关的信息与细节。让我们从一些人在谈论这个话题时通常感到的困惑开始，PHP 不是一种线程语言， PHP 的内核没有使用线程，而且 PHP 天生也不允许用户层代码通过任何方式使用多线程作为并发机制。\n因此 PHP 跟其他一些技术有很大的区别，例如 Java。Java 不仅自身使用了大量的线程，它还允许用户通过编程来是用线程。然而，PHP 不适用线程是有它的原因的。\nPHP 内核没有使用线程，主要是为了简化开发。当你读到下一节的时候，你就会了解到线程并不是一个能使任何程序都能更快运行的魔法技术。是不是听起来很像是在推销不是吗？但是我们不是推销，而是谈论技术，而且 我们很清楚我们在说什么。因此 PHP 引擎目前没有使用多线程，也许将来会使用。但是使用多线程在编程上会引发很多问题，例如程序运行结果不是你所期待的等等。主要的困难是跨平坦的多线程编程，其次就是资源共享和 锁的管理，再次就是并不是所有的程序都能够被转化成多线程程序。PHP 的设计主要在 2000 前后，在那个时候，多线程编程并不是很广泛和成熟，PHP 引擎开发工程师决定创造一个完全没有线程的单片机引擎（当然他们也没有 足够的能力去驾驭一个稳定的跨平台的多线程引擎）。\nPHP 用户层代码也不允许使用线程，因为那不是 PHP 期待你的代码运行的方式。PHP 是一个\u0026quot;发送并忘记(fire-and-forget)\u0026ldquo;型的语言，你应该尽可能快的处理完请求，然后释放，然后接着处理下一个请求。PHP 被设计作为一种 胶水语言：你不用处理可能使用到线程的复杂任务，而是访问快速而且已经准备好的资源，将它们粘合到一起，然后再返回给用户。通过 PHP，无论什么可能花费比通常时间多的时间的任务，都不能用 PHP 来处理。这就是为什么 在 PHP 中我们通常使用基于消息队列的系统(Gearman, AMQP, ActiveMQ 等等)来异步处理一些耗时任务。正如 Unix 看待事物的方式：“开发小而完备的工具，然后将他们连接在一起”。因此 PHP 的设计不是允许大规模的并行，而是 其他专门的技术\u0026ndash;是用正确的工具来解决特定的问题。\n线程的简介 让我们来快速的介绍下线程。注意，我们不会阐述太多细节的东西，对于你想深入了解关于线程的任何细节，都可以在相关书籍和站点上找到。\n线程是进程中的轻量的事务处理单元，注意，一个进程可以产生多个线程，一个线程必须有且只能属于一个进程。进程是操作系统中的基本工作处理单元。在多 CPU 的机器上，不同的 CPU 将会平行工作，这样对于计算能力的提升会 有很大的好处。如果进程 A 和 B 都准备被执行，而且两个 CPU（或者两个 CPU 核心）也都有空闲的负载，那么进程 A 和 B 将会同时被执行。因此，计算机将能高效的在一个单位时间内同时进行多个运算，我们称之为“并行”(parallelism)。\n进程\n线程\n进程和线程的关系 线程不是进程，线程是进程中的执行单元。也就是说，一个进程可以将它的工作划分成多个小的任务，使他们同时执行。例如：进程 A 和进程 B 都能够创造线程，分别为 A1,A2,B1,B2，如果计算机有多个 CPU（例如 8 个），那么 A1, A2, B1, B2 将会在同一个时帧运行。\n使用线程，程序员可以决定将进程任务划分成多个小的任务，使得他们能同时执行\n线程的执行跟进程几乎完全一样：他们都拥有一个状态，内核线程调度程序通过这个状态来管理它们。\n线程比进程更加轻量级，线程只需要一个栈和一些寄存器，而进程则需要更多的条件(内核虚拟机，堆，一些信号信息，一些文件描述符信息，一些锁信息等等)。\n进程的内存是由内核和内存管理单元管理，而线程的内存是由程序员自己和一些线程库来管理。\n线程的内存布局 正如我们了解的，线程拥有独立的栈，也就是说，线程访问有个函数中声明的变量时，他们访问的是他们持有的该变量的拷贝。但是我们不能用同样描述来说明进程的堆：堆在线程间是共享的，通常存放全局变量和文件描述符。 这样做有利也有弊。如果你只是读取一个全局的内存，你只需要在一个恰当的时机读取（例如在线程 X 之后，线程 Y 之前），如果你想要去写，那么你必须保证多个线程不能在同一时刻去写同一个内存空间：这样会破坏那个内存区域 让记忆体处于不可预知的状态；这种情况我们就称之为“竞争条件”，同时这也是线程编程背后所面临的主要挑战。\n对于并发访问情况的发生，你需要在你的代码中加入一些诸如可重入性和同步机制的编程技术，可重入性用来防止并发，而同步则主要是保证并发按照可预测的方式进行。\n拥有了一个很大的共享内存，就有必要去同步公共空间的访问，常用的技术有信号(semaphores)灯和互斥器(mutexes)。它们都是基于锁的概念，如果一个资源被锁定，同时有一个线程尝试访问，那么这个线程就会被阻塞，直到共享资源可以被访问。 这就是为什么使用线程并不一定就意味着你的程序能跑的更快。如果你不能有效的划分任务，或者不能有效的管理锁，程序将会比不用线程的单进程执行任务耗费更多的时间：因为线程总是在相互等待。\n如果你没有熟练使用过线程的话，使用起来确实很复杂。你需要花很多时间去练习，而且会面临很多问题，如果你漏掉了一点点细节，那么你的整个程序可能在你面前崩溃掉。调试线程程序比调试非线程程序要困难的多，假如我们正在讨论的是成百上千个线程运行到进程中的真实用例，那么你将会很快迷失自己，陷入困难之中。\n由于前面所述的那种共享内存的方式不是我们想要的，于是出现了 Thread Local Storage(TLS)。TLS 的主要原理是全局数据被线程持有，而且不能共享给其他线程，它们是一个代表全局状态的内存区域，但是对于线程而言是私有的。 要实现 LTS，在线程被创建的时候，就要申请一些进程堆内存，线程库提供一个 key，将该 key 关联到这块存储区域。每次访问这块属于特殊线程的区域，都需要使用这个特定的 key 来解锁才行。线程被销毁的时候，需要同时释放这块堆内存。\nThread libraries 正如你的猜想，操作线程需要操作系统内核的帮助。在 90 年代中期，线程出现在操作系统中，又过了很长的时间，才逐渐成熟。但是依然存在跨平台的问题，尤其是 windows 和 unix 这两大对立阵营，他们采用了不同的线程模型和不同的线程库。如今，类 unix 系统中使用的是pthread（也同时存在一些其他的 thread libraries）。Pthread 代表的是\u0026quot;Posix threads\u0026rdquo;，这是一个可以追溯到 1995 年的 POSIX 规范的实现。因此，如果你想在你的程序中使用线程，你需要通过 gcc 的-lpthread开关开连接 libpthread 到你的程序。同时 libpthread 是一个用 c 语言编写的开源程式库，它有自己独立的版本控制和管理。\n所以，通常情况下，在类 unix 系统中，我们使用pthread来进行多线程编程。需要注意的是，pthread 允许并发，但是是否平行，这个取决于操作系统和计算机本身。并发是多个线程运行在同一个 CPU 执行序，平行是多个线程在同一时刻运行在不同的 CPU 上。\n并发：\n平行：\nPHP 和多线程 让我们先回顾一下：\nPHP 不是一个多线程的语言：PHP 引擎不是通过管理线程来实现其并发机制。 PHP 不提供用户端操作线程的的方法：你不能通过原生 PHP 语言来直接操作线程。有一个由 PHP 核心开发人员 Joe Watkins 开发的 PHP 扩展：ext/pthread 提供了操作线程的方法，虽然这是一个非常棒的扩展库，但是我个人还是不推荐如此使用 PHP，毕竟对于多线程编程，PHP 并不是合适的语言，比如我就会选择 C 或者 Java。 那么，谈论 PHP 和多线程有什么意义呢？\nPHP 是如何处理请求的 这里说的其实是 PHP 是如何处理 HTTP 请求的。为了在同一时间内服务多个客户端，一个 web 伺服器程式需要一些并发（或者平行）机制。你不能因为响应一个客户端而阻塞其他所有的请求不是吗？如此以来，伺服器程式通常的做法是使用多进程，或多线程去响应客户端。从历史的角度来看，在 unix 上，使用的是多进程模型。因为进程是 unix 的基础，从 unix 诞生的时候起，进程就诞生了，而且拥有创建、销毁、和同步的能力。在 unix 环境中，多个 PHP 服务多个客户端，但是每一个 PHP 在一个独立的进程中运行。\n如果你还记得前言中介绍的，在这种情况下，PHP 代码中不需要做任何额外的事情：进程间是彼此隔离的，进程 A 处理请求 A 中的数据，不会影响到进程 B 处理请求 B 中的数据，而这正是我们想要的。\n使用这种模型的包括php-fpm和 Apache 的mpm_prefork，通常，在 98%的情形下你是用的是二者中的其中一种架构。但是，到了 windows 环境下或者在那些使用线程的 unix 系统中，事情将会变得复杂。windows 毫无质疑地是一个很优秀的操作系统，但是它有一个弊端就是它的代码不是公开的。不过幸运的是关于它内部引擎是如何工作的原理能够在互联网和一些书籍上找到，而且微软工程师也分享了很多关于 windows 核心的相关知识。在处理并发和平行的问题上，windows 选择了不同于 unix 的道路。windows 高度依赖线程，事实上，在 windows 上创建一个进程的代价是很大的以至于你通常不会这么做。在 windows 系统中，你每时每刻都在使用线程。windows 中的线程也比 unix 中强大很多。因此当你在 windows 上运行 PHP 的时候，伺服器程序（例如 IIS，Apache，FooBarBaz）会使用多线程处理不同的客户端，而不是进程。也就是说，在这样的环境下，PHP 将会运行在线程中，而且 PHP 要额外的小心线程的规则：它必须是线程安全的。\nPHP 必须是线程安全的，也就是说它必须能够控制不是由它自身创建的并发性，而且必须能够。聪明的你也许已经想到了，要解决这个问题，PHP 就要寻找一种方法，能够防止其自身访问自己的全局变量。\n于是就有了一个叫做Zend Thread Safety(ZTS)的模块，用以实现线程安全性。\nZend Thread Safety 的内部细节 开启 ZTS 可以通过使用--enable-maintainer-zts编译开关。通常情况下，你不需要打开此开关，除非是运行在 windows 系统中，或者是你需要使用一些扩展需要引擎是线程安全的时候。检查是否开启 ZTS 可以有很多方式，例如使用命令行php -v\n1liubang@venux:~$ /opt/app/php-7.1/bin/php -v 2PHP 7.1.7 (cli) (built: Jul 11 2017 10:00:35) ( NTS ) 3Copyright (c) 1997-2017 The PHP Group 你也可以使用phpinfo()来查看。在 PHP 中也可以使用检查PHP_ZTS常量来判断是否启用\n1if (PHP_ZTS) { 2\techo \u0026#34;OK\u0026#34;; 3} 在 ZTS 模式下，PHP 内核都是线程安全的，除非你使用了非线程安全的扩展。官方 PHP 扩展都是线程安全的，但是对于一些第三方的扩展，谁能保证呢？\n使用和设计可重入函数 当设计一个 PHP 扩展的时候，使用可重入函数。可重入函数是指函数不依赖任何全局状态来工作。简单来说，可重入函数的正确定义是一个函数可以在这个函数执行的任何时刻中断它。如果一个函数被平行调用于多个线程中，如果他们 使用了全局的变量或状态，那么显然它不是可重入函数。一些传统的 libc 函数不是可重入函数，因为他们诞生于一个没有线程的年代。因此一些 libc 发布了可重入版本，通常是在函数加上_r后缀。同时，最新的 C11 标准也给线程提供 了很大的空间，C11 libc 将修改函数后缀为_s.\n处于跨平台的考虑，PHP 自身也提供了这些可重入函数，可以访问源码来查看 PHP 提供的可重入函数列表。\n不要连接非线程安全的程式库 线程编程是关于整个进程镜像共享的，而进程镜像中包括一些连接的程式库。如果你的扩展连接了非线程安全的库，那么你将要采取一些措施来避免这些库访问全局资源。有些事在 C 语言和多线程语言中很常见，但是却很容易被人忘记。\n使用 ZTS 当我们开发 PHP 内核或者编写 PHP 扩展的时候，我们一定要区分两种全局变量。一种是普通的 C 语言全局变量, 叫做\u0026quot;true globals\u0026quot;，对于这种变量我们不必在多线程中做一些额外的工作，只需要正常的读取就好了，因为这种全局变量在线程创建之前就已经被 创建和初始化了。而执行这些操作的方法在内核中叫做module init，在很多 PHP 扩展里，我们都能看到形如以下的代码：\n1static int val; /* true global */ 2 3PHP_MINIT(wow_ext) 4{ 5 if (somthong()) { 6 val = 3; 7 } 8} php 扩展有很多 hook，通过 PHP 文件来触发。这个叫做MINIT()的 hook 是用来初始化 PHP 的，执行到这一步时，PHP 开始启动，我们可以在这里安全的读写 true globals，就像例子中那样。此外还有一个非常重要的 hook，叫做RINIT()， 即请求初始化，每一个 PHP 扩展的RINIT()hook 在每一个新的请求处理时都会被触发，也就是说RINIT()在一个扩展中能够被调用很多次。在RINIT()中，PHP 已经处于线程当中，所以此时的代码必须是线程安全的。无论是 C 语言的全局变量，还是线程全局变量，他们都是全局变量，都需要通过 ZTS 层来防止线程不安全的发生。\n1PHP_RINIT(wow_ext) 2{ 3 if (something()) { 4 WOW_G(val) = 3; /* writing to a thread global */ 5 } 6} 我们通过宏WOW_G()来访问线程全局变量，下面我们来探讨下这个宏背后到底发生了什么。\n宏的必要 记住，当 PHP 在多线程的环境中式运行时，所有面向请求的全局资源都必须对其访问做限制。但是当 PHP 在非线程环境下运行时，这种限制就是没有必要的，因为每个进程都有它自己的存储空间，没有共享的部分。因此访问面向请求的 全局变量的操作是区分环境的，也就是说我们需要寻找一种不区分环境的统一的表现形式来访问这些全局变量。我们使用宏就是为了解决这个问题。上面的WOW_G()宏会区分不同的多任务引擎，而且如果你改变了条件，需要重新编译 你的扩展，这就是为什么 PHP 扩展不兼容 ZTS mode 和 non-ZTS mode：因为它不是二进制兼容的。\nWOW_G()宏在多进程模式下\n1#ifdef ZTS 2#define WOW_G(v) wow_globals.v 3#endif 而在多线程环境中\n1#ifdef ZTS 2#define WOW_G(v) wow_globals.v 3#else 4#define WOW_G(v) (((wow_globals *) (*((void ***) tsrm_get_ls_cache())))[((wow_globals_id)-1)]-\u0026gt;v) 5#endif ZTS 模式是不是看上去很复杂。在多进程环境中，使用的是 NZTS(Non Zend Thread Safe)，使用全局变量会被命名为wow_globals。这是一个存放全局变量的结构体，你可以通过使用WOW_G宏来访问其中的成员。WOW_G(foo)代表wow_globals.foo。很显然，你需要去声明这样的变量，然后在启动的时候将其初始化。而这一切也可以通过宏来操作：\n1ZEND_BEGIN_MODULE_GLOBALS(wow) 2 int foo; 3ZEND_END_MODULE_GLOBALS(wow) 4 5ZEND_DECLARE_MODULE_GLOBALS(wow) 这些宏将被展开为：\n1#define ZEND_BEGIN_MODULE_GLOBALS(module_name) typedef struct _zend_##module_name##_globals { 2#define ZEND_END_MODULE_GLOBALS(module_name) } zend_##module_name##_globals; 3#define ZEND_DECLARE_MODULE_GLOBALS(module_name) zend_##module_name##_globals module_name##_globals; 上面就是在多进程模式下的实现，是不是很简单。\n但是在多线程模式下，也就是使用了 ZTS，将不会再有 C 语言中的全局变量声明，但是宏的表现形式确是一致的：\n1#define ZEND_BEGIN_MODULE_GLOBALS(module_name) typedef struct _zend_##module_name##_globals { 2#define ZEND_END_MODULE_GLOBALS(module_name) } zend_##module_name##_globals; 3#define ZEND_DECLARE_MODULE_GLOBALS(module_name) ts_rsrc_id module_name##_globals_id; 在 ZTS 和 NZTS 模式下申明全局变量看上去差异不大，但是访问的时候却有很大的差别，在 ZTS 模式下，通过调用tsrm_get_ls_cache()函数。该函数调用Thread Local Storage(TLS)，然后返回一个跟当前线程绑定的内存区域。正如 你所看到的那样，这个内存区域是非常复杂的，就凭最开始的一个(void ***)case类型装换，就能让我们嗅到它背后复杂的气息。\nTSRM layer ZTS 是通过一个叫做 TSRM 的层实现的。Thread Safe Resource Manager layer 仅仅是一些普通的 C 代码而已！它主要位于 PHP 源码中的 TSRM 目录中。即使我们将会描述它的细节，但是阅读一下源码也是一件很有意义的事情。\nTSRM 并不完美，它从 PHP5(2004)开始才大体设计完成。它可以操作一些底层的线程库：Gnu Portable Thread, Posix Threads, State Threads, Win32 Threads or BeThreads。如果你想使用 TSRM，需要在编译的时候加上--with-tsrm-xxx参数。在深入分析 TSRM 的时候我们只讲解 pthreads 的实现。\nTSRM boot 在 PHP 启动的时候，执行 module initialization 时，PHP 会迅速调用tsrm_start()。由于 PHP 现在还不知道有多少个线程需要建立线程安全保护，因此它初始化线程表的时候只存入 1 个元素。这个表随后会通过使用malloc增加元素。 这个启动操作中同样很重要的一步是同时创建 TLS 键和需要被同步的 TLS 互斥锁。\n1static pthread_key_t tls_key; 2 3TSRM_API int tsrm_startup(int expected_threads, int expected_resources, int debug_level, char *debug_filename) 4{ 5 pthread_key_create( \u0026amp;tls_key, 0 ); /* Create the key */ 6 7 tsrm_error_file = stderr; 8 tsrm_error_set(debug_level, debug_filename); 9 tsrm_tls_table_size = expected_threads; 10 11 tsrm_tls_table = (tsrm_tls_entry **) calloc(tsrm_tls_table_size, sizeof(tsrm_tls_entry *)); 12 if (!tsrm_tls_table) { 13 TSRM_ERROR((TSRM_ERROR_LEVEL_ERROR, \u0026#34;Unable to allocate TLS table\u0026#34;)); 14 return 0; 15 } 16 id_count=0; 17 18 resource_types_table_size = expected_resources; 19 resource_types_table = (tsrm_resource_type *) calloc(resource_types_table_size, sizeof(tsrm_resource_type)); 20 if (!resource_types_table) { 21 TSRM_ERROR((TSRM_ERROR_LEVEL_ERROR, \u0026#34;Unable to allocate resource types table\u0026#34;)); 22 free(tsrm_tls_table); 23 tsrm_tls_table = NULL; 24 return 0; 25 } 26 27 tsmm_mutex = tsrm_mutex_alloc(); /* Allocate a mutex */ 28} 29 30#define MUTEX_T pthread_mutex_t * 31 32TSRM_API MUTEX_T tsrm_mutex_alloc(void) 33{ 34 MUTEX_T mutexp; 35 mutexp = (pthread_mutex_t *)malloc(sizeof(pthread_mutex_t)); 36 pthread_mutex_init(mutexp,NULL); 37 return mutexp; 38} TSRM Resources 至此，TSRM 已经启动了，是时候向其中添加新资源了。一个 TSRM 资源，其实就是一个存放许多全局变量集合的内存区域，通常是给 PHP 扩展专用的，而且必须被当前特定的线程所持有，或者被限制访问。接着，这个内存区域有一个大小，而且需要有初始化(constructor)和销毁(destructor)操作。通常初始化就是用 0 将其填充，而销毁则不需要做任何事情。这样被称作 TSRM Resource 的内存区域，会被 TSRM layer 赋予一个唯一的 resource ID，调用者需要保存这样的一个 ID，以便在后续的调用中返还给 TSRM。\n下面是 TSRM 创建一个新的 resource 的实现：\n1typedef struct { 2 size_t size; 3 ts_allocate_ctor ctor; 4 ts_allocate_dtor dtor; 5 int done; 6} tsrm_resource_type; 7 8TSRM_API ts_rsrc_id ts_allocate_id(ts_rsrc_id *rsrc_id, size_t size, ts_allocate_ctor ctor, ts_allocate_dtor dtor) 9{ 10 int i; 11 12 tsrm_mutex_lock(tsmm_mutex); 13 14 /* obtain a resource id */ 15 *rsrc_id = id_count++; 16 17 /* store the new resource type in the resource sizes table */ 18 if (resource_types_table_size \u0026lt; id_count) { 19 resource_types_table = (tsrm_resource_type *) realloc(resource_types_table, sizeof(tsrm_resource_type)*id_count); 20 if (!resource_types_table) { 21 tsrm_mutex_unlock(tsmm_mutex); 22 TSRM_ERROR((TSRM_ERROR_LEVEL_ERROR, \u0026#34;Unable to allocate storage for resource\u0026#34;)); 23 *rsrc_id = 0; 24 return 0; 25 } 26 resource_types_table_size = id_count; 27 } 28 resource_types_table[(*rsrc_id)-1].size = size; 29 resource_types_table[(*rsrc_id)-1].ctor = ctor; 30 resource_types_table[(*rsrc_id)-1].dtor = dtor; 31 resource_types_table[(*rsrc_id)-1].done = 0; 32 33 /* enlarge the arrays for the already active threads */ 34 for (i=0; i \u0026lt; tsrm_tls_table_size; i++) { 35 tsrm_tls_entry *p = tsrm_tls_table[i]; 36 37 while (p) { 38 if (p-\u0026gt;count \u0026lt; id_count) { 39 int j; 40 41 p-\u0026gt;storage = (void *) realloc(p-\u0026gt;storage, sizeof(void *)*id_count); 42 for (j=p-\u0026gt;count; j\u0026lt;id_count; j++) { 43 p-\u0026gt;storage[j] = (void *) malloc(resource_types_table[j].size); 44 if (resource_types_table[j].ctor) { 45 resource_types_table[j].ctor(p-\u0026gt;storage[j]); 46 } 47 } 48 p-\u0026gt;count = id_count; 49 } 50 p = p-\u0026gt;next; 51 } 52 } 53 tsrm_mutex_unlock(tsmm_mutex); 54 55 return *rsrc_id; 56} 从上述代码中可以看到，这个函数需要一个互斥锁。如果它被一个子线程调用，那么它将会持有锁，其他线程将不能在同一时刻操作 global thread storage。新的 resource 被添加到了一个动态的resource_types_table[]数组里，然 后会生成一个唯一的标识rsrc_id，随着资源的不断增加，这个标识的值也会增长。\n在请求开始的时候 现在我们已经准备好开始处理请求了。切记，每个请求都是在特定的线程中被处理的。那么当一个请求到来的时候会发生什么呢？在每个请求最最最开始的时候，ts_resource_ex()函数会被调用。这个函数会读取当前的线程 id，接着 尝试去获取由当前线程创建的资源，也就是专属于当前线程的用来存放全局变量的内存区域。如果没有获取到（说明是一个新的线程）那么它将会像 PHP 启动的时候那样，调用allocate_new_resource()函数来为当前线程创建一个新的资源。\n1static void allocate_new_resource(tsrm_tls_entry **thread_resources_ptr, THREAD_T thread_id) 2{ 3 int i; 4 5 TSRM_ERROR((TSRM_ERROR_LEVEL_CORE, \u0026#34;Creating data structures for thread %x\u0026#34;, thread_id)); 6 (*thread_resources_ptr) = (tsrm_tls_entry *) malloc(sizeof(tsrm_tls_entry)); 7 (*thread_resources_ptr)-\u0026gt;storage = NULL; 8 if (id_count \u0026gt; 0) { 9 (*thread_resources_ptr)-\u0026gt;storage = (void **) malloc(sizeof(void *)*id_count); 10 } 11 (*thread_resources_ptr)-\u0026gt;count = id_count; 12 (*thread_resources_ptr)-\u0026gt;thread_id = thread_id; 13 (*thread_resources_ptr)-\u0026gt;next = NULL; 14 15 /* Set thread local storage to this new thread resources structure */ 16 tsrm_tls_set(*thread_resources_ptr); 17 18 if (tsrm_new_thread_begin_handler) { 19 tsrm_new_thread_begin_handler(thread_id); 20 } 21 for (i=0; i\u0026lt;id_count; i++) { 22 if (resource_types_table[i].done) { 23 (*thread_resources_ptr)-\u0026gt;storage[i] = NULL; 24 } else 25 { 26 (*thread_resources_ptr)-\u0026gt;storage[i] = (void *) malloc(resource_types_table[i].size); 27 if (resource_types_table[i].ctor) { 28 resource_types_table[i].ctor((*thread_resources_ptr)-\u0026gt;storage[i]); 29 } 30 } 31 } 32 33 if (tsrm_new_thread_end_handler) { 34 tsrm_new_thread_end_handler(thread_id); 35 } 36 37 tsrm_mutex_unlock(tsmm_mutex); 38} 扩展中的 Local Storage 缓存 在 PHP7 中，每一个扩展都会声明一个 local storage 缓存。也就是说每一个扩展需要在每一个新的线程启动的时候读取该线程的 local storage，而不是在每次访问全局变量的时候迭代 storage 列表。要完成这样的魔法，还需要额外的操作。首先你需要编译 PHP 的时候加上DZEND_ENABLE_STATIC_TSRMLS_CACHE=1参数，然后你应该用ZEND_TSRMLS_CACHE_DEFINE()宏来声明你的全局变量：\n1#define ZEND_TSRMLS_CACHE_DEFINE(); __thread void *_tsrm_ls_cache = ((void *)0); 如你所见，这里声明了一个 C 语言的全局变量，但是使用了**__thread**这个特殊的声明。这是用来告知编译器，该变量是线程特有的变量。接着你需要使用ZEND_TSRMLS_CACHE_UPDATE()宏来将 TSRM layer 中存放的全局变量填充到这个void *storage 当中。\n1PHP_GINIT_FUNCTION(my_ext) 2{ 3#ifdef ZTS 4\tZEND_TSRMLS_CACHE_UPDATE(); 5#endif 6} 下面是这个宏展开的样子：\n1#define ZEND_TSRMLS_CACHE_UPDATE() _tsrm_ls_cache = tsrm_get_ls_cache(); 针对 pthread 的实现：\n1#define tsrm_get_ls_cache() pthread_getspecific(tls_key) 至此，你应该能理解全局变量是如何通过下面的宏来访问的了：\n1#ifdef ZTS 2#define MY_G(v) (((my_globals *) (*((void ***) _tsrm_ls_cache))[((my_globals_id)-1)])-\u0026gt;(v)) 使用MY_G()宏来访问全局变量，当在多线程环境中的时候，它将会被展开未通过扩展的 id 查找_tsrm_ls_cache区域：\nmy_globals_id:\n每一个扩展都有存放它全局变量的空间，id 用于返回此扩展的存储空间。TSRM 会在一个新的请求/线程诞生的时候为当前线程创建这个存储空间。\n总结 多线程编程不是一个简单的事情。在此，我只是描述了 PHP 是如何处理全局变量的管理的：它通过引擎中特定的 TSRM layer，使用 TLS 在每个新的线程和请求启动的时候分离每一个全局存储。它持有一个互斥锁，然后为当前线程创建 存储全局变量的存储空间，然后在释放互斥锁。通过这种方式，我们可以在 PHP 扩展的任何地方访问它自己的全局变量，而不需要使用互斥锁。\nTSRMLS layer 背后的一切都是那么的抽象：这是一个用来简化全局变量管理的 C 代码层，尤其对于 PHP 扩展开发者而言，你通过一个宏来访问你的全局空间，如果你在 ZTS 环境下运行，这个宏会展开成特定的代码来访问每一个扩展中属于 你自己的一小部分，通过 TSRM 缓存，你不必在每次访问全局变量的时候去做查找操作，而是给你一个指向特定的存储空间的指针，你缓存起来，并在需要访问全局变量的时候使用它。\n当然，这些说的都是基于请求的全局变量。你可能任然在使用 C 语言的全局变量，但是不要尝试着在处理一个请求的时候去写他们：这么做即使你没有使得整个服务器崩溃，也会给企业造成巨大的损失，而且会出现很难 debug 的奇怪行为！\n","date":"October 12, 2017","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/php/2017-10-12-php%E5%92%8C%E7%BA%BF%E7%A8%8B/","series":[],"smallImg":"","tags":[{"title":"C","url":"/blog/tags/c/"},{"title":"Php","url":"/blog/tags/php/"}],"timestamp":1507766400,"title":"PHP和线程"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"Programming","url":"/blog/categories/programming/"}],"content":"在阅读优秀的 c 语言开源程式的时候，我们经常会看到各种复杂的声明，顿时会让我们怀疑人生，怀疑自己是否真的看得懂 c 语言。然而冷静三秒钟，透过现象看本质，发现牛人写的代码并不是“天书”， 也是很好懂的，关键是要冷静和耐心去阅读。\n从“中的一个例子说起 1(*(void(*)())0)() 下面我们来一步步分析：\n我们知道变量的声明方式为：\n1int a; 函数的声明方式为：\n1int fn(); 指针的声明方式为：\n1int *a = 10; 函数指针的声明方式为：\n1int (*fn)(); //fn 是一个指向返回int型的函数的指针 函数指针的调用方式：\n1typedef int (*fn_type)(); 2 3int fn() { 4 return 0; 5} 6 7fn_type a = fn; 8 9printf(\u0026#34;%d\\n\u0026#34;, a()); 10//或者 11printf(\u0026#34;%d\\n\u0026#34;, (*)a()); 最简单的类型转换：\n1void *p = 10; 2(int *)p; 在 c 语言中，去掉变量名，就是变量类型：\n1int (*fn)();//fn 是一个指向返回int型的函数的指针 2int (*)(); //表示指向返回int型的函数的指针类型 3 4// 还可以用typedef 5 6typedef int (*fn_type)(); // fn_type 就是指向返回int型的函数指针类型 回到上面的声明，我们先分析里边的部分(void(*)())0，很显然void (*)()是一个指向返回 void 类型的函数的指针类型，可以简化为typedef void (*fn_ptr)(); (fn_ptr)0， 这样写是不是一下子明了了许多，原来是把0强制类型转换成了fn_ptr类型，也就是把0转成了一个指向返回void的函数的指针类型。这样的话，原式可以等价为((* fn_ptr )0)()， 实际上就是一个先转型，后调用的过程，即先把 0 转成函数指针，然后再调用函数。\n再来看一个例子 1char *(*(*a[])())() 有了前面的基础，我相信再理解这个声明就没有那么困难了。\n首先还是从内到外来解读：\n1(*a[])() 很显然，在 c 语言中，去掉变量名就是变量类型，这里的 a 是一个指向函数的指针的数组，我们将其看做一个整体a0，那么再到外层为：\n1char *(*a0)() 这样就很显然了，a0是一个指向返回char *类型的函数的指针。\n那么综合起来解读这个声明即为：a 是一个指向 返回一个 指向返回char *类型的函数指针类型 的函数指针类型的数组。\n哈哈，是不是读起来很绕口，很多时候确实是这样的，为了便于理解，也可参考下面的代码：\n1#include \u0026lt;stdio.h\u0026gt; 2 3typedef char * (*f1_ptr)(); 4typedef f1_ptr (*f2_ptr)(); 5 6char *f1() { 7 return \u0026#34;hello\u0026#34;; 8} 9 10f1_ptr f2() { 11 return f1; 12} 13 14int main(int argc, char *argv[]) 15{ 16 char *(*(*a[1])())(); 17 a[0] = f2; 18 printf(\u0026#34;%s liubang\\n\u0026#34;, (a[0]())()); 19 return 0; 20} 此外，我们还可以借助一些很好用的开源工具来帮我们解读这些声明，而且有时候，用英文表达这些声明能更好的帮我们解：\n1liubang@venux:~$ sudo apt-get install cdecl -y 2liubang@venux:~$ cdecl 3Type `help\u0026#39; or `?\u0026#39; for help 4cdecl\u0026gt; explain char *(*(*a[])())() 5declare a as array of pointer to function returning pointer to function returning pointer to char 6cdecl\u0026gt; declare a as pointer to function returning struct tag 7struct tag (*a)() ","date":"September 12, 2017","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/sp/2017-09-12-%E7%90%86%E8%A7%A3c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%A3%B0%E6%98%8E/","series":[],"smallImg":"","tags":[{"title":"C","url":"/blog/tags/c/"},{"title":"Sp","url":"/blog/tags/sp/"}],"timestamp":1505174400,"title":"理解c语言中的声明"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"Programming","url":"/blog/categories/programming/"}],"content":" preface 在之前的文章中，我们已经实现了一些 object handlers 来将我们的 ArrayBuffer 整合到 php 中。但是美中不足的是，我们的 ArrayBufferView 并不支持迭代器操作。也就是它不能像 php 中的数组那样使用foreach来遍历。 那么，我们接下来就来看看迭代器在内核中是如何实现的，并且给我们的 ArrayBufferView 也增加一个迭代器。\nget_iterator handler 内核中的迭代器跟用户端的IteratorAggregate接口功能是一样的。一个具有迭代功能的类都有一个get_iterator处理器，它会返回一个zend_object_iterator *类型的结构，该结构定义如下（位于 phpsrc/Zend/zend_iterators.h 中）：\n1struct _zend_object_iterator { 2 void *data; 3 zend_object_iterator_funcs *funcs; 4 ulong index; /* private to fe_reset/fe_fetch opcodes */ 5}; 其中的index成员就是内核中用以实现foreach的，它的值会在每次迭代后增加。funcs成员包含了不同的迭代操作：\n1typedef struct _zend_object_iterator_funcs { 2 /* release all resources associated with this iterator instance */ 3 void (*dtor)(zend_object_iterator *iter TSRMLS_DC); 4 5 /* check for end of iteration (FAILURE or SUCCESS if data is valid) */ 6 int (*valid)(zend_object_iterator *iter TSRMLS_DC); 7 8 /* fetch the item data for the current element */ 9 void (*get_current_data)(zend_object_iterator *iter, zval ***data TSRMLS_DC); 10 11 /* fetch the key for the current element (optional, may be NULL). The key 12 * should be written into the provided zval* using the ZVAL_* macros. If 13 * this handler is not provided auto-incrementing integer keys will be 14 * used. */ 15 void (*get_current_key)(zend_object_iterator *iter, zval *key TSRMLS_DC); 16 17 /* step forwards to next element */ 18 void (*move_forward)(zend_object_iterator *iter TSRMLS_DC); 19 20 /* rewind to start of data (optional, may be NULL) */ 21 void (*rewind)(zend_object_iterator *iter TSRMLS_DC); 22 23 /* invalidate current value/key (optional, may be NULL) */ 24 void (*invalidate_current)(zend_object_iterator *iter TSRMLS_DC); 25} zend_object_iterator_funcs; 这些处理器跟Iterator接口中的抽象方法类似，只不过名字不同罢了。唯一没有对应用户端接口的是invalidate_current，它可以被用来销毁当前的key/value。 然而这个操作几乎不会被用到，通常foreach也不会取调用它。\n最后一个成员data可以用来存放一些自定义的数据。通常类似于zend_object的操作，我们需要对它的结构进行扩展。\n为了给 ArrayBufferView 添加迭代器，我们需要保存一些信息：首先我们需要有一个 buffer view 对象的引用，我们可以用data来存放该引用。其次我们还需要存储buffer_view_object， 这样可以避免我们在每种迭代操作中都要获取它。最后我们还需要存放当前元素的offset和当前元素的zval *。\n1typedef struct _buffer_view_iterator { 2\tzend_object_iterator intern; 3\tbuffer_view_object *view; 4\tsize_t offset; 5\tzval *current; 6} buffer_view_iterator; 下面我们来声明一个zend_object_iterator_funcs结构体：\n1static zend_object_iterator_funcs linger_buffer_view_iterator_funcs = { 2\tlinger_buffer_view_iterator_dtor, 3\tlinger_buffer_view_iterator_valid, 4\tlinger_buffer_view_iterator_get_current_data, 5\tlinger_buffer_view_iterator_get_current_key, 6\tlinger_buffer_view_iterator_move_forward, 7\tlinger_buffer_view_iterator_rewind 8}; 接下来我们来实现get_iterator handler。这个处理器接受一个class entry，一个object，还有一个标记迭代是否为引用，然后返回 zend_object_iterator *。我们要做的就是创建一个 iterator，并对其中的元素做初始化：\n1zend_object_iterator *linger_buffer_view_get_iterator(zend_class_entry *ce, zval *object, int by_ref TSRMLS_DC) 2{ 3\tbuffer_view_iterator *iterator; 4\tif (by_ref) { 5\tzend_throw_exception(NULL, \u0026#34;Cannot interate buffer view by refererce\u0026#34;, 0 TSRMLS_CC); 6\treturn NULL; 7\t} 8\titerator = emalloc(sizeof(buffer_view_iterator)); 9\titerator-\u0026gt;intern.funcs = \u0026amp;linger_buffer_view_iterator_funcs; 10\titerator-\u0026gt;intern.data = object; 11\tZ_ADDREF_P(object); 12 13\titerator-\u0026gt;view = zend_object_store_get_object(object TSRMLS_CC); 14\titerator-\u0026gt;offset = 0; 15\titerator-\u0026gt;current = NULL; 16\treturn (zend_object_iterator *) iterator; 17} 然后我们需要调整注册 buffer view class 的宏函数\n1#define REGISTER_ARRAY_BUFFER_VIEW_CLASS(class_name, type)\t\\ 2\tdo {\t\\ 3\tINIT_CLASS_ENTRY(ce, #class_name, linger_array_buffer_view_methods);\t\\ 4\ttype##_array_ce = zend_register_internal_class(\u0026amp;ce TSRMLS_CC); \\ 5\ttype##_array_ce-\u0026gt;create_object = linger_array_buffer_view_create_object; \\ 6\ttype##_array_ce-\u0026gt;get_iterator = linger_buffer_view_get_iterator;\t\\ 7\ttype##_array_ce-\u0026gt;iterator_funcs.funcs = \u0026amp;linger_buffer_view_iterator_funcs; \\ 8\tzend_class_implements(type##_array_ce TSRMLS_CC, 1, zend_ce_traversable); \\ 9\t} while (0) Iterator functions 1static void linger_buffer_view_iterator_dtor(zend_object_iterator *intern TSRMLS_DC) 2{ 3\tbuffer_view_iterator *iterator = (buffer_view_iterator *) intern; 4\tif (iterator-\u0026gt;current) { 5\tzval_ptr_dtor(\u0026amp;iterator-\u0026gt;current); 6\t} 7\tzval_ptr_dtor((zval **) \u0026amp;intern-\u0026gt;data); 8\tefree(iterator); 9} 10 11static int linger_buffer_view_iterator_valid(zend_object_iterator *intern TSRMLS_DC) 12{ 13\tbuffer_view_iterator *iterator = (buffer_view_iterator *)intern; 14\treturn iterator-\u0026gt;offset \u0026lt; iterator-\u0026gt;view-\u0026gt;length ? SUCCESS : FAILURE; 15} 16 17static void linger_buffer_view_iterator_get_current_data(zend_object_iterator *intern, zval ***data TSRMLS_DC) 18{ 19\tbuffer_view_iterator *iterator = (buffer_view_iterator *)intern; 20\tif (iterator-\u0026gt;current) { 21\tzval_ptr_dtor(\u0026amp;iterator-\u0026gt;current); 22\t} 23 24\tif (iterator-\u0026gt;offset \u0026lt; iterator-\u0026gt;view-\u0026gt;length) { 25\titerator-\u0026gt;current = linger_buffer_view_offset_get(iterator-\u0026gt;view, iterator-\u0026gt;offset); 26\t*data = \u0026amp;iterator-\u0026gt;current; 27\t} else { 28\t*data = NULL; 29\t} 30} 31 32static void linger_buffer_view_iterator_get_current_key(zend_object_iterator *intern, zval *key TSRMLS_DC) 33{ 34\tbuffer_view_iterator *iterator = (buffer_view_iterator *)intern; 35\tZVAL_LONG(key, iterator-\u0026gt;offset); 36} 37 38static void linger_buffer_view_iterator_move_forward(zend_object_iterator *intern TSRMLS_DC) 39{ 40\tbuffer_view_iterator *iterator = (buffer_view_iterator *)intern; 41\titerator-\u0026gt;offset++; 42} 43 44static void linger_buffer_view_iterator_rewind(zend_object_iterator *intern TSRMLS_DC) 45{ 46\tbuffer_view_iterator *iterator = (buffer_view_iterator *) iterator; 47\titerator-\u0026gt;offset = 0; 48\titerator-\u0026gt;current = NULL; 49} 代码依然平淡无奇，所以没什么好解释的。\n至此我们就完成了 ArrayBufferView 类的迭代器操作。完整代码可以访问：https://github.com/iliubang/php-ArrayBuffer.git\n","date":"August 28, 2017","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/php/2017-08-28-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8/","series":[],"smallImg":"","tags":[{"title":"C","url":"/blog/tags/c/"},{"title":"Php","url":"/blog/tags/php/"}],"timestamp":1503878400,"title":"PHP扩展开发之迭代器"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"Programming","url":"/blog/categories/programming/"}],"content":" Object Handlers 在前面的博文中，已经介绍过一些 object handlers 了，也特别介绍了如何通过指定 handlers 来创建一个自定义的结构和使用clone_obj来对自定义的结构进行克隆操作。 然而，这只是开始：在 php 中，几乎所有的对象操作，都可以通过 object handlers 来实现，而且所有的魔术方法和魔术接口在内核中都是实现了对应的 object handler。此外， 一些 handlers 并没有开放给用户端的 php，例如，内部类可以自定义类的比较操作，而使用 php 代码是无法实现的。\n由于 php 中有很多不同的 object handlers，这里只挑几个来讨论，其它的只给出简单的说明。\n概述 下面列举出 php 中主要的 26 个(php5.6 中为 28 个)object handlers（位于 phpsrc/Zend/zend_object_handlers.h），并给出简要的说明。\n1zval *read_property(zval *object, zval *member, int type, const struct _zend_literal *key TSRMLS_DC) 2void write_property(zval *object, zval *member, zval *value, const struct _zend_literal *key TSRMLS_DC) 3int has_property(zval *object, zval *member, int has_set_exists, const struct _zend_literal *key TSRMLS_DC) 4void unset_property(zval *object, zval *member, const struct _zend_literal *key TSRMLS_DC) 5zval **get_property_ptr_ptr(zval *object, zval *member, const struct _zend_literal *key TSRMLS_DC) 上述 handlers 分别表示__get，__set，__isset，__unset方法。get_property_ptr_ptr等同于__get返回一个引用类型。zend_literal *key作为这些函数的参数 起到优化作用，例如它包含了一些将属性名进行 hash 计算的结果。\n1zval *read_dimension(zval *object, zval *offset, int type TSRMLS_DC) 2void write_dimension(zval *object, zval *offset, zval *value TSRMLS_DC) 3int has_dimension(zval *object, zval *member, int check_empty TSRMLS_DC) 4void unset_dimension(zval *object, zval *offset TSRMLS_DC) 上述了几个 handlers 就是内核用以实现ArrayAccess接口的。\n1void set(zval **object, zval *value TSRMLS_DC) 2zval *get(zval *object TSRMLS_DC) 上述 handlers 用来get或set一个对象的值。他们可以用来重写（从某种程度上）像+=，++这样的符合赋值操作符，他们的存在主要是作为代理对象，但在实际应用中 缺很少被使用。\n1HashTable *get_properties(zval *object TSRMLS_DC) 2HashTable *get_debug_info(zval *object, int *is_temp TSRMLS_DC) 上述 handlers 用来获取对象的属性，并返回 hashtable。前者更加通用，例如它还被用在get_object_vars函数中。而后者唯一的作用就是在类似于var_dump这种 debug 函数中打印 属性信息。因此，即使一个对象没有提供一些正式的属性，但是它仍然能够打印一些有用的 debug 信息。\n1union _zend_function *get_method(zval **object_ptr, char *method, int method_len, const struct _zend_literal *key TSRMLS_DC) 2int call_method(const char *method, INTERNAL_FUNCTION_PARAMETERS) get_method handler 通过查找zend_function来调用一个指定的方法。如果不存在这个指定的方法，就会触发__call-like的魔术方法来捕获所有的行为，这时候get_method 就会标记当前情况为ZEND_OVERLOADED_FUNCTION，从而使得call_method被执行。\n1union _zend_function *get_constructor(zval *object TSRMLS_DC) 类似于get_method handler，但是不同的是它是专门用来获取构造函数的。覆盖此 handler 通常是为了禁止用户自定义构造函数抛出错误。\n1int count_elements(zval *object, long *count TSRMLS_DC) 这就是内核实现Countable::count方法的方式。\n1int compare_objects(zval *object1, zval *object2 TSRMLS_DC) 2int cast_object(zval *readobj, zval *retval, int type TSRMLSDC) 内部类拥有自定义比较操作的功能，而且能重写每种类型的类型转换操作。用户层的 php 类只能靠__toString()方法重写对象到 string 的类型转换操作。\n1int get_closure(zval *obj, zend_class_entry **ce_ptr, union _zend_function **fptr_ptr, zval **zobj_ptr TSRMLS_DC) 当一个对象被当做函数调用的时候，这个 handler 就会被触发执行。实际上它就是__invoke的内核实现。它的名字源于它主要是用作实现闭包。\n1zend_class_entry *get_class_entry(const zval *object TSRMLS_DC) 2int get_class_name(const zval *object, const char **class_name, zend_uint *class_name_len, int parent TSRMLS_DC) 上面两个 handler 分别用于通过一个对象获取 class_entry 和类的名字。一般情况下不会去覆盖它们。我认为唯一有必要重写它们的情况就是当你创建一个自定义结构并没有将 标准的zend_object作为其中的子结构。\n1void add_ref(zval *object TSRMLS_DC) 2void del_ref(zval *object TSRMLS_DC) 3zend_object_value clone_obj(zval *object TSRMLS_DC) 4HashTable *get_gc(zval *object, zval ***table, int *n TSRMLS_DC) 上述的操作主要用于对象维护。当一个zval开始引用一个对象的时候，add_ref将会被调用，当一个引用被移出的时候del_ref就会被调用。默认情况下，这些 handlers 会 改变 object store 中的refcount的值。同样的，它们也没有必要被重写，唯一可能的情况就是你不想使用 Zend object store，而想自定义一个。对于clone_obj，前面的文 章中已经介绍过了。get_gc会返回对象中所有的变量，所以错综复杂的依赖关系可以被适当的搜集。\n使用 object handlers 来实现 array access 正如前面一篇文章中提到的，ArrayAccess接口是用来给 array buffer views 提供类似数组的行为。那么现在，我们将通过使用对应的*_dimension object handlers 来实现同样 的功能。但是使用自定义的实现方式能够避免额外的函数调用造成的开销，从而提升性能。\n提供维度操作的 object handlers 分别为read_dimention，write_dimention，has_dimention，unset_dimention。它们都需要传递一个对象的zval作为第一个参数，offset 作为第二个参数。由于我们的实现的是一个 ArrayBuffer，所以offset一定是一个整数类型，所以我们首先来定义一个工具函数，来从一个zval中获取整数值。\n1static long get_long_from_zval(zval *offset) 2{ 3 if (Z_TYPE_P(offset) == IS_LONG) { 4 return Z_LVAL_P(offset); 5 } else { 6 zval tmp = *offset; 7 zval_copy_ctor(\u0026amp;tmp); 8 convert_to_long(\u0026amp;tmp); 9 return Z_LAVL(tmp); 10 } 11} 接下来我们来分别实现相应的 handlers。\n1static zval *linger_array_buffer_view_read_dimension(zval *object, zval *zv_offset, int type TSRMLS_DC) 2{ 3\tbuffer_view_object *intern = zend_object_store_get_object(object TSRMLS_CC); 4\tzval *retval; 5\tlong offset; 6 7\tif (intern-\u0026gt;std.ce-\u0026gt;parent) { 8\treturn zend_get_std_object_handlers()-\u0026gt;read_dimension(object, zv_offset, type TSRMLS_CC); 9\t} 10 11\tif (!zv_offset) { 12\tzend_throw_exception(NULL, \u0026#34;Cannot append to a typed array\u0026#34;, 0 TSRMLS_CC); 13\treturn NULL; 14\t} 15 16\toffset = get_long_from_zval(zv_offset); 17\tif (offset \u0026lt; 0 || offset \u0026gt;= intern-\u0026gt;length) { 18\tzend_throw_exception(NULL, \u0026#34;Offset is outside the buffer range\u0026#34;, 0 TSRMLS_CC); 19\treturn NULL; 20\t} 21 22\tretval = linger_buffer_view_offset_get(intern, offset); 23\tZ_DELREF_P(retval); 24\treturn retval; 25} 26 27static void linger_array_buffer_view_write_dimension(zval *object, zval *zv_offset, zval *value TSRMLS_DC) 28{ 29\tbuffer_view_object *intern; 30\tlong offset; 31\tintern = zend_object_store_get_object(object TSRMLS_CC); 32 33\tif (intern-\u0026gt;std.ce-\u0026gt;parent) { 34\treturn zend_get_std_object_handlers()-\u0026gt;write_dimension(object, zv_offset, value TSRMLS_CC); 35\t} 36 37\tif (!zv_offset) { 38\tzend_throw_exception(NULL, \u0026#34;Cannot append to a typed array\u0026#34;, 0 TSRMLS_CC); 39\treturn; 40\t} 41 42\toffset = get_long_from_zval(zv_offset); 43\tif (offset \u0026lt; 0 || offset \u0026gt; intern-\u0026gt;length) { 44\tzend_throw_excpetion(NULL, \u0026#34;Offset is outside the buffer range\u0026#34;, 0 TSRMLS_CC); 45\treturn; 46\t} 47 48\tlinger_buffer_view_offset_set(intern, offset, value); 49} 50 51static int linger_array_buffer_view_has_dimension(zval *object, zval *zv_offset, int check_empty TSRMLS_DC) 52{ 53\tbuffer_view_object *intern; 54\tlong offset; 55\tintern = zend_object_store_get_object(object TSRMLS_CC); 56 57\tif (intern-\u0026gt;std.ce-\u0026gt;parent) { 58\treturn zend_get_std_object_handlers()-\u0026gt;has_dimension(object, zv_offset, check_empty TSRMLS_CC); 59\t} 60 61\toffset = get_long_from_zval(zv_offset); 62\tif (offset \u0026lt; 0 || offset \u0026gt; intern-\u0026gt;length) { 63\treturn 0; 64\t} 65 66\tif (check_empty) { 67\tint retval; 68\tzval *value = linger_buffer_view_offset_get(intern, offset); 69\tretval = zend_is_true(value); 70\tzval_ptr_dtor(\u0026amp;value); 71\treturn retval; 72\t} 73 74\treturn 1; 75} 76 77static void linger_array_buffer_view_unset_dimension(zval *object, zval *zv_offset TSRMLS_DC) 78{ 79\tzend_throw_exception(NULL, \u0026#34;Cannot unset offsets in a typed array\u0026#34;, 0 TSRMLS_CC); 80} 关于以上代码的写法上没什么好解释的，但是还需要补充说明一些事情。也许细心的你看到上述代码会感到一些疑惑，为什么我们会在读操作中校验 append 呢（zv_offset == NULL）， 这个与上述代码中我们没有使用到的type参数有关。对于普通的读操作，例如$foo[0]，type的值为BP_VAR_R，但是在其他情况下，它也可能是BP_VAR_W，BP_VAR_RW，BP_VAR_IS或者BP_VAR_UNSET的一种。 为了帮助理解什么时候会产生non-read的情况，举几个例子看看：\n1$foo[0][1];\t// [0] is a read_dimension(...,BP_VAR_R), 2\t// [1] is a read_dimension(...,BP_VAR_R) 3$foo[0][1] = $bar;\t// [0] is a read_dimension(...,BP_VAR_W), [1] is a write_dimension 4$foo[][1] = $bar;\t// [] is a read_dimension(...,BP_VAR_W), [1] is a write_dimension 5isset($foo[0][1]);\t// [0] is a read_dimension(...,BP_VAR_IS), [1] is a has_dimension 6unset($foo[0][1]);\t// [0] is a read_dimension(...,BP_VAR_UNSET), [1] is a unset_dimension 正如你看到的其他嵌套维度访问的时候BP_VAR的类型，在这些情况下，只有最外层的访问会调用实际的操作处理器，而内层维度的都是通过访问相应类型的读处理器进行的。 所以如果使用[]添加操作符进行嵌套维度访问，read_dimension将会被调用，而且此时的 offset 为 NULL。正常情况下，我们需要根据上下文判断type的类型，来做出相应的操作，例如： isset操作不能抛出任何错误和异常，我们通过显示的检查BP_VAR_IS来做出操作：\n1if (type == BP_VAR_IS) { 2\treturn \u0026amp;EG(uninitialized_zval_ptr); 3} 但是在我们这个特殊的 ArrayBuffer 例子中，嵌套访问并没有实际的意义，所以不用担心这种情况。\n继承 有一种关键的情况我们不得不考虑，那就是继承。当你自定义一个类的 object handlers 后，他会沿着继承链一直生效。所以，如果一个类继承了 ArrayBufferView 中的其中某个类，那么它将会使用和父类同样的 handlers，也就是说 派生类将再也不能使用ArrayAccess。要解决这个问题并不难，一个非常简单的方法就是分别在相关 dimension handlers 中添加一个校验当前类是否为派生类，如果是的话就直接返回标准类的相关处理器。\n1if (intern-\u0026gt;std.ce-\u0026gt;parent) { 2\treturn zend_get_std_object_handlers()-\u0026gt;read_dimension(object, zv_offset, type TSRMLS_CC); 3} 自定义比较处理器 1static int linger_array_buffer_view_compare_objects(zval *obj1, zval *obj2 TSRMLS_DC) 2{ 3\tbuffer_view_object *intern1 = zend_object_store_get_object(obj1 TSRMLS_CC); 4\tbuffer_view_object *intern2 = zend_object_store_get_object(obj2 TSRMLS_CC); 5 6\tif (memcmp(intern1, intern2, sizeof(buffer_view_object)) == 0) { 7\treturn 0; 8\t} else { 9\treturn 1; 10\t} 11} 自定义 get_debug_info 1static HashTable *linger_array_buffer_view_get_debug_info(zval *obj, int *is_temp TSRMLS_DC) 2{ 3\tbuffer_view_object *intern = zend_object_store_get_object(obj TSRMLS_CC); 4\tHashTable *properties = Z_OBJPROP_P(obj); 5\tHashTable *ht; 6\tint i; 7 8\tALLOC_HASHTABLE(ht); 9\tZEND_INIT_SYMTABLE_EX(ht, intern-\u0026gt;length + zend_hash_num_elements(properties), 0); 10\tzend_hash_copy(ht, properties, (copy_ctor_func_t) zval_add_ref, NULL, sizeof(zval *)); 11 12\t*is_temp = 1; 13\tfor (i = 0; i \u0026lt; intern-\u0026gt;length; i++) { 14\tzval *value = linger_buffer_view_offset_get(intern, i); 15\tzend_hash_index_update(ht, i, (void *) \u0026amp;value, sizeof(zval *), NULL); 16\t} 17 18\treturn ht; 19} 至此，我们就对之前写的ArrayBufferView完成了改造，完整的代码可以访问https://github.com/iliubang/php-ArrayBuffer.git\n","date":"August 27, 2017","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/php/2017-08-27-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%A4%84%E7%90%86%E5%99%A8/","series":[],"smallImg":"","tags":[{"title":"C","url":"/blog/tags/c/"},{"title":"Php","url":"/blog/tags/php/"}],"timestamp":1503792000,"title":"PHP扩展开发之对象处理器(Object Handlers)"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"Programming","url":"/blog/categories/programming/"}],"content":" ArrayBuffer 简介 ArrayBuffer 又叫二进制数组，是一个用来表示通用的，固定长度的二进制数据缓冲区。你不能直接操纵 ArrayBuffer 的内容， 而是创建一个表示特定格式的 buffer 的类型化数组对象（也叫做数据视图对象）来对 buffer 的内容进行读写操作。\n我最早了解 ArrayBuffer 是从 JavaScript 开始的，具体的用法和 api 可以参考JavaScript 标准库－－ArrayBuffer\n那么接下来，我们就给 PHP 扩展一个简单的 ArrayBuffer，顺便巩固一下php 扩展开发之自定义对象的存储。\n定义 ArrayBuffer 的数据结构和相关 handlers ArrayBuffer是一个非常简单的对象，它只需要申明并存储一个buffer和它的长度即可：\n1typedef struct _buffer_object { 2 zend_object std; 3 void *buffer; 4 size_t length; 5} buffer_object; 接下来我们来实现它的create和free handlers，有了前面的基础，这个实现也是及其简单的：\n1static void linger_array_buffer_free_object_storage(buffer_object *intern TSRMLS_DC) 2{ 3\tzend_object_std_dtor(\u0026amp;intern-\u0026gt;std TSRMLS_CC); 4\tlinger_efree(intern-\u0026gt;buffer); 5} 6 7zend_object_value linger_array_buffer_create_object(zend_class_entry *class_type TSRMLS_DC) 8{ 9\tzend_object_value retval; 10\tbuffer_object *intern = emalloc(sizeof(buffer_object)); 11\tmemset(intern, 0, sizeof(buffer_object)); 12 13\tzend_object_std_init(\u0026amp;intern-\u0026gt;std, class_type TSRMLS_CC); 14\tobject_properties_init(\u0026amp;intern-\u0026gt;std, class_type); 15 16\tretval.handle = zend_objects_store_put( 17\tintern, 18\t(zend_objects_store_dtor_t) zend_objects_destroy_object, 19\t(zend_objects_free_object_storage_t) linger_array_buffer_free_object_storage, 20\tNULL 21\tTSRMLS_CC 22\t); 23 24\tretval.handlers = \u0026amp;linger_array_buffer_handlers; 25\treturn retval; 26} 从上面的代码中可以看到，我们并没有在create_object中申请buffer的空间，而这步操作将会在__construct中来实现，因为buffer的长度会作为构造函数的参数传递过来。\n1/* ArrayBuffer arginfo */ 2ZEND_BEGIN_ARG_INFO_EX(arginfo_buffer_ctor, 0, 0, 1) 3\tZEND_ARG_INFO(0, length) 4ZEND_END_ARG_INFO() 5 6PHP_METHOD(linger_ArrayBuffer, __construct) 7{ 8\tbuffer_object *intern; 9\tlong length; 10\tzend_error_handling error_handling; 11 12\tzend_replace_error_handling(EH_THROW, NULL, \u0026amp;error_handling TSRMLS_CC); 13\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \u0026#34;l\u0026#34;, \u0026amp;length) == FAILURE) { 14\tzend_restore_error_handling(\u0026amp;error_handling TSRMLS_CC); 15\treturn; 16\t} 17 18\tzend_restore_error_handling(\u0026amp;error_handling TSRMLS_CC); 19\tif (length \u0026lt; 0) { 20\tzend_throw_exception(NULL, \u0026#34;Buffer length must be positive\u0026#34;, 0 TSRMLS_CC); 21\treturn; 22\t} 23\tintern = zend_object_store_get_object(getThis() TSRMLS_CC); 24\tintern-\u0026gt;buffer = emalloc(length); 25\tintern-\u0026gt;length = length; 26 27\tmemset(intern-\u0026gt;buffer, 0, length); 28} 由于现在写的是物件导向风格的程式码，所以我们不再直接抛出error，而是通过zend_throw_exception抛exception， 它需要传递一个异常类的class entry，异常信息和错误码作为参数，如果异常类的class entry为NULL的话，就会 使用默认的Exception类抛出。\n对于__construct这样的方法尤其需要注意，当发生错误的时候抛出异常能够避免一个对象被部分构造。这就是上述代码 替换掉错误处理模式的原因。通常情况下，zend_parse_parameters在解析非法参数的情况下只会抛出一个warning，通过 将错误模式设置为EH_NORMAL可以自动将警告转换成异常抛出。\n使用zend_replace_error_handling函数可以改变错误处理模式。它的第一个参数为错误模式：EH_NORMAL、EH_SUPPRESS、EH_THROW，第二个参数为异常类的class entry，如果为NULL，则使用 默认的Exception作为异常类抛出，最后一个参数是一个指向zend_error_handling结构的指针，用以备份之前的error mode。\n除了create handler之外，我们还需要处理克隆操作。\n1static zend_object_value linger_array_buffer_clone(zval *object TSRMLS_DC) 2{ 3\tbuffer_object *old_object = zend_object_store_get_object(object TSRMLS_CC); 4\tzend_object_value new_object_val = linger_array_buffer_create_object(Z_OBJCE_P(object) TSRMLS_CC); 5\tbuffer_object *new_object = zend_object_store_get_object_by_handle(new_object_val.handle TSRMLS_CC); 6 7\tzend_objects_clone_members(\u0026amp;new_object-\u0026gt;std, new_object_val, \u0026amp;old_object-\u0026gt;std, Z_OBJ_HANDLE_P(object) TSRMLS_CC); 8 9\tnew_object-\u0026gt;buffer = old_object-\u0026gt;buffer; 10\tnew_object-\u0026gt;length = old_object-\u0026gt;length; 11 12\tif (old_object-\u0026gt;buffer) { 13\tnew_object-\u0026gt;buffer = emalloc(old_object-\u0026gt;length); 14\tmemcpy(new_object-\u0026gt;buffer, old_object-\u0026gt;buffer, old_object-\u0026gt;length); 15\t} 16\tmemcpy(new_object-\u0026gt;buffer, old_object-\u0026gt;buffer, old_object-\u0026gt;length); 17\treturn new_object_val; 18} 最后在MINIT中注册 ArrayBuffer 类：\n1PHP_MINIT_FUNCTION(linger_array_buffer) 2{ 3\tzend_class_entry ce; 4\tINIT_CLASS_ENTRY(ce, \u0026#34;Linger\\\\ArrayBuffer\u0026#34;, linger_array_buffer_methods); 5\tlinger_array_buffer_ce = zend_register_internal_class(\u0026amp;ce TSRMLS_CC); 6\tlinger_array_buffer_ce-\u0026gt;create_object = linger_array_buffer_create_object; 7\tmemcpy(\u0026amp;linger_array_buffer_handlers, zend_get_std_object_handlers(), sizeof(zend_object_handlers)); 8\tlinger_array_buffer_handlers.clone_obj = linger_array_buffer_clone; 9 10\treturn SUCCESS; 11} buffer view 下面我们来打造数据视图类。我们将要在同一个示例中实现 8 中不同的数据视图类，分别叫做Int8Array，UInt8Array， Int16Array，UInt16Array，Int32Array，UInt32Array，FloatArray，DoubleArray。首先我们在MINIT中 注册这些类：\n1/* ArrayBufferView class entry and handlers */ 2zend_class_entry *int8_array_ce; 3zend_class_entry *uint8_array_ce; 4zend_class_entry *int16_array_ce; 5zend_class_entry *uint16_array_ce; 6zend_class_entry *int32_array_ce; 7zend_class_entry *uint32_array_ce; 8zend_class_entry *float_array_ce; 9zend_class_entry *double_array_ce; 10zend_object_handlers linger_array_buffer_view_handlers; 11 12PHP_MINIT_FUNCTION(linger_array_buffer) 13{ 14\tzend_class_entry ce; 15\t// ArrayBuffer class register 16\t... 17#define REGISTER_ARRAY_BUFFER_VIEW_CLASS(class_name, type)\t\\ 18\tdo {\t\\ 19\tINIT_CLASS_ENTRY(ce, #class_name, linger_array_buffer_view_methods); \\ 20\ttype##_array_ce = zend_register_internal_class(\u0026amp;ce TSRMLS_CC); \\ 21\ttype##_array_ce-\u0026gt;create_object = linger_array_buffer_view_create_object; \\ 22\tzend_class_implements(type##_array_ce TSRMLS_CC, 1, zend_ce_arrayaccess);\\ 23\t} while (0) 24 25\tREGISTER_ARRAY_BUFFER_VIEW_CLASS(Linger\\\\ArrayBufferView\\\\Int8Array, int8); 26\tREGISTER_ARRAY_BUFFER_VIEW_CLASS(Linger\\\\ArrayBufferView\\\\UInt8Array, uint8); 27\tREGISTER_ARRAY_BUFFER_VIEW_CLASS(Linger\\\\ArrayBufferView\\\\Int16Array, int16); 28\tREGISTER_ARRAY_BUFFER_VIEW_CLASS(Linger\\\\ArrayBufferView\\\\UInt16Array, uint16); 29\tREGISTER_ARRAY_BUFFER_VIEW_CLASS(Linger\\\\ArrayBufferView\\\\Int32Array, int32); 30\tREGISTER_ARRAY_BUFFER_VIEW_CLASS(Linger\\\\ArrayBufferView\\\\UInt32Array, uint32); 31\tREGISTER_ARRAY_BUFFER_VIEW_CLASS(Linger\\\\ArrayBufferView\\\\FloatArray, float); 32\tREGISTER_ARRAY_BUFFER_VIEW_CLASS(Linger\\\\ArrayBufferView\\\\DoubleArray, double); 33 34\tmemcpy(\u0026amp;linger_array_buffer_view_handlers, zend_get_std_object_handlers(), sizeof(zend_object_handlers)); 35\tlinger_array_buffer_view_handlers.clone_obj = linger_array_buffer_view_clone; 36\treturn SUCCESS; 37} 为了避免书写大量重复类似的代码，我们定义了一个宏来简化书写，注意，在 macro 中#表示将参数作为字符串传递，而##表示连接操作。\n接下来我们来申明linger_array_buffer_view_methods：\n1const zend_function_entry linger_array_buffer_view_methods[] = { 2\tPHP_ME_MAPPING(__construct, linger_array_buffer_view_ctor, arginfo_buffer_view_ctor, ZEND_ACC_PUBLIC | ZEND_ACC_CTOR) 3\tPHP_ME_MAPPING(offsetGet, linger_array_buffer_view_offset_get, arginfo_buffer_view_offset, ZEND_ACC_PUBLIC) 4\tPHP_ME_MAPPING(offsetSet, linger_array_buffer_view_offset_set, arginfo_buffer_view_offset_set, ZEND_ACC_PUBLIC) 5\tPHP_ME_MAPPING(offsetExists, linger_array_buffer_view_offset_exists, arginfo_buffer_view_offset, ZEND_ACC_PUBLIC) 6\tPHP_ME_MAPPING(offsetUnset, linger_array_buffer_view_offset_unset, arginfo_buffer_view_offset, ZEND_ACC_PUBLIC) 7\tPHP_FE_END 8}; 这里用到了一个很新鲜的玩意儿，PHP_ME_MAPPING。通常我们在定义zend_function_entry的时候都是使用PHP_ME宏，那么 PHP_ME和PHP_ME_MAPPING的区别是什么呢，下面我们来举例说明：\n1PHP_ME(linger_ArrayBuffer_View, offsetGet, arginfo_buffer_view_offset, ZEND_ACC_PUBLIC) 2/* 会映射到 */ 3PHP_METHOD(linger_ArrayBuffer_View, offsetGet) {...} 4 5PHP_ME_MAPPING(offsetGet, linger_array_buffer_offset_get, arginfo_buffer_view_offset, ZEND_ACC_PUBLIC) 6/* 会映射到 */ 7PHP_FUNCTION(linger_array_buffer_offset_get) {...} 至此，也许你也应该意识到了PHP_FUNCTION和PHP_METHOD其实什么都没有做，他们只是定义了一些函数的名字和参数而已。 这就是为什么你可以把一个function注册成method，你也可以定义一个方法的时候使用一个名字，而注册的时候使用另一个名字。 这对于支持物件导向接口和程式 API 都是非常有用的。\n而回到我们的代码中，这里之所以选择使用PHP_ME_MAPPING是因为我们没有一个确切的ArrayBufferView类，而是一组公用方法的类。\n接下来我们来思考buffer view的数据结构该如何组织：首先需要能够区分不同的视图类，例如一些标记字段，其次它还需要存储一个 zval类型的数据来记录它所操作的ArrayBuffer对象，最后需要一个成员能够作为不同的类型用来访问ArrayBuffer中的buffer。 此外它还需要记录当前的offset和length，因为我们在创建数据视图的时候不一定会使用到整个ArrayBuffer中的buffer，例如： new linger\\ArrayBuffer\\Int32Array($buffer, 8, 10)，将会创建一个数据视图，从ArrayBuffer的偏移sizeof(int32_t) * 8bytes 的位置开始， 总共包含 24 和元素。\n下面是Array Buffer View的数据结构：\n1typedef enum _buffer_view_type { 2\tbuffer_view_int8, 3\tbuffer_view_uint8, 4\tbuffer_view_int16, 5\tbuffer_view_uint16, 6\tbuffer_view_int32, 7\tbuffer_view_uint32, 8\tbuffer_view_float, 9\tbuffer_view_double, 10} buffer_view_type; 11 12typedef struct _buffer_view_object { 13\tzend_object std; 14\tzval *buffer_zval; 15\tunion { 16\tint8_t *as_int8; 17\tuint8_t *as_uint8; 18\tint16_t *as_int16; 19\tuint16_t *as_uint16; 20\tint32_t *as_int32; 21\tuint32_t *as_uint32; 22\tfloat *as_float; 23\tdouble *as_double; 24\t} buf; 25\tsize_t offset; 26\tsize_t length; 27\tbuffer_view_type type; 28} buffer_view_object; 与ArrayBuffer类似，下面是free和create_objecthandler 的定义，由于很简单，只给出代码，不再做详细的分析：\n1static void linger_array_buffer_view_free_object_storage(buffer_view_object *intern TSRMLS_DC) 2{ 3\tzend_object_std_dtor(\u0026amp;intern-\u0026gt;std TSRMLS_CC); 4\tif (intern-\u0026gt;buffer_zval) { 5\tzval_ptr_dtor(\u0026amp;intern-\u0026gt;buffer_zval); 6\t} 7\tlinger_efree(intern); 8} 9 10zend_object_value linger_array_buffer_view_create_object(zend_class_entry *class_type TSRMLS_CC) 11{ 12\tzend_object_value retval; 13\tbuffer_view_object *intern = emalloc(sizeof(buffer_view_object)); 14\tmemset(intern, 0, sizeof(buffer_view_object)); 15 16\tzend_object_std_init(\u0026amp;intern-\u0026gt;std, class_type TSRMLS_CC); 17\tobject_properties_init(\u0026amp;intern-\u0026gt;std, class_type); 18 19\t{ 20\tzend_class_entry *base_class_type = class_type; 21\twhile (base_class_type-\u0026gt;parent) { 22\tbase_class_type = base_class_type-\u0026gt;parent; 23\t} 24 25\tif (base_class_type == int8_array_ce) { 26\tintern-\u0026gt;type = buffer_view_int8; 27\t} else if (base_class_type == uint8_array_ce) { 28\tintern-\u0026gt;type = buffer_view_uint8; 29\t} else if (base_class_type == int16_array_ce) { 30\tintern-\u0026gt;type = buffer_view_int16; 31\t} else if (base_class_type == uint16_array_ce) { 32\tintern-\u0026gt;type = buffer_view_uint16; 33\t} else if (base_class_type == int32_array_ce) { 34\tintern-\u0026gt;type = buffer_view_int32; 35\t} else if (base_class_type == uint32_array_ce) { 36\tintern-\u0026gt;type = buffer_view_uint32; 37\t} else if (base_class_type == float_array_ce) { 38\tintern-\u0026gt;type = buffer_view_float; 39\t} else if (base_class_type == double_array_ce) { 40\tintern-\u0026gt;type = buffer_view_double; 41\t} else { 42\tzend_error(E_ERROR, \u0026#34;Buffer view does not have a valid base class\u0026#34;); 43\t} 44\t} 45 46\tretval.handle = zend_objects_store_put( 47\tintern, 48\t(zend_objects_store_dtor_t) zend_objects_destroy_object, 49\t(zend_objects_free_object_storage_t) linger_array_buffer_view_free_object_storage, 50\tNULL 51\tTSRMLS_CC 52\t); 53 54\tretval.handlers = \u0026amp;linger_array_buffer_view_handlers; 55\treturn retval; 56} 但是上述代码还需要特别说明的是，在create_objecthandler 中我们额外的使用迭代来获取buffer view的基类，这是很有必要的， 因为很视图类有可能会是一个派生类。\n然后就是clonehandler 的实现：\n1static zend_object_value linger_array_buffer_view_clone(zval *object TSRMLS_DC) 2{ 3\tbuffer_view_object *old_object = zend_object_store_get_object(object TSRMLS_CC); 4\tzend_object_value new_object_val = linger_array_buffer_view_create_object(Z_OBJCE_P(object) TSRMLS_CC); 5\tbuffer_view_object *new_object = zend_object_store_get_object_by_handle(new_object_val.handle TSRMLS_CC); 6 7\tzend_objects_clone_members(\u0026amp;new_object-\u0026gt;std, new_object_val, \u0026amp;old_object-\u0026gt;std, Z_OBJ_HANDLE_P(object) TSRMLS_CC); 8 9\tnew_object-\u0026gt;buffer_zval = old_object-\u0026gt;buffer_zval; 10\tif (new_object-\u0026gt;buffer_zval) { 11\tZ_ADDREF_P(new_object-\u0026gt;buffer_zval); 12\t} 13 14\tnew_object-\u0026gt;buf.as_int8 = old_object-\u0026gt;buf.as_int8; 15\tnew_object-\u0026gt;offset = old_object-\u0026gt;offset; 16\tnew_object-\u0026gt;length = old_object-\u0026gt;length; 17\tnew_object-\u0026gt;type = old_object-\u0026gt;type; 18 19\treturn new_object_val; 20} 接下来我们来实现视图类的构造函数，代码平淡无奇：\n1PHP_FUNCTION(linger_array_buffer_view_ctor) 2{ 3\tzval *buffer_zval; 4\tlong offset = 0, length = 0; 5\tbuffer_object *buffer_intern; 6\tbuffer_view_object *view_intern; 7\tzend_error_handling error_handling; 8 9\tzend_replace_error_handling(EH_THROW, NULL, \u0026amp;error_handling TSRMLS_CC); 10\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \u0026#34;o|ll\u0026#34;, \u0026amp;buffer_zval, linger_array_buffer_ce, \u0026amp;offset, \u0026amp;length) == FAILURE) { 11\tzend_restore_error_handling(\u0026amp;error_handling TSRMLS_CC); 12\treturn; 13\t} 14 15\tzend_restore_error_handling(\u0026amp;error_handling TSRMLS_CC); 16 17\tview_intern = zend_object_store_get_object(getThis() TSRMLS_CC); 18\tbuffer_intern = zend_object_store_get_object(buffer_zval TSRMLS_CC); 19 20\tif (offset \u0026lt; 0) { 21\tzend_throw_exception(NULL, \u0026#34;Offset must be non-negative\u0026#34;, 0 TSRMLS_CC); 22\treturn; 23\t} 24\tif (offset \u0026gt;= buffer_intern-\u0026gt;length) { 25\tzend_throw_exception(NULL, \u0026#34;Offset has to be smaller than the buffer length\u0026#34;, 0 TSRMLS_CC); 26\treturn; 27\t} 28\tif (length \u0026lt; 0) { 29\tzend_throw_excpetion(NULL, \u0026#34;Length must be positive or zero\u0026#34;, 0 TSRMLS_CC); 30\treturn; 31\t} 32\tview_intern-\u0026gt;offset = offset; 33\tview_intern-\u0026gt;buffer_zval = buffer_zval; 34\tZ_ADDREF_P(buffer_zval); 35 36\t{ 37\tsize_t bytes_per_element = linger_buffer_view_get_bytes_per_element(view_intern); 38\tsize_t max_length = (buffer_intern-\u0026gt;length - offset) / bytes_per_element; 39\tif (length == 0) { 40\tview_intern-\u0026gt;length = max_length; 41\t} else if (length \u0026gt; max_length) { 42\tzend_throw_exception(NULL, \u0026#34;Length is large than the buffer\u0026#34;, 0 TSRMLS_CC); 43\treturn; 44\t} else { 45\tview_intern-\u0026gt;length = length; 46\t} 47\t} 48\tview_intern-\u0026gt;buf.as_int8 = buffer_intern-\u0026gt;buffer; 49\tview_intern-\u0026gt;buf.as_int8 += offset; 50} 构造函数中使用到了一个buffer_view_get_bytes_per_element，它是用来返回每种视图类型的基本类型占用多少字节的空间：\n1size_t linger_buffer_view_get_bytes_per_element(buffer_view_object *intern) 2{ 3\tswitch (intern-\u0026gt;type) { 4\tcase buffer_view_int8: 5\tcase buffer_view_uint8: 6\treturn 1; 7\tcase buffer_view_int16: 8\tcase buffer_view_uint16: 9\treturn 2; 10\tcase buffer_view_int32: 11\tcase buffer_view_uint32: 12\tcase buffer_view_float: 13\treturn 4; 14\tcase buffer_view_double: 15\treturn 8; 16\tdefault: 17\tzend_error_noreturn(E_ERROR, \u0026#34;Invalid buffer view type\u0026#34;); 18 19\t} 20} 在这里，需要特别说明的是，ArrayBuffer和ArrayBufferView的联系是通过union{}buf这个联合体存储，这里的用法是非常巧妙的， 由于联合体的特性，它在一个共有的空间内每次至多只存储一种数据类型，而其中存放的又是某种类型的指针（其实就是一个数组）,在构 造视图类的时候，我们将视图结构体中的 buf 的起始位置指向ArrayBuffer中的buffer的起始位置，然后在进行插入和取出的时候，充 分利用 c 语言数组和指针的特性，很巧妙的对内存区块进行读写，从而达到目的。\n到此，一切准备工作已经完成了，我们可以开始写真正的视图操作函数。\n首先实现offset set操作:\n1void linger_buffer_view_offset_set(buffer_view_object *intern, long offset, zval *value) 2{ 3\tif (intern-\u0026gt;type == buffer_view_float || intern-\u0026gt;type == buffer_view_double) { 4\tZ_ADDREF_P(value); 5\tconvert_to_double_ex(\u0026amp;value); 6\tif (intern-\u0026gt;type == buffer_view_float) { 7\tintern-\u0026gt;buf.as_float[offset] = Z_DAVL_P(value); 8\t} else { 9\tintern-\u0026gt;buf.as_double[offset] = Z_DAVL_P(value); 10\t} 11\tzval_ptr_dtor(\u0026amp;value); 12\t} else { 13\tZ_ADDREF_P(value); 14\tconvert_to_long_ex(\u0026amp;value); 15\tswitch (intern-\u0026gt;type) { 16\tcase buffer_view_int8: 17\tintern-\u0026gt;buf.as_int8[offset] = Z_LVAL_P(value); 18\tbreak; 19\tcase buffer_view_uint8: 20\tintern-\u0026gt;buf.as_uint8[offset] = Z_LVAL_P(value); 21\tbreak; 22\tcase buffer_view_int16: 23\tintern-\u0026gt;buf.as_int16[offset] = Z_LVAL_P(value); 24\tbreak; 25\tcase buffer_view_uint16: 26\tintern-\u0026gt;buf.as_uint16[offset] = Z_LVAL_P(value); 27\tbreak; 28\tcase buffer_view_int32: 29\tintern-\u0026gt;buf.as_int32[offset] = Z_LVAL_P(value); 30\tbreak; 31\tcase buffer_view_uint32: 32\tintern-\u0026gt;buf.as_uint32[offset] = Z_LVAL_P(value); 33\tbreak; 34\tdefault: 35\tzend_error(E_ERROR, \u0026#34;Invalid buffer view type\u0026#34;); 36\t} 37\tzval_ptr_dtor(\u0026amp;value); 38\t} 39} 40 41PHP_FUNCTION(linger_array_buffer_view_offset_set) 42{ 43\tbuffer_view_object *intern; 44\tlong offset; 45\tzval *value; 46\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \u0026#34;lz\u0026#34;, \u0026amp;offset, \u0026amp;value) == FAILURE) { 47\treturn; 48\t} 49\tintern = zend_object_store_get_object(getThis() TSRMLS_CC); 50\tif (offset \u0026lt; 0 || offset \u0026gt;= intern-\u0026gt;length) { 51\tzend_throw_excpetion(NULL, \u0026#34;Offset is outside the buffer range\u0026#34;, 0 TSRMLS_CC); 52\treturn; 53\t} 54\tlinger_buffer_view_offset_set(intern, offset, value); 55 56\tRETURN_TRUE; 57} 代码平淡无奇，这里就不做过多的解释，同样很简单的来实现offset get操作：\n1zval *linger_buffer_view_offset_get(buffer_view_object *intern, size_t offset) 2{ 3\tzval *retval; 4\tMAKE_STD_ZVAL(retval); 5 6\tswitch (intern-\u0026gt;type) { 7\tcase buffer_view_int8: 8\tZVAL_LONG(retval, intern-\u0026gt;buf.as_int8[offset]); 9\tbreak; 10\tcase buffer_view_uint8: 11\tZVAL_LONG(retval, intern-\u0026gt;buf.as_uint8[offset]); 12\tbreak; 13\tcase buffer_view_int16: 14\tZVAL_LONG(retval, intern-\u0026gt;buf.as_int16[offset]); 15\tbreak; 16\tcase buffer_view_uint16: 17\tZVAL_LONG(retval, intern-\u0026gt;buf.as_uint16[offset]); 18\tbreak; 19\tcase buffer_view_int32: 20\tZVAL_LONG(retval, intern-\u0026gt;buf.as_int32[offset]); 21\tbreak; 22\tcase buffer_view_uint32: { 23\tuint32_t value = intern-\u0026gt;buf.as_uint32[offset]; 24\tif (value \u0026lt;= LONG_MAX) { 25\tZVAL_LONG(retval, value); 26\t} else { 27\tZVAL_DOUBLE(retval, value); 28\t} 29\tbreak; 30\t} 31\tcase buffer_view_float: 32\tZVAL_DOUBLE(retval, intern-\u0026gt;buf.as_float[offset]); 33\tbreak; 34\tcase buffer_view_double: 35\tZVAL_DOUBLE(retval, intern-\u0026gt;buf.as_double[offset]); 36\tbreak; 37\tdefault: 38\tzend_error_noreturn(E_ERROR, \u0026#34;Invalid buffer view type\u0026#34;); 39\t} 40\treturn retval; 41} 42 43PHP_FUNCTION(linger_array_buffer_view_offset_get) 44{ 45\tbuffer_view_object *intern; 46\tlong offset; 47\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \u0026#34;l\u0026#34;, \u0026amp;offset) == FAILURE) { 48\treturn; 49\t} 50 51\tintern = zend_object_store_get_object(getThis() TSRMLS_CC); 52\tif (offset \u0026lt; 0 || offset \u0026gt;= intern-\u0026gt;length) { 53\tzend_throw_exception(NULL, \u0026#34;Offset is outside the buffer range\u0026#34;, 0 TSRMLS_CC); 54\treturn; 55\t} 56 57\tzval *retval; 58\tretval = linger_buffer_view_offset_get(intern, offset); 59\tRETURN_ZVAL(retval, 1, 1); 60} 对于剩下的offsetExists和offsetUnset这里就不再赘述了。而且这里只实现了数据的基本存取操作，并没有实现Iterator接口，不支持foreach操作， 不过会在后续的文章中实现，今天的完整代码可到 github 上查看：https://github.com/iliubang/php_ArrayBuffer_extension.git\n编译后写个测试脚本：\n1\u0026lt;?php 2 3$buffer = new linger\\ArrayBuffer(256); 4var_dump($buffer); 5 6$int32 = new linger\\ArrayBufferView\\Int32Array($buffer); 7var_dump($int32); 8$uint8 = new linger\\ArrayBufferView\\UInt8Array($buffer); 9var_dump($uint8); 10 11for ($i = 0; $i \u0026lt; 255; $i++) { 12 $uint8[$i] = $i; 13} 14 15for ($i = 0; $i \u0026lt; 255; $i++) { 16 echo $int32[$i], \u0026#34;\\n\u0026#34;; 17} 同样的代码可以用 js 测试一下：\n1var buffer = new ArrayBuffer(256); 2var uint8 = new Uint8Array(buffer); 3var int32 = new Int32Array(buffer); 4for (i = 0; i \u0026lt; 255; i++) { 5 uint8[i] = i; 6} 7for (i = 0; i \u0026lt; 255; i++) { 8 console.log(int32[i]); 9} 结果是一致的。\n","date":"August 25, 2017","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/php/2017-08-25-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E6%89%93%E9%80%A0%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84arraybuffer/","series":[],"smallImg":"","tags":[{"title":"C","url":"/blog/tags/c/"},{"title":"Php","url":"/blog/tags/php/"}],"timestamp":1503619200,"title":"PHP扩展开发之打造一个简易的ArrayBuffer"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"Programming","url":"/blog/categories/programming/"}],"content":" 前言 对于 php 扩展开发，很多人可能已经不那么陌生了，zend 引擎为了们提供了非常丰富了函数和 macro，来帮助我们很快速的创建一个标准的 php 类，然而，当我们在使用自定义的数据结构(struct)， 并想把我们自己定义的数据结构封装成 php 的类的时候可能就会有些困惑，因为我们都知道 php 中的所有变量都是通过 zval 来存储的，而我们自定义的数据结构要怎样才能和 zval 实现完美的对接呢？ 以前我通常采用的一种方式就是使用 zend 引擎提供的资源类型，因为资源类型的封装中包含了通用的数据类型，而且有很丰富的函数来操作资源，所以使用起来很简单也很方便。然而，强大的 zend 引擎真的没有其他方式扩展数据结构了吗？当然不是！下面就来介绍一个更加优雅的方式。要弄明白，首要要搞清 php 内核是如何创建对象的。\n如何创建一个对象 我们首先来探讨下如何创建一个 PHP 对象。为此我们将会用到object_and_properties_init之类的一些宏。\n1// 创建一个SomeClass类型的对象，并且把properties_hashtable中的变量作为其属性值 2zval *obj; 3MAKE_STD_ZVAL(obj); 4object_and_properties_init(obj, class_entry_of_SomeClass, properties_hashtable); 5 6// 创建一个没有属性的对象 7zval *obj; 8MAKE_STD_ZVAL(obj); 9object_init_ex(obj, class_entry_of_SomeClass); 10// = object_and_properties_init(obj, class_entry_of_SomeClass, NULL) 11 12// 创建一个stdClass的对象 13zval *obj; 14MAKE_STD_ZVAL(obj); 15object_init(obj); 16// = object_init_ex(obj, NULL) = object_and_properties_init(obj, NULL, NULL); 在上面的例子中，最后一种情况下，当你创建一个stdClass的对象后，通常将会给它添加属性。这时如果使用 zend_update_property之类的函数，是不起作用的，取而代之的是add_property宏函数：\n1add_property_long(obj, \u0026#34;id\u0026#34;, id); 2add_property_string(obj, \u0026#34;name\u0026#34;, name, 1); // 1 表示使用字符串的副本 3add_property_bool(obj, \u0026#34;isAdmin\u0026#34;, is_admin); 4// 同样有_null(), _double(), _stringl(), _resource()和_zval() 那么当一个对象被创建的时候到底发生了什么呢？想知道真相，就需要去阅读_object_and_properties_init函数的源码（位于 phpsrc/Zend/zend_API.c 中）：\n1/* This function requires \u0026#39;properties\u0026#39; to contain all props declared in the 2 * class and all props being public. If only a subset is given or the class 3 * has protected members then you need to merge the properties separately by 4 * calling zend_merge_properties(). */ 5ZEND_API int _object_and_properties_init(zval *arg, zend_class_entry *class_type, HashTable *properties ZEND_FILE_LINE_DC TSRMLS_DC) 6{ 7 zend_object *object; 8 9 if (class_type-\u0026gt;ce_flags \u0026amp; (ZEND_ACC_INTERFACE|ZEND_ACC_IMPLICIT_ABSTRACT_CLASS|ZEND_ACC_EXPLICIT_ABSTRACT_CLASS)) { 10 char *what = (class_type-\u0026gt;ce_flags \u0026amp; ZEND_ACC_INTERFACE) ? \u0026#34;interface\u0026#34; 11 :((class_type-\u0026gt;ce_flags \u0026amp; ZEND_ACC_TRAIT) == ZEND_ACC_TRAIT) ? \u0026#34;trait\u0026#34; 12 : \u0026#34;abstract class\u0026#34;; 13 zend_error(E_ERROR, \u0026#34;Cannot instantiate %s %s\u0026#34;, what, class_type-\u0026gt;name); 14 } 15 16 zend_update_class_constants(class_type TSRMLS_CC); 17 18 Z_TYPE_P(arg) = IS_OBJECT; 19 if (class_type-\u0026gt;create_object == NULL) { 20 Z_OBJVAL_P(arg) = zend_objects_new(\u0026amp;object, class_type TSRMLS_CC); 21 if (properties) { 22 object-\u0026gt;properties = properties; 23 object-\u0026gt;properties_table = NULL; 24 } else { 25 object_properties_init(object, class_type); 26 } 27 } else { 28 Z_OBJVAL_P(arg) = class_type-\u0026gt;create_object(class_type TSRMLS_CC); 29 } 30 return SUCCESS; 31} 这个函数基本上只做了三件事情：首先校验其是否能够被实例化，接着会注册 class 常量，最后也是最重要的一步操作就是 是否该类有create_object的处理函数，如果有，将会被调用，如果没有，会调用一个默认的实现zend_objects_new。\n下面是zend_objects_new的源码（位于 phpsrc/Zend/zend_objects.c 中）：\n1ZEND_API zend_object_value zend_objects_new(zend_object **object, zend_class_entry *class_type TSRMLS_DC) 2{ 3 zend_object_value retval; 4 5 *object = emalloc(sizeof(zend_object)); 6 (*object)-\u0026gt;ce = class_type; 7 (*object)-\u0026gt;properties = NULL; 8 (*object)-\u0026gt;properties_table = NULL; 9 (*object)-\u0026gt;guards = NULL; 10 retval.handle = zend_objects_store_put(*object, (zend_objects_store_dtor_t) zend_objects_destroy_object, (zend_objects_free_object_storage_t) zend_objects_free_object_sto↷ 11 retval.handlers = \u0026amp;std_object_handlers; 12 return retval; 13} 上面的代码中包含了三个很有趣的东西。一个是zend_object的结构，它的定义如下（位于 phpsrc/Zend/zend.h 中）：\n1typedef struct _zend_object { 2 zend_class_entry *ce; 3 HashTable *properties; 4 zval **properties_table; 5 HashTable *guards; /* protects from __get/__set ... recursion */ 6} zend_object; 这就是一个标准的对象的结构。zend_objects_new函数声明了一个标准的对象结构并对其进行初始化操作。然后它调用了zend_objects_store_put函数 来把对象数据存放到一个对象存储器中。对象存存储器仅仅是一个能够动态改变大小的存放zend_object_store_buckets类型数据的数组。\n下面是zend_object_store_bucket的数据结构（位于 phpsrc/Zend/zend_objects_API.h 中）\n1typedef struct _zend_object_store_bucket { 2 zend_bool destructor_called; 3 zend_bool valid; 4 zend_uchar apply_count; 5 union _store_bucket { 6 struct _store_object { 7 void *object; 8 zend_objects_store_dtor_t dtor; 9 zend_objects_free_object_storage_t free_storage; 10 zend_objects_store_clone_t clone; 11 const zend_object_handlers *handlers; 12 zend_uint refcount; 13 gc_root_buffer *buffered; 14 } obj; 15 struct { 16 int next; 17 } free_list; 18 } bucket; 19} zend_object_store_bucket; 这里的主要部分是_store_object结构，它通过void *object成员来存储对象，紧跟其后的成员分别用于是它的销毁，释放和拷贝。 接着是一些额外的成员，例如它有自己的refcount属性，因为一个存储在对象存储器中的对象可以被很多zval同时引用，php 需要 知道有多少引用以便于它是否能够被释放。此外，handlers属性和一个 GC root buffer 也被额外保存下来。\n我们回到前面的zend_objects_new函数，它的最后一部操作就是将对象的handlers设置成默认的std_object_handlers。\n重写 create_object 当你想使用自定义的对象存储时，你至少需要重复上述的三个操作：首先你需要申明并初始化你的对象，其中它需要包含一个标准的 对象作为它结构的一部分。接着你需要将它以及它的一些处理函数一起放入对象存储器中。最后你需要将你自定义的对象处理结构物 赋值给zend_object_value的handlers属性中。\n下面是一个很简单的示例：\n1#ifdef HAVE_CONFIG_H 2#include \u0026#34;config.h\u0026#34; 3#endif 4 5#include \u0026#34;php.h\u0026#34; 6#include \u0026#34;php_ini.h\u0026#34; 7#include \u0026#34;ext/standard/info.h\u0026#34; 8#include \u0026#34;php_test.h\u0026#34; 9 10static int le_test; 11 12zend_class_entry *test_ce; 13 14static zend_object_handlers test_object_handlers; 15 16typedef\tstruct _test_object { 17\tzend_object std; 18\tlong additional_property; 19} test_object; 20 21 22static void test_free_object_storage_handler(test_object *intern TSRMLS_DC) 23{ 24\tzend_object_std_dtor(\u0026amp;intern-\u0026gt;std TSRMLS_CC); 25\tefree(intern); 26} 27 28zend_object_value test_create_object_handler(zend_class_entry *class_type TSRMLS_DC) 29{ 30\tzend_object_value retval; 31\ttest_object *intern = emalloc(sizeof(test_object)); 32\tmemset(intern, 0, sizeof(test_object)); 33 34\tzend_object_std_init(\u0026amp;intern-\u0026gt;std, class_type TSRMLS_CC); 35\tobject_properties_init(\u0026amp;intern-\u0026gt;std, class_type); 36 37\tretval.handle = zend_objects_store_put( 38\tintern, 39\t(zend_objects_store_dtor_t) zend_objects_destroy_object, 40\t(zend_objects_free_object_storage_t) test_free_object_storage_handler, 41\tNULL TSRMLS_CC 42\t); 43 44\t/* Assign the customized object handlers */ 45\tretval.handlers = \u0026amp;test_object_handlers; 46\treturn retval; 47} 48 49const zend_function_entry test_methods[] = { 50\tPHP_FE_END 51}; 52 53 54/* PHP_MINIT_FUNCTION 55 */ 56PHP_MINIT_FUNCTION(test) 57{ 58\tzend_class_entry tmp_ce; 59\tINIT_CLASS_ENTRY(tmp_ce, \u0026#34;Test\u0026#34;, test_methods); 60\ttest_ce = zend_register_internal_class(\u0026amp;tmp_ce TSRMLS_CC); 61\ttest_ce-\u0026gt;create_object = test_create_object_handler; 62\tmemcpy(\u0026amp;test_object_handlers, zend_get_std_object_handlers(), sizeof(zend_object_handlers)); 63 64\treturn SUCCESS; 65} 66 67/* PHP_MSHUTDOWN_FUNCTION 68 */ 69PHP_MSHUTDOWN_FUNCTION(test) 70{ 71\treturn SUCCESS; 72} 73 74/* PHP_RINIT_FUNCTION 75 */ 76PHP_RINIT_FUNCTION(test) 77{ 78\treturn SUCCESS; 79} 80 81/* PHP_RSHUTDOWN_FUNCTION 82 */ 83PHP_RSHUTDOWN_FUNCTION(test) 84{ 85\treturn SUCCESS; 86} 87 88/* PHP_MINFO_FUNCTION 89 */ 90PHP_MINFO_FUNCTION(test) 91{ 92\tphp_info_print_table_start(); 93\tphp_info_print_table_header(2, \u0026#34;test support\u0026#34;, \u0026#34;enabled\u0026#34;); 94\tphp_info_print_table_end(); 95 96} 97 98/* test_functions[] 99 * 100 */ 101const zend_function_entry test_functions[] = { 102\tPHP_FE_END 103}; 104 105/* test_module_entry 106 */ 107zend_module_entry test_module_entry = { 108\tSTANDARD_MODULE_HEADER, 109\t\u0026#34;test\u0026#34;, 110\tNULL, 111\tPHP_MINIT(test), 112\tPHP_MSHUTDOWN(test), 113\tPHP_RINIT(test),\t/* Replace with NULL if there\u0026#39;s nothing to do at request start */ 114\tPHP_RSHUTDOWN(test),\t/* Replace with NULL if there\u0026#39;s nothing to do at request end */ 115\tPHP_MINFO(test), 116\tPHP_TEST_VERSION, 117\tSTANDARD_MODULE_PROPERTIES 118}; 119 120#ifdef COMPILE_DL_TEST 121ZEND_GET_MODULE(test) 122#endif Object store handlers 正如前面已经提到的，总共有三个 object storage handlers: 一个是用来做销毁操作，一个是用来处理释放操作，还有一个是用来处理克隆。 你一开始是不是感到有一点点的疑惑，为什么会同时存在dtor和free操作，它们看上去像是做的相同的事情。然而实际上是 php 有两个阶段 的对象销毁系统，首先会调用析构函数，然后才会释放空间。两个阶段相互分开，彼此独立。\n特别地，在脚本执行完毕，而且所有的对象还存在于内存中的时候，php 会先调用析构函数（之后会执行 RSHUTDOWN 函数），接下来会及时释放 空间，作为关闭执行器的一部分操作。销毁和释放操作独立开是很有必要的，这样能够保证在关闭操作执行的时候不会有析构函数执行，换句 话说，你可能会遇到这种情况，你的代码在一种半关闭的状态下执行。\n析构函数的另一个特性就是它不是一定会被执行，例如当执行die语句后，析构函数就会被跳过。\n因此dtor和free最本质的区别就是dtor可以执行用户端的代码，但是并不是必须执行的，而free操作却总是会被执行，而且free不必 执行任何 php 代码。这就是为什么大多数情况下，你只需要定义一个自定义的释放函数，然后使用zend_objects_destroy_object作为析构函数的原因。 而zend_objects_destroy_object只提供了一个默认的行为，那就是调用__destruct方法，如果存在的话。另外，即使你用不到__destruct方法， 你也需要给该dtor赋值，否则它的派生类也不能使用__destruct方法。\n至此，只剩下 clone handler 了，但是对于它的功能，从名字上我们很快就能理解到。但是它的用法却有一点点的复杂。下面是一个 clone handler 的示例：\n1static void test_clone_object_storage_handler(test_object *object, test_object **object_clone_target TSRMLS_DC) 2{ 3 /* Create a new object */ 4 test_object *object_clone = emalloc(sizeof(test_object)); 5 zend_object_std_init(\u0026amp;object_clone-\u0026gt;std, object-\u0026gt;std.ce TSRMLS_CC); 6 object_properties_init(\u0026amp;object_clone-\u0026gt;std, object-\u0026gt;std.ce); 7 8 object_clone-\u0026gt;additional_property = object-\u0026gt;additional_property; 9 *object_clone_target = object_clone; 10} 然后把 clone handler 传递给zend_objects_store_put函数的最后一个参数：\n1retval.handle = zend_object_store_put( 2 intern, 3 (zend_objects_store_dtor_t) zend_objects_destroy_object, 4 (zend_objects_free_object_storage_t) test_free_object_storage_handler, 5 (zend_objects_store_clone_t) test_clone_object_storage_handler 6 TSRMLS_CC 7 ); 但是这样做并不能使 clone handler 生效，默认情况下，clone handler 会被忽略。为了使他生效，你需要通过zend_objects_store_clone_obj用 默认的 clone handler 替换到自己定义的 handlers 结构：\n1memcpy(\u0026amp;test_object_handlers, zend_get_std_object_handlers(), sizeof(zend_object_handlers)); 2test_object_handler.clone_obj = zend_objects_store_clone_obj; 由于覆盖标准的 clone handler(zend_objects_clone_obj)会引发一系列的问题：由于对象的属性不会被拷贝，因此 __clone方法也不会被调用。这就是为什么大多数内部类都是直接指定自己的对象拷贝函数，而不是绕额外的弯子去 使用对象存储器的对象克隆函数。这个方法看起来有点过于样板化，它的源码如下（位于 phpsrc/Zend/zend_objects.c 中）：\n1ZEND_API zend_object_value zend_objects_clone_obj(zval *zobject TSRMLS_DC) 2{ 3 zend_object_value new_obj_val; 4 zend_object *old_object; 5 zend_object *new_object; 6 zend_object_handle handle = Z_OBJ_HANDLE_P(zobject); 7 8 /* assume that create isn\u0026#39;t overwritten, so when clone depends on the 9 * overwritten one then it must itself be overwritten */ 10 old_object = zend_objects_get_address(zobject TSRMLS_CC); 11 new_obj_val = zend_objects_new(\u0026amp;new_object, old_object-\u0026gt;ce TSRMLS_CC); 12 13 zend_objects_clone_members(new_object, new_obj_val, old_object, handle TSRMLS_CC); 14 15 return new_obj_val; 16} 这个函数首先使用zend_objects_get_address从对象存储器中获取zend_object*，然后创建一个拥有相同class_entry的对象（通过zend_objects_new）， 然后调用zend_objects_clone_members操作来克隆对象的属性，而且会调用__clone方法，如果存在的话。\n使用我们自定义的create_object handler 来取代zend_objects_new函数，将会使得我们自定义的 object clone handler 看起来简单许多：\n1static zend_object_value test_clone_handler(zval *object TSRMLS_DC) 2{ 3\ttest_object *old_object = zend_object_store_get_object(object TSRMLS_CC); 4\tzend_object_value new_object_val = test_create_object_handler(Z_OBJCE_P(object) TSRMLS_CC); 5\ttest_object *new_object = zend_object_store_get_object_by_handle(new_object_val.handle TSRMLS_CC); 6\t/* Clone properties and call __clone */ 7\tzend_objects_clone_members(\u0026amp;new_object-\u0026gt;std, new_object_val, \u0026amp;old_object-\u0026gt;std, Z_OBJ_HANDLE_P(object) TSRMLS_CC); 8 9\tnew_object-\u0026gt;additional_property = old_object-\u0026gt;additional_property; 10\treturn new_object_val; 11} 12 13/* ... */ 14//MINIT 15test_object_handler.clone_obj = test_clone_handler; 与 object store 的交互操作 通过上面的示例，已经展示过一些与 object store 交互的函数，例如：zend_objects_store_put，这是一个向 object store 中插入一个元素的操作。 同时也有三个函数用来从 object store 中获取元素。\nzend_object_store_get_object_by_handle()，顾名思义，通过给定一个对象的 handle 来获取该对象。当你已经获取到了一个对象的 handle，却没有访问到它的 zval 时，可以调用此函数。 但是在大多数情况下，你会使用zend_object_store_get_object()函数，通过给定对象的 zval 来获取它。 第三个函数是zend_objects_get_address()，该函数类似于zend_object_store_get_object()函数，但是它返回的类型是zend_object *而不是void *。所以这个函数一般很少使用，因为 c 语言允许隐式的类型转换，从void *类型转换成其他指针类型。\n以上三个函数中最重要的一个就是zend_object_store_get_object()。你将会频繁使用。下面给出一个简单的示例：\n1PHP_METHOD(Test, get) 2{ 3\tzval *object; 4\ttest_object *intern; 5\tif (zend_parse_parameters_none() == FAILURE) { 6\treturn; 7\t} 8\tobject = getThis(); 9\tintern = zend_object_store_get_object(object TSRMLS_CC); 10\tRETURN_LONG(intern-\u0026gt;additional_property); 11} 下面给出完整的示例代码：\n1/* 2 +----------------------------------------------------------------------+ 3 | Test | 4 +----------------------------------------------------------------------+ 5 | Copyright (c) 1997-2016 The PHP Group | 6 +----------------------------------------------------------------------+ 7 | This source file is subject to version 3.01 of the PHP license, | 8 | that is bundled with this package in the file LICENSE, and is | 9 | available through the world-wide-web at the following url: | 10 | http://www.php.net/license/3_01.txt | 11 | If you did not receive a copy of the PHP license and are unable to | 12 | obtain it through the world-wide-web, please send a note to | 13 | license@php.net so we can mail you a copy immediately. | 14 +----------------------------------------------------------------------+ 15 | Author: liubang \u0026lt;it.liubang@gmail.com\u0026gt; | 16 +----------------------------------------------------------------------+ 17*/ 18 19/* $Id$ */ 20 21#ifdef HAVE_CONFIG_H 22#include \u0026#34;config.h\u0026#34; 23#endif 24 25#include \u0026#34;php.h\u0026#34; 26#include \u0026#34;php_ini.h\u0026#34; 27#include \u0026#34;ext/standard/info.h\u0026#34; 28#include \u0026#34;php_test.h\u0026#34; 29 30static int le_test; 31 32zend_class_entry *test_ce; 33 34static zend_object_handlers test_object_handlers; 35 36typedef\tstruct _test_object { 37\tzend_object std; 38\tlong additional_property; 39} test_object; 40 41static void test_free_object_storage_handler(test_object *intern TSRMLS_DC) 42{ 43\tzend_object_std_dtor(\u0026amp;intern-\u0026gt;std TSRMLS_CC); 44\tefree(intern); 45} 46 47 48static void test_clone_object_storage_handler(test_object *object, test_object **object_clone_target TSRMLS_DC) 49{ 50\t/* Create a new object */ 51\ttest_object *object_clone = emalloc(sizeof(test_object)); 52\tzend_object_std_init(\u0026amp;object_clone-\u0026gt;std, object-\u0026gt;std.ce TSRMLS_CC); 53\tobject_properties_init(\u0026amp;object_clone-\u0026gt;std, object-\u0026gt;std.ce); 54 55\tobject_clone-\u0026gt;additional_property = object-\u0026gt;additional_property; 56\t*object_clone_target = object_clone; 57} 58 59zend_object_value test_create_object_handler(zend_class_entry *class_type TSRMLS_DC) 60{ 61\tzend_object_value retval; 62\ttest_object *intern = emalloc(sizeof(test_object)); 63\tmemset(intern, 0, sizeof(test_object)); 64 65\tzend_object_std_init(\u0026amp;intern-\u0026gt;std, class_type TSRMLS_CC); 66\tobject_properties_init(\u0026amp;intern-\u0026gt;std, class_type); 67 68\tretval.handle = zend_objects_store_put( 69\tintern, 70\t(zend_objects_store_dtor_t) zend_objects_destroy_object, 71\t(zend_objects_free_object_storage_t) test_free_object_storage_handler, 72\t(zend_objects_store_clone_t) test_clone_object_storage_handler 73\tTSRMLS_CC 74\t); 75 76\t/* Assign the customized object handlers */ 77\tretval.handlers = \u0026amp;test_object_handlers; 78\treturn retval; 79} 80 81static zend_object_value test_clone_handler(zval *object TSRMLS_DC) 82{ 83\ttest_object *old_object = zend_object_store_get_object(object TSRMLS_CC); 84\tzend_object_value new_object_val = test_create_object_handler(Z_OBJCE_P(object) TSRMLS_CC); 85\ttest_object *new_object = zend_object_store_get_object_by_handle(new_object_val.handle TSRMLS_CC); 86\t/* Clone properties and call __clone */ 87\tzend_objects_clone_members(\u0026amp;new_object-\u0026gt;std, new_object_val, \u0026amp;old_object-\u0026gt;std, Z_OBJ_HANDLE_P(object) TSRMLS_CC); 88 89\tnew_object-\u0026gt;additional_property = old_object-\u0026gt;additional_property; 90\treturn new_object_val; 91} 92 93PHP_METHOD(Test, set) 94{ 95\tzval *object; 96\tlong *val; 97\ttest_object *intern; 98\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \u0026#34;l\u0026#34;, \u0026amp;val) == FAILURE) { 99\tRETURN_FALSE; 100\t} 101\tobject = getThis(); 102\tintern = zend_object_store_get_object(object TSRMLS_CC); 103\tintern-\u0026gt;additional_property = val; 104\tRETURN_TRUE; 105} 106 107PHP_METHOD(Test, get) 108{ 109\tzval *object; 110\ttest_object *intern; 111\tif (zend_parse_parameters_none() == FAILURE) { 112\treturn; 113\t} 114\tobject = getThis(); 115\tintern = zend_object_store_get_object(object TSRMLS_CC); 116\tRETURN_LONG(intern-\u0026gt;additional_property); 117} 118 119const zend_function_entry test_methods[] = { 120\tPHP_ME(Test, set, NULL, ZEND_ACC_PUBLIC) 121\tPHP_ME(Test, get, NULL, ZEND_ACC_PUBLIC) 122\tPHP_FE_END 123}; 124 125 126/* PHP_MINIT_FUNCTION 127 */ 128PHP_MINIT_FUNCTION(test) 129{ 130\tzend_class_entry tmp_ce; 131\tINIT_CLASS_ENTRY(tmp_ce, \u0026#34;Test\u0026#34;, test_methods); 132\ttest_ce = zend_register_internal_class(\u0026amp;tmp_ce TSRMLS_CC); 133\ttest_ce-\u0026gt;create_object = test_create_object_handler; 134\tmemcpy(\u0026amp;test_object_handlers, zend_get_std_object_handlers(), sizeof(zend_object_handlers)); 135\ttest_object_handlers.clone_obj = test_clone_handler; 136 137\treturn SUCCESS; 138} 139 140/* PHP_MSHUTDOWN_FUNCTION 141 */ 142PHP_MSHUTDOWN_FUNCTION(test) 143{ 144\treturn SUCCESS; 145} 146 147/* PHP_RINIT_FUNCTION 148 */ 149PHP_RINIT_FUNCTION(test) 150{ 151\treturn SUCCESS; 152} 153 154/* PHP_RSHUTDOWN_FUNCTION 155 */ 156PHP_RSHUTDOWN_FUNCTION(test) 157{ 158\treturn SUCCESS; 159} 160 161/* PHP_MINFO_FUNCTION 162 */ 163PHP_MINFO_FUNCTION(test) 164{ 165\tphp_info_print_table_start(); 166\tphp_info_print_table_header(2, \u0026#34;test support\u0026#34;, \u0026#34;enabled\u0026#34;); 167\tphp_info_print_table_end(); 168 169} 170 171/* test_functions[] 172 * 173 */ 174const zend_function_entry test_functions[] = { 175\tPHP_FE_END 176}; 177 178/* test_module_entry 179 */ 180zend_module_entry test_module_entry = { 181\tSTANDARD_MODULE_HEADER, 182\t\u0026#34;test\u0026#34;, 183\tNULL, 184\tPHP_MINIT(test), 185\tPHP_MSHUTDOWN(test), 186\tPHP_RINIT(test),\t/* Replace with NULL if there\u0026#39;s nothing to do at request start */ 187\tPHP_RSHUTDOWN(test),\t/* Replace with NULL if there\u0026#39;s nothing to do at request end */ 188\tPHP_MINFO(test), 189\tPHP_TEST_VERSION, 190\tSTANDARD_MODULE_PROPERTIES 191}; 192 193#ifdef COMPILE_DL_TEST 194ZEND_GET_MODULE(test) 195#endif 测试并运行：\n1$test = new Test(); 2var_dump($test); 3$test-\u0026gt;set(123); 4var_dump($test-\u0026gt;get()); 5// output 6liubang@venux:~/workspace/c/test$ php tests/test.php 7object(Test)#1 (0) { 8} 9int(123) ","date":"August 24, 2017","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/php/2017-08-24-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%98%E5%82%A8/","series":[],"smallImg":"","tags":[{"title":"C","url":"/blog/tags/c/"},{"title":"Php","url":"/blog/tags/php/"}],"timestamp":1503532800,"title":"PHP扩展开发之自定义对象的存储"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"Programming","url":"/blog/categories/programming/"}],"content":" hashtable 哈希表又叫散列表，是实现字典操作的中有效数据结构。通常来说，一个 hash table 包含了一个数据，其中的数据通过 index 来访问。 而 hash table 的基本原理就是通过 hash 函数建立起所有可能的 index 与其对应的位置的联系。一个 hash 函数接收一个 key，返回其 hash code， key 的类型是可变的，而 hash code 是一个整型。\n由于计算一个 hash 值和通过 index 访问一个数据都是常量级的时间复杂度，所以我们可以通过这中特性实现常量级时间复杂度的查找。 如果一个 hash 函数能够保证不会有两个不同的 key 生成相同的 hash 值，那么这样的 hash table 就被称为是直接定址。然而，这只是一想法而已， 实际上这种 hash table 在现实中却是不常用的。\nChained Hash Table 链式 hash 表从本质上来讲，就是一个存放了一组链表的数组。每个链表可以看做是一个槽，我们把元素通过 hash 函数找到一个 hash 值，然后把元素的值 放入到数组中与改 hash 值对应的槽中。\nCollision Resolution 当有两个 key 被 hash 到了同一个位置，就会产生冲突。链式 hash 表有一种简单的冲突解决办法：当冲突产生时，元素被简单的放在同一个槽里。这样做可能带来的问题就是， 如果在同一个位置上出现很多冲突，这个槽就会变得越来越长，这样当我们访问这个槽中的元素的时候，所花的时间也就会越来越长。\n在理想状态下，我们希望所有的槽能够以同样的速度增长，这样他们就可以尽可能地保持小的容量和相同的大小。换句话说，我们的目标就是尽可能均匀分散所有的元素。这种情况 在理论上称为均匀散列。而实际中，我们只能尽可能近似的到达这种状态。\n如果插入表中的元素数量远大于表中槽的数量，那么即使在均匀分布的情况下，表中的槽也会变得越来越深，表的性能也会随之迅速降低。因此我们必须要特别注意一个 hash 表的负载因子， 其定义为：\n$$ \\alpha = n / m $$\n其中$n$是表中元素的个数，$m$是槽的数量。链式 hash 表的负载因子表示在均匀散列的情况下，表中每一个槽的最大期望存放的元素个数。 例如：有一个 hash 表，$m = 1699$, $n = 3198$，那么这个 hash 表的负载因子为$\\alpha = 3198/1699 = 2$。因此在这种情况下，我们说 该 hash 表中每一个槽中的元素数量最大不要超过 2。\n选择 hash 函数 一个好的 hash 函数的目标是尽可能近似于均匀散列。定义一个 hash 函数$f$，它将键$k$映射到 hash 表中的位置$x$，$x$称为$k$的 hash code：\n$$ h(k) = x $$\nDivision Method 有一个整数键$k$，有一种最简单的将$k$映射到 hash 表中槽位的方法就是取余数:\n$$ h(h) = k,mod,m $$\nMultiplication Method 与求余法不同的一种方法是乘法，它将整型键$k$乘以一个常数$A (0 \u0026lt; A \u0026lt; 1)$，取所乘结果的小数部分，然后再乘以$m$，取结果的整数部分。通常情况下，$A$取$0.618$， 它由$\\sqrt{5}$减$1$再除以$2$得到：\n$$ h(k) = \\lfloor m (kA,mod,1) \\rfloor，其中 A \\approx (\\sqrt{5} - 1) / 2 $$\n链式 hash table 的实现 基于以上理论，实现一个 hash 表已经显得非常简单了。下面直接给出代码：\n1#include \u0026lt;stdlib.h\u0026gt; 2#include \u0026lt;stdio.h\u0026gt; 3#include \u0026lt;limits.h\u0026gt; 4#include \u0026lt;string.h\u0026gt; 5 6#define linger_free(ptr) if (ptr) free(ptr) 7 8typedef struct entry_s { 9 char *key; 10 char *value; 11 struct entry_s *next; 12} entry_t; 13 14typedef struct hashtable_s { 15 int size; 16 entry_t **table; 17} hashtable_t; 18 19hashtable_t *ht_create(int size) 20{ 21 hashtable_t *hashtable = NULL; 22 int i; 23 24 if (size \u0026lt; 1) { 25 return NULL; 26 } 27 28 if ((hashtable = malloc(sizeof(hashtable_t))) == NULL) { 29 return NULL; 30 } 31 32 if ((hashtable-\u0026gt;table = malloc(sizeof(entry_t *) * size)) == NULL) { 33 linger_free(hashtable); 34 return NULL; 35 } 36 37 for (i = 0; i \u0026lt; size; i++) { 38 hashtable-\u0026gt;table[i] = NULL; 39 } 40 41 hashtable-\u0026gt;size = size; 42 return hashtable; 43} 44 45int ht_hash(hashtable_t *hashtable, char *key) 46{ 47 const char *ptr; 48 unsigned int val; 49 val = 0; 50 ptr = key; 51 while (*ptr != \u0026#39;\\0\u0026#39;) { 52 unsigned int tmp; 53 val = (val \u0026lt;\u0026lt; 4) + (*ptr); 54 if (tmp = (val \u0026amp; 0xf0000000)) { 55 val = val ^ (tmp \u0026gt;\u0026gt; 24); 56 val = val ^ tmp; 57 } 58 ptr++; 59 } 60 return val % hashtable-\u0026gt;size; 61} 62 63entry_t *ht_newpair(char *key, char *value) 64{ 65 entry_t *newpair; 66 if ((newpair = malloc(sizeof(entry_t))) == NULL) { 67 return NULL; 68 } 69 70 if ((newpair-\u0026gt;key = strdup(key)) == NULL) { 71 return NULL; 72 } 73 74 if ((newpair-\u0026gt;value = strdup(value)) == NULL) { 75 return NULL; 76 } 77 newpair-\u0026gt;next = NULL; 78 79 return newpair; 80} 81 82void ht_set(hashtable_t *hashtable, char *key, char *value) 83{ 84 int bin = 0; 85 entry_t *newpair = NULL; 86 entry_t *next = NULL; 87 entry_t *last = NULL; 88 89 bin = ht_hash(hashtable, key); 90 91 next = hashtable-\u0026gt;table[bin]; 92 93 while (next != NULL \u0026amp;\u0026amp; next-\u0026gt;key != NULL \u0026amp;\u0026amp; strcmp(key, next-\u0026gt;key) \u0026gt; 0) { 94 last = next; 95 next = next-\u0026gt;next; 96 } 97 98 if (next != NULL \u0026amp;\u0026amp; next-\u0026gt;key != NULL \u0026amp;\u0026amp; strcmp(key, next-\u0026gt;key) == 0) { 99 linger_free(next-\u0026gt;value); 100 next-\u0026gt;value = strdup(value); 101 } else { 102 newpair = ht_newpair(key, value); 103 if (next == hashtable-\u0026gt;table[bin]) { 104 newpair-\u0026gt;next = next; 105 hashtable-\u0026gt;table[bin] = newpair; 106 } else if (next == NULL) { 107 last-\u0026gt;next = newpair; 108 } else { 109 newpair-\u0026gt;next = next; 110 last-\u0026gt;next = newpair; 111 } 112 } 113} 114 115char *ht_get(hashtable_t *hashtable, char *key) 116{ 117 int bin = 0; 118 entry_t *pair; 119 bin = ht_hash(hashtable, key); 120 pair = hashtable-\u0026gt;table[bin]; 121 while (pair != NULL \u0026amp;\u0026amp; pair-\u0026gt;key != NULL \u0026amp;\u0026amp; strcmp(key, pair-\u0026gt;key) \u0026gt; 0) { 122 pair = pair-\u0026gt;next; 123 } 124 125 if (pair == NULL || pair-\u0026gt;key == NULL || strcmp(key, pair-\u0026gt;key) != 0) { 126 return NULL; 127 } 128 129 return pair-\u0026gt;value; 130} 131 132void ht_destroy(hashtable_t *hashtable) 133{ 134 entry_t *curr, *next; 135 if (hashtable-\u0026gt;size \u0026gt; 0) { 136 for (int i = 0; i \u0026lt; hashtable-\u0026gt;size; i++) { 137 if (hashtable-\u0026gt;table[i] == NULL) { 138 continue; 139 } 140 curr = hashtable-\u0026gt;table[i]; 141 while (curr != NULL) { 142 next = curr-\u0026gt;next; 143 linger_free(curr-\u0026gt;key); 144 linger_free(curr-\u0026gt;value); 145 linger_free(curr); 146 curr = next; 147 } 148 149 } 150 } 151 linger_free(hashtable); 152} 至此我们就实现了一个简单的链式 hash table。\n给 php 扩展一个 hash table 接下来我们把这个 hash table 写成 php 扩展。由于太简单，这里就不再详细讲述实现过程，源代码可以访问https://github.com/iliubang/php_hashtable_extension.git\n写了个脚本测试下性能:\n1\u0026lt;?php 2$ht = new linger\\Hashtable(65535); 3 4$n = 10000; 5 6$start = microtime(true); 7for ($i = 0; $i \u0026lt; $n; $i++) { 8 $ht-\u0026gt;set(\u0026#34;hello{$i}\u0026#34;, \u0026#34;world{$i}\u0026#34;); 9} 10 11for ($i = 0; $i \u0026lt; $n; $i++) { 12 $ht-\u0026gt;get(\u0026#34;hello{$i}\u0026#34;); 13} 14 15echo \u0026#34;HashTable:\u0026#34; . (microtime(true) - $start), PHP_EOL; 16 17$arr = []; 18 19$start = microtime(true); 20for ($i = 0; $i \u0026lt; $n; $i++) { 21 $arr[\u0026#34;hello{$i}\u0026#34;] = \u0026#34;world{$i}\u0026#34;; 22} 23 24for ($i = 0; $i \u0026lt; $n; $i++) { 25 $tmp = $arr[\u0026#34;hello{$i}\u0026#34;]; 26} 27echo \u0026#34;Array:\u0026#34; . (microtime(true) - $start), PHP_EOL; 测试结果还是很不错的：\n1liubang@venux:~/workspace/c/php-hashtable-extension/tests$ php test2.php 2HashTable:0.009289026260376 3Array:0.0061149597167969 ","date":"August 22, 2017","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/ds/2017-08-22-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8Bhashtable/","series":[],"smallImg":"","tags":[{"title":"Ds","url":"/blog/tags/ds/"},{"title":"Algorithm","url":"/blog/tags/algorithm/"}],"timestamp":1503360000,"title":"数据结构之hashtable"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"Programming","url":"/blog/categories/programming/"}],"content":" struct 在 c 语言中，结构体(struct)是一种复合数据类型，用来将一系列相同或不同类型的变量聚集在同一个内存区间内并赋予同一个名字，使得通过一个指针就能访问集合中的所有成员。结构体中可以包含许多简单或符合数据类型，因此从内存分配上看，有点类似数组，而从变量组织上看，又类似于面向对象编程语言中的类。\n定义 struct 定义一个 struct 非常简单，使用struct关键字即可。\n1struct student { 2 char *name; 3 int age; 4}; struct 的初始化 通常有四种常用的 struct 初始化方式。\n１．定义并初始化\n1struct { 2 char *ext; 3 char *filetype; 4} extensions[] = { 5 {\u0026#34;gif\u0026#34;, \u0026#34;image/gif\u0026#34;}, 6 {\u0026#34;jpg\u0026#34;, \u0026#34;image/jpg\u0026#34;} 7}; ２．按照成员声明的顺序初始化\n1struct Person { 2 char *name; 3 int age; 4}; 5 6struct Person zhangsan = {\u0026#34;张三\u0026#34;, 24}; 本质上，这种方式跟第一种是一样的。\n３．指定初始化，成员顺序可以不定，Linux Kernel 中多采用这种方式。\n1struct Student { 2 char c; 3 int score; 4 const char *name; 5}; 6 7struct Student zhangsan = { 8 .name = \u0026#34;张三\u0026#34;, 9 .c = \u0026#39;B\u0026#39;, 10 .score = 92, 11}; ４．指定初始化，成员顺序可以不定。\n1struct Student { 2 char c; 3 int score; 4 const char *name; 5}; 6 7struct Student zhangsan = { 8 c: \u0026#39;C\u0026#39;, 9 score: 93, 10 name: \u0026#34;张三\u0026#34;, 11}; structure member alignment, padding and data packing. 首先我们来看看以下程序的结果\n1#include \u0026lt;stdio.h\u0026gt; 2 3typedef struct structa_tag { 4 char c; 5 short int s; 6} structa_t; 7 8typedef struct structb_tag { 9 short int s; 10 char c; 11 int i; 12} structb_t; 13 14typedef struct structc_tag { 15 char c; 16 double d; 17 int s; 18} structc_t; 19 20typedef struct structd_tag { 21 double d; 22 char c; 23 int s; 24} structd_t; 25 26 27int main(int argc, char *argv[]) 28{ 29 printf(\u0026#34;sizeof(structa_t) = %d\\n\u0026#34;, sizeof(structa_t)); 30 printf(\u0026#34;sizeof(structb_t) = %d\\n\u0026#34;, sizeof(structb_t)); 31 printf(\u0026#34;sizeof(structc_t) = %d\\n\u0026#34;, sizeof(structc_t)); 32 printf(\u0026#34;sizeof(structd_t) = %d\\n\u0026#34;, sizeof(structd_t)); 33 return 0; 34} 在执行程序之前，不妨分析下运行的结果。\ndata alignment 许多实际意义的计算机对基本类型数据在内存中存放的位置有限制，他们会要求这些地址的起始地址的值是某个数 k 的倍数，这就是所谓的内存对齐，而这个 k 则被称为改数据类型的对齐模数(alignment modulus)。这种强制的要求一来是简化了处理器与内存之间传输系统的涉及，二来可以提升读取数据的速度。\n比如有这么一种处理器，它每次读写内存的时候都从某个 8 倍数地址开始，那么读或写一个 double 类型数据就只需要一次内存操作。否则，我们就可能需要两次内存操作才能完成这个动作，因为数据或许恰好横跨在两个符合对齐要求的 8 字节内存块上。\n对齐的原则 数据类型自身对齐: char 类型自身对齐为 1 字节，short 类型为 2 字节，int/float 为 4 字节，double 为 8 字节 结构体或类的自身对齐：其成员中自身对齐值最大的那个值 指定对齐：#pragma pack(value)指定对齐的 value 数据成员，结构体和类的有效对齐值：自身对齐值和指定对齐值中较小者，即有效对齐值=min{自身对齐值，当前指定的 pack 值} 基于以上说明，我们来分析下上例程序的运行结果：\n对于structa_tag, char占１个字节，short int占 2 个字节，假如short int紧跟着char之后来分配内存，那么它将会以一个奇数边界开始。所以，计算机会在char之后填充 1 字节来保证short int起始地址从 2 的倍数开始。所以stracta_t的总大小为：sizeof(char) + 1(padding) + sizeof(short)，也就是 1 + 1 + 2 = 4 bytes.\n对于structb_tag，sizeof(structb_t) = sizeof(short) + sizeof(char) + 1 (padding) + sizeof(int)，即 2 + 1 + 1 + 4 = 8 bytes.\n对于structc_tag，由于double为 8 字节对齐，所以在char后需要填充 7 字节，通常我们以为这样就够了，sizeof(char) + 7 (padding) + sizeof(double) + sizeof(int)，1 + 7 + 8 + 4 = 20 bytes。然而实际上并不是这样的结果，因为虽然前述内容看上去满足了基本数据类型的自身对齐，但是对于结构体这种复合数据类型，作为一个整体也需要满足对齐，根据 对齐原则，结构体或类的自身对齐，是以成员中自身对齐最大的那个值，也就是structc_t自身对齐的值为 8，所以在int后还有４个字节的填充，sizeof(char) + 7 (padding) + sizeof(double) + sizeof(int) + 4 (padding), 1 + 7 + 8 + 4 + 4 = 24 bytes。\n对于structd_tag，对于这个的分析就简单多了，这里就不再赘述，结果显而易见，sizeof(double) + sizeof(char) + 1 (padding) + sizeof(int) + 2 (padding)，8 + 1 + 1 + 4 + 2 = 16 bytes。\npacking #pragma pack(n)手动指定对齐数值。但是并不是指定后一定就能生效，因为根据对齐原则，有效对齐值=min{自身对齐值，当前指定的 pack 值}\n在 linux 中，使用 gcc 编译器时候可以使用 gcc 特有的语法来强制指定对齐数值，__attribute__((aligned (n)))\n1#include \u0026lt;stdio.h\u0026gt; 2 3typedef struct A A; 4 5struct A { 6 char c[3]; 7} __attribute__((aligned (4))); 8 9int main(int argc, char *argv[]) 10{ 11 printf(\u0026#34;sizeof(A) = %d\\n\u0026#34;, sizeof(A)); 12 return 0; 13} 14 15// will output 4 这种写法在 linux kernel 中非常常见，例如著名的rbtree中有如下声明:\n1struct rb_node { 2\tunsigned long __rb_parent_color; 3\tstruct rb_node *rb_right; 4\tstruct rb_node *rb_left; 5} __attribute__((aligned(sizeof(long)))); 6 /* The alignment might seem pointless, but allegedly CRIS needs it */ 关于__attribute__的其它用法，可以参考以下文章:\nhttp://unixwiz.net/techtips/gnu-c-attributes.html http://www.keil.com/support/man/docs/armcc/armcc_chr1359124973480.htm 位域(bit field) 有些数据在存储时不需要占用一个完整的字节，只需要占用一个或几个二进制位。例如记录开关状态的变量，用0和1表示，也就是一个二进制位就能满足。正式基于这种考虑，c 语言又提供了一种叫做位域的数据结构。 c 标准允许unsigned int/signed int/int类型的位域声明，c99 中加入了_Bool类型的位域。但像 GCC 这样的编译器自行加入了一些扩展，比如支持short，char等整形类型的位域字段。\n以下是 c 语言中 bit field 的一般形式\n1#include \u0026lt;stdio.h\u0026gt; 2 3int main(int argc, char *argv[]) 4{ 5 struct A { 6 unsigned short s1 : 1, 7 s2 : 2, 8 s3 : 3, 9 ......, 10 sn : k; 11 }; 12 return 0; 13} 要特别注意的是，bit field 是基于二进制位的一种结构，而不是基于字节(byte).\nbit field 的出现，让我们可以通过变量名代表某些 bit，并通过变量名直接获得和设置一些内存中 bit 的值，而不是通过晦涩难以理解的位操作来进行。例如：\n1#include \u0026lt;stdio.h\u0026gt; 2 3int main(int argc, char *argv[]) 4{ 5 struct foo_t { 6 unsigned int a : 3, 7 b : 2, 8 c : 4; 9 }; 10 11 struct foo_t f; 12 f.a = 3; 13 f.b = 1; 14 f.c = 12; 15 return 0; 16} 另外，使用 bit field 可以在展现和存储相同信息时，自定义更加紧凑的内存布局，节约内存的使用量。这使得 bit field 在嵌入式领域，在驱动程序领域得到广泛的应用。比如可以仅用两个字节就可以将 tcpheader 从 dataoffset 到 fin 的信息全部表示和存储起来：\n1#include \u0026lt;stdio.h\u0026gt; 2 3int main(int argc, char *argv[]) 4{ 5 struct tcphdr { 6 __u16 doff : 4, 7 res1 : 4, 8 cwr : 1, 9 ece : 1, 10 urg : 1, 11 ack : 1, 12 psh : 1, 13 rst : 1, 14 syn : 1, 15 fin : 1; 16 }; 17 return 0; 18} 注意：在 c 语言中，尝试获得一个 bit field 的地址是非法操作。\n1#include \u0026lt;stdio.h\u0026gt; 2 3int main(int argc, char *argv[]) 4{ 5 struct flag_t { 6 int a : 1; 7 }; 8 9 struct flag_t f; 10 printf(\u0026#34;%p\\n\u0026#34;, \u0026amp;f.a); 11 return 0; 12} 13 14//compile output 15liubang@venux:~/workspace/c/learn/02$ gcc demo5.c -o demo5 16demo5.c: In function ‘main’: 17demo5.c:10:20: error: cannot take address of bit-field ‘a’ 18 printf(\u0026#34;%p\\n\u0026#34;, \u0026amp;f.a); 19 ^ 匿名位域 顾名思义，匿名位域就是位域成员没有名称，只给出了数据类型和位宽，如下所示：\n1#include \u0026lt;stdio.h\u0026gt; 2 3int main(int argc, char *argv[]) 4{ 5 struct bs { 6 int m : 12; 7 int : 20; 8 int n : 4; 9 }; 10 return 0; 11} 匿名位域一般用来填充或者调整成员的位置。因为没有名称，所以匿名位域不能使用。\n","date":"August 21, 2017","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/sp/2017-08-21-c%E8%AF%AD%E8%A8%80%E4%B9%8Bstruct/","series":[],"smallImg":"","tags":[{"title":"C","url":"/blog/tags/c/"}],"timestamp":1503273600,"title":"c语言之struct"},{"authors":[],"categories":[{"title":"Programming","url":"/blog/categories/programming/"}],"content":" 1、JNI 基础 JNI 中定义了一下类型来对应到相应的 Java 的数据类型:\n1. Java 基本数据类型: jint,jbyte,jshort,jlong,jfloat,jdouble,jchar,jboolean分别对应 Java 中的int,byte,short,long,float,double,char和boolean。\n2. Java 引用类型： jobject对应java.lang.object。同时也定义了下列子类型：\njclass对应java.lang.Class jstring对应java.lang.String jthrowable对应java.lang.Throwable jarray对应 Java 中的数组。Java 中的数组由 8 种基本数据类型和一个Object类型派生二来，所以 JNI 中也存在jintArray,jbyteArray,jshortArray,jlongArray,jfloatArray,jdoubleArray, jcharArray,jbooleanArray和jobjectArray native 函数接收和返回上述的 JNI 类型数据。如果 native 函数需要操作它自己的数据类型(如 c 语言中的 int, char *)，那么就需要在 JNI 类型和本地类型之间做相应的转换。\n简而言之，native 函数的编写流程大致为：\n通过 Java 程序接收 JNI 类型的参数 将接收的 JNI 类型转换成本地类型 完成相应的操作 创建一个需要返回的 JNI 类型的对象，然后将返回的数据 copy 到要返回的对象中 返回 从上述流程可以看出，编写 JNI 程序主要的挑战在于数据类型之间的转换，然而 JNI 中提供了很多转换函数来帮助我们完成相应的操作。\nJNI 是一个 c 语言的接口，c 语言并不支持 OOP 的特性(严格的说，OOP 是一种理念，这里只是从语言本身来说 c 语言不支持面向对象，实际上用 c 语言也可以写出面向对象风格的程序！)，所以他们之间并不是真的通过对象来传递。\n2、在 Java 程序和 native 程序之间传递参数 2.1 传递基本类型 传递 Java 中的基本数据类型是非常简单的。一个jxxx类型被定义在 native 环境中，直接对应着 Java 中xxx基本类型。\n1public class TestAdd { 2\tstatic { 3\tSystem.loadLibrary(\u0026#34;myadd\u0026#34;); 4\t} 5 6\tprivate native double add(int a, int b); 7 8\tpublic static void main(String[] args) { 9\tSystem.out.println(\u0026#34;In Java, the summary is \u0026#34; + new TestAdd().add(3, 2)); 10\t} 11} 编译 Java 并生成 C/C++头文件\n1javac TestAdd.java 2javah TestAdd 实现 C 代码\n1#include \u0026lt;stdio.h\u0026gt; 2#include \u0026lt;jni.h\u0026gt; 3#include \u0026#34;TestAdd.h\u0026#34; 4 5JNIEXPORT jdouble JNICALL Java_TestAdd_add (JNIEnv *env, jobject this, jint a, jint b) { 6\tjint\tresult; 7\tprintf(\u0026#34;In c, the numbers are %d and %d\\n\u0026#34;, a, b); 8\tresult = (jint)(a + b); 9\treturn result; 10} 将 C 代码编译成动态链接库\n1gcc -fPIC -shared -I /opt/app/java/include/ -I /opt/app/java/include/linux/ TestAdd.c -o libmyadd.so 运行 Java 程序\n1java -Djava.library.path=. TestAdd 2 3====output==== 4ubuntu@vm-911:~/workspace/java/jni/demo2$ java -Djava.library.path=. TestAdd 5In c, the numbers are 3 and 2 6In Java, the summary is 5.0 上面的例子是传递整型类型的情况，比较简单，不需要做转换处理，那么下面我们来看看传递字符串类型的情况。\n2.2 传递 String 由于编译方式几乎每次都一样，所以接下来的例子只呈现代码，不再描述具体的编译操作，如果有问题请阅读 Java Native Interface（一）。\n1public class TestJNIString { 2 static { 3 System.loadLibrary(\u0026#34;myjnistring\u0026#34;); 4 } 5 6 private native String say(String msg); 7 8 public static void main(String[] args) { 9 String result = new TestJNIString().say(\u0026#34;hello liubang\u0026#34;); 10 System.out.println(\u0026#34;In Java, the result is \u0026#34; + result); 11 } 12} 实现 C 逻辑\n1#include \u0026lt;stdio.h\u0026gt; 2#include \u0026lt;jni.h\u0026gt; 3#include \u0026#34;TestJNIString.h\u0026#34; 4 5JNIEXPORT jstring JNICALL Java_TestJNIString_say(JNIEnv *env, jobject this, jstring msg) { 6 const char *cString = (*env)-\u0026gt;GetStringUTFChars(env, msg, NULL); 7 if (NULL == cString) { 8 return NULL; 9 } 10 11 printf(\u0026#34;In c, the received string is %s\\n\u0026#34;, cString); 12 (*env)-\u0026gt;ReleaseStringUTFChars(env, msg, cString); 13 14 char outPut[128]; 15 printf(\u0026#34;Enter a String: \u0026#34;); 16 scanf(\u0026#34;%s\u0026#34;, outPut); 17 18 return (*env)-\u0026gt;NewStringUTF(env, outPut); 19} 由于上述代码太简单，所以这里不做具体的解释，关于相关函数的原型，可以在jni.h头文件中找到定义。\n测试结果如下：\n1ubuntu@vm-911:~/workspace/java/jni/demo2$ java -Djava.library.path=. TestJNIString 2In c, the received string is hello liubang 3Enter a String: liubang 4In Java, the result is liubang 2.3 传递数组 TestJNIArray.java\n1public class TestJNIArray { 2 static { 3 System.loadLibrary(\u0026#34;myjniarray\u0026#34;); 4 } 5 6 private native double[] avg(int[] numbers); 7 8 public static void main(String[] args) { 9 int[] numbers = {12, 25, 8}; 10 double[] results = new TestJNIArray().avg(numbers); 11 System.out.println(\u0026#34;In Java the sum is \u0026#34; + results[0]); 12 System.out.println(\u0026#34;In java the avg is \u0026#34; + results[1]); 13 } 14} TestJNIArray.c\n1#include \u0026lt;jni.h\u0026gt; 2#include \u0026#34;TestJNIArray.h\u0026#34; 3 4JNIEXPORT jdoubleArray JNICALL Java_TestJNIArray_avg(JNIEnv *env, jobject this, jintArray jniarray) { 5 jint *cArray = (*env)-\u0026gt;GetIntArrayElements(env, jniarray, NULL); 6 if (NULL == cArray) 7 return NULL; 8 9 jsize length = (*env)-\u0026gt;GetArrayLength(env, jniarray); 10 jint sum = 0; 11 int i; 12 for (i = 0; i \u0026lt; length; i++) { 13 sum += cArray[i]; 14 } 15 jdouble avg = (jdouble)sum / length; 16 (*env)-\u0026gt;ReleaseIntArrayElements(env, jniarray, cArray, 0); 17 18 jdouble output[] = {sum, avg}; 19 jdoubleArray outJNIArray = (*env)-\u0026gt;NewDoubleArray(env, 2); 20 if (NULL == outJNIArray) 21 return NULL; 22 23 (*env)-\u0026gt;SetDoubleArrayRegion(env, outJNIArray, 0, 2, output); 24 return outJNIArray; 25} 运行结果为：\n1ubuntu@vm-911:~/workspace/java/jni/demo2$ java -Djava.library.path=. TestJNIArray 2In Java the sum is 45.0 3In java the avg is 15.0 3、访问对象的成员变量和回调函数 3.1 访问成员变量 TestObjVariable.java\n1public class TestObjVariable { 2 static { 3 System.loadLibrary(\u0026#34;libmytestobjvariable\u0026#34;); 4 } 5 6 private String name = \u0026#34;liubang\u0026#34;; 7 private int age = 24; 8 9 private native void setNameAndAge(); 10 11 public static void main(String[] args) { 12 TestObjVariable test = new TestObjVariable(); 13 test.setNameAndAge(); 14 System.out.println(\u0026#34;My name is \u0026#34; + test.name + \u0026#34; and I am \u0026#34; + test.age + \u0026#34; years old\u0026#34;); 15 } 16} C 语言中的实现：\nTestObjVariable.c\n1#include \u0026lt;stdio.h\u0026gt; 2#include \u0026lt;jni.h\u0026gt; 3#include \u0026#34;TestObjVariable.h\u0026#34; 4 5JNIEXPORT void JNICALL Java_TestObjVariable_setNameAndAge(JNIEnv *env, jobject obj) { 6 //获取当前对象的Class 7 jclass thisClass = (*env)-\u0026gt;GetObjectClass(env, obj); 8 9 jfieldID fidAge = (*env)-\u0026gt;GetFieldID(env, thisClass, \u0026#34;age\u0026#34;, \u0026#34;I\u0026#34;); 10 if (NULL == fidAge) { 11 return; 12 } 13 14 jint age = (*env)-\u0026gt;GetIntField(env, obj, fidAge); 15 printf(\u0026#34;In C, the age is %d\\n\u0026#34;, age); 16 age = 22; 17 (*env)-\u0026gt;SetIntField(env, obj, fidAge, age); 18 19 jfieldID fidName = (*env)-\u0026gt;GetFieldID(env, thisClass, \u0026#34;name\u0026#34;, \u0026#34;Ljava/lang/String;\u0026#34;); 20 if (NULL == fidName) { 21 return; 22 } 23 24 jstring name = (*env)-\u0026gt;GetObjectField(env, obj, fidName); 25 const char *str = (*env)-\u0026gt;GetStringUTFChars(env, name, NULL); 26 if (NULL == str) { 27 return; 28 } 29 30 printf(\u0026#34;In C, the name is %s\\n\u0026#34;, str); 31 (*env)-\u0026gt;ReleaseStringUTFChars(env, name, str); 32 33 name = (*env)-\u0026gt;NewStringUTF(env, \u0026#34;钟灵\u0026#34;); 34 if (NULL == name) { 35 return; 36 } 37 (*env)-\u0026gt;SetObjectField(env, obj, fidName, name); 38} 运行结果为：\n1ubuntu@vm-911:~/workspace/java/jni/demo2$ java -Djava.library.path=. TestObjVariable 2In C, the age is 24 3In C, the name is liubang 4My name is 钟灵 and I am 22 years old 可能在之前的例子中你会觉得平淡无奇，那么写到这里是不是发现有点意思了。\n首先通过GetObjectClass函数来获取当前对象的类，然后通过GetFieldID函数来获取成员变量的 ID，这里你需要提供字段的名字和字段类型的描述符。对于一个 Java 类类型的描述符，通常用\u0026quot;L;\u0026ldquo;的形式来描述，这里千万要注意最后有一个分号，例如上述例子中的对于 String 类型的描述符为\u0026quot;Ljava/lang/String;\u0026quot;。而对于基本数据类型，可以使用\u0026quot;I\u0026quot;来描述\u0026quot;int\u0026rdquo;，\u0026ldquo;B\u0026quot;来描述\u0026quot;byte\u0026rdquo;，\u0026ldquo;S\u0026quot;来描述\u0026quot;short\u0026rdquo;，\u0026ldquo;J\u0026quot;描述\u0026quot;long\u0026rdquo;，\u0026ldquo;F\u0026quot;描述\u0026quot;float\u0026rdquo;，\u0026ldquo;D\u0026quot;描述\u0026quot;double\u0026rdquo;，\u0026ldquo;C\u0026quot;描述\u0026quot;char\u0026rdquo;，\u0026ldquo;Z\u0026quot;描述\u0026quot;boolean\u0026rdquo;。如果是数组，则只需要加上一个\u0026quot;[\u0026ldquo;的前缀即可，例如：\u0026quot;[Ljava/lang/String;\u0026ldquo;描述一个 String 类型的数组。看到这里，假如你恰好也是一个 PHP 程序员，而且对 PHP 内核有所了解的话，是不是发现跟鞋 PHP 扩展时候参数的解析有一些类似呢。\n基于字段 ID，通过GetObjectField函数或者Get\u0026lt;primitive-type\u0026gt;Field函数来获取实例对象的成员变量。\n更新实例对象的成员变量，则调用SetObjectField或者Set\u0026lt;primitive-type\u0026gt;Field函数。\n3.2 访问静态成员 访问静态成员同访问成员变量很相似，不同的是使用的 JNI 函数为GetStaticFieldID, Get|SetStaticObjectField, Get|SetStatic\u0026lt;Primitive-type\u0026gt;Field。\nTestObjStaticVariable.java\n1public class TestObjStaticVariable { 2 static { 3 System.loadLibrary(\u0026#34;libtestobjstaticvariable\u0026#34;); 4 } 5 6 private static int age = 24; 7 private static String name = \u0026#34;liubang\u0026#34;; 8 9 private native void setNameAndAge(); 10 11 public static void main(String[] args) { 12 TestObjStaticVariable test = new TestObjStaticVariable(); 13 test.setNameAndAge(); 14 System.out.println(\u0026#34;In java, my name is \u0026#34; + name + \u0026#34;, I am \u0026#34; + age + \u0026#34; years old\u0026#34;); 15 } 16} TestObjStaticVariable.c\n1#include \u0026lt;stdio.h\u0026gt; 2#include \u0026lt;jni.h\u0026gt; 3#include \u0026#34;TestObjStaticVariable.h\u0026#34; 4 5JNIEXPORT void JNICALL Java_TestObjStaticVariable_setNameAndAge(JNIEnv *env, jobject obj) { 6 jclass class = (*env)-\u0026gt;GetObjectClass(env, obj); 7 8 jfieldID fidAge = (*env)-\u0026gt;GetStaticFieldID(env, class, \u0026#34;age\u0026#34;, \u0026#34;I\u0026#34;); 9 if (NULL == fidAge) { 10 return; 11 } 12 13 jint age = (*env)-\u0026gt;GetStaticIntField(env, obj, fidAge); 14 printf(\u0026#34;In C, the age is %d\\n\u0026#34;, age); 15 16 age = 22; 17 (*env)-\u0026gt;SetStaticIntField(env, class, fidAge, age); 18} 3.3 调用实例方法和静态方法 TestInstanceMethod.java\n1public class TestInstanceMethod { 2 static { 3 System.loadLibrary(\u0026#34;testinstance\u0026#34;); 4 } 5 6 private native void foo(); 7 8 private void bar() { 9 System.out.println(\u0026#34;hello liubang\u0026#34;); 10 } 11 12 private void bar(String message) { 13 System.out.println(\u0026#34;hello \u0026#34; + message); 14 } 15 16 private double avg(int a, int b) { 17 return ((double)a + b)/2.0; 18 } 19 20 private static String s() { 21 return \u0026#34;hello zhongling\u0026#34;; 22 } 23 24 public static void main(String[] args) { 25 new TestInstanceMethod().foo(); 26 } 27} TestInstanceMethod.c\n1#include \u0026lt;stdio.h\u0026gt; 2#include \u0026lt;jni.h\u0026gt; 3#include \u0026#34;TestInstanceMethod.h\u0026#34; 4 5JNIEXPORT void JNICALL Java_TestInstanceMethod_foo(JNIEnv *env, jobject obj) { 6 7 jclass thisClass = (*env)-\u0026gt;GetObjectClass(env, obj); 8 jmethodID midBar = (*env)-\u0026gt;GetMethodID(env, thisClass, \u0026#34;bar\u0026#34;, \u0026#34;()V\u0026#34;); 9 if (NULL == midBar) { 10 return; 11 } 12 13 printf(\u0026#34;In C, call Java\u0026#39;s bar()\\n\u0026#34;); 14 (*env)-\u0026gt;CallVoidMethod(env, obj, midBar); 15 16 jmethodID midBarStr = (*env)-\u0026gt;GetMethodID(env, thisClass, \u0026#34;bar\u0026#34;, \u0026#34;(Ljava/lang/String;)V\u0026#34;); 17 if (NULL == midBarStr) { 18 return; 19 } 20 printf(\u0026#34;In C, call Java\u0026#39;s s()\\n\u0026#34;); 21 jstring message = (*env)-\u0026gt;NewStringUTF(env, \u0026#34;钟灵\u0026#34;); 22 (*env)-\u0026gt;CallVoidMethod(env, obj, midBarStr, message); 23 24 jmethodID midAvg = (*env)-\u0026gt;GetMethodID(env, thisClass, \u0026#34;avg\u0026#34;, \u0026#34;(II)D\u0026#34;); 25 if (NULL == midAvg) { 26 return; 27 } 28 jdouble average = (*env)-\u0026gt;CallDoubleMethod(env, obj, midAvg, 2, 5); 29 printf(\u0026#34;In C, the average of 2 and 5 is %f\\n\u0026#34;, average); 30 31 jmethodID midStatic = (*env)-\u0026gt;GetStaticMethodID(env, thisClass, \u0026#34;s\u0026#34;, \u0026#34;()Ljava/lang/String;\u0026#34;); 32 if (NULL == midStatic) { 33 return; 34 } 35 36 jstring res = (*env)-\u0026gt;CallStaticObjectMethod(env, thisClass, midStatic); 37 const char *cStr = (*env)-\u0026gt;GetStringUTFChars(env, res, NULL); 38 if (NULL == cStr) { 39 return; 40 } 41 printf(\u0026#34;In C, the returned string is %s\\n\u0026#34;, cStr); 42 (*env)-\u0026gt;ReleaseStringUTFChars(env, res, cStr); 43} 测试结果为：\n1ubuntu@vm-911:~/workspace/java/jni/demo3$ java -Djava.library.path=. TestInstanceMethod 2In C, call Java\u0026#39;s bar() 3hello liubang 4In C, call Java\u0026#39;s s() 5hello 钟灵 6In C, the average of 2 and 5 is 3.500000 7In C, the returned string is hello zhongling **注意：**也许细心的你已经发现了，在调用对象成员和静态成员(类成员)的时候，除了调用的函数中多了\u0026quot;static\u0026quot;之外，函数的参数也有所区别，对象成员中传入的是当前的对象实例，而静态成员传的则是当前的类。\n上述代码非常简单，主要使用GetMethodID函数来获取想要调用的成员方法的 methodID，这里需要解释的一点就是，对于函数的参数和返回值使用的是(参数)返回值的形式来做描述符，这里的类型描述符跟前面讲到获取对象成员时候的规则是一样的，这里不再赘述。\n4、创建对象和对象数组 4.1 使用构造方法创建对象 TestCreateObj.java\n1public class TestCreateObj { 2 static { 3 System.loadLibrary(\u0026#34;createobj\u0026#34;); 4 } 5 6 private native Integer getIntegerObj(int n); 7 8 public static void main(String[] args) { 9 TestCreateObj t = new TestCreateObj(); 10 System.out.println(\u0026#34;In Java, the number is :\u0026#34; + t.getIntegerObj(1000)); 11 } 12} TestCreateObj.c\n1#include \u0026lt;stdio.h\u0026gt; 2#include \u0026lt;jni.h\u0026gt; 3#include \u0026#34;TestCreateObj.h\u0026#34; 4 5JNIEXPORT jobject JNICALL Java_TestCreateObj_getIntegerObj(JNIEnv *env, jobject obj, jint number) { 6 jclass clazz = (*env)-\u0026gt;FindClass(env, \u0026#34;java/lang/Integer\u0026#34;); 7 jmethodID midCons = (*env)-\u0026gt;GetMethodID(env, clazz, \u0026#34;\u0026lt;init\u0026gt;\u0026#34;, \u0026#34;(I)V\u0026#34;); 8 9 jobject intObj = (*env)-\u0026gt;NewObject(env, clazz, midCons, number); 10 jmethodID midToString = (*env)-\u0026gt;GetMethodID(env, clazz, \u0026#34;toString\u0026#34;, \u0026#34;()Ljava/lang/String;\u0026#34;); 11 if (NULL == midToString) { 12 return NULL; 13 } 14 15 jstring resStr = (*env)-\u0026gt;CallObjectMethod(env, intObj, midToString); 16 const char *cStr = (*env)-\u0026gt;GetStringUTFChars(env, resStr, NULL); 17 printf(\u0026#34;In C: the number is %s\\n\u0026#34;, cStr); 18 19 return intObj; 20} 运行结果为：\n1ubuntu@vm-911:~/workspace/java/jni/demo3$ java -Djava.library.path=. TestCreateObj 2In C: the number is 1000 3In Java, the number is :1000 4.2 创建对象数组 TestObjArr.java\n1public class TestObjArr { 2 static { 3 System.loadLibrary(\u0026#34;objarr\u0026#34;); 4 } 5 6 private native Double[] sumAndAverage(Integer[] number); 7 8 public static void main(String args[]) { 9 Integer[] numbers = {11, 24, 88}; 10 Double[] results = new TestObjArr().sumAndAverage(numbers); 11 System.out.println(\u0026#34;In Java, the sum is \u0026#34; + results[0]); 12 System.out.println(\u0026#34;In Java, the average is \u0026#34; + results[1]); 13 } 14} TestObjArr.c\n1#include \u0026lt;stdio.h\u0026gt; 2#include \u0026lt;jni.h\u0026gt; 3#include \u0026#34;TestObjArr.h\u0026#34; 4 5JNIEXPORT jobjectArray JNICALL Java_TestObjArr_sumAndAverage(JNIEnv *env, jobject obj, jobjectArray numbers) { 6 jclass classInt = (*env)-\u0026gt;FindClass(env, \u0026#34;java/lang/Integer\u0026#34;); 7 jmethodID midIntVal = (*env)-\u0026gt;GetMethodID(env, classInt, \u0026#34;intValue\u0026#34;, \u0026#34;()I\u0026#34;); 8 if (NULL == midIntVal) { 9 return NULL; 10 } 11 12 jsize length = (*env)-\u0026gt;GetArrayLength(env, numbers); 13 jint sum = 0; 14 int i; 15 for (i = 0; i \u0026lt; length; i++) { 16 jobject objInt = (*env)-\u0026gt;GetObjectArrayElement(env, numbers, i); 17 if (NULL == objInt) { 18 return NULL; 19 } 20 jint value = (*env)-\u0026gt;CallIntMethod(env, objInt, midIntVal); 21 sum += value; 22 } 23 24 double average = (double)sum / length; 25 printf(\u0026#34;In C, the sum is %d\\n\u0026#34;, sum); 26 printf(\u0026#34;In C, the average is %f\\n\u0026#34;, average); 27 28 jclass classDouble = (*env)-\u0026gt;FindClass(env, \u0026#34;java/lang/Double\u0026#34;); 29 jobjectArray outArr = (*env)-\u0026gt;NewObjectArray(env, 2, classDouble, NULL); 30 jmethodID midDoubleInit = (*env)-\u0026gt;GetMethodID(env, classDouble, \u0026#34;\u0026lt;init\u0026gt;\u0026#34;, \u0026#34;(D)V\u0026#34;); 31 if (NULL == midDoubleInit) { 32 return NULL; 33 } 34 35 jobject objSum = (*env)-\u0026gt;NewObject(env, classDouble, midDoubleInit, (double)sum); 36 jobject objAvg = (*env)-\u0026gt;NewObject(env, classDouble, midDoubleInit, average); 37 38 (*env)-\u0026gt;SetObjectArrayElement(env, outArr, 0, objSum); 39 (*env)-\u0026gt;SetObjectArrayElement(env, outArr, 1, objAvg); 40 41 return outArr; 42} 测试结果为：\n1ubuntu@vm-911:~/workspace/java/jni/demo3$ java -Djava.library.path=. TestObjArr 2In C, the sum is 123 3In C, the average is 41.000000 4In Java, the sum is 123.0 5In Java, the average is 41.0 注意： 在 JNI 中调用构造方法的时候，方法名称用的是\u0026lt;init\u0026gt;\n","date":"March 20, 2017","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/java/2017-03-20-java_native_interface%E4%BA%8C/","series":[],"smallImg":"","tags":[{"title":"Java","url":"/blog/tags/java/"},{"title":"JNI","url":"/blog/tags/jni/"}],"timestamp":1489968000,"title":"Java Native Interface（二）"},{"authors":[],"categories":[{"title":"Programming","url":"/blog/categories/programming/"}],"content":"前面系统研究了 JNI 的相关操作，下面就来小试牛刀，做一个实际的练习。\n记得去年我曾经用 C 语言写过一个 PHP 的 md5 扩展函数，那么今天就花一点点时间用 JNI 来实现一遍吧。\n不过这里可要提前声明了，虽然是实现 md5 函数，但是这里并不会从头写 md5 算法，而是投机取巧使用到了 linux 内核提供的crypto库。\n废话不多说，首先来写一个 Java 类\nMyString.java\n1public class MyString { 2 static { 3 System.loadLibrary(\u0026#34;mymd5\u0026#34;); 4 } 5 6 private String value; 7 8 public native String md5(); 9 10 public MyString(String value) { 11 this.value = value; 12 } 13} 然后生成头文件，并实现 c 代码：\n1#include \u0026lt;jni.h\u0026gt; 2#include \u0026lt;openssl/md5.h\u0026gt; 3#include \u0026lt;string.h\u0026gt; 4 5JNIEXPORT jstring JNICALL Java_MyString_md5(JNIEnv *env, jobject obj) { 6 jclass thisClass = (*env)-\u0026gt;GetObjectClass(env, obj); 7 jfieldID fidValue = (*env)-\u0026gt;GetFieldID(env, thisClass, \u0026#34;value\u0026#34;, \u0026#34;Ljava/lang/String;\u0026#34;); 8 if (NULL == fidValue) { 9 return NULL; 10 } 11 jstring value = (*env)-\u0026gt;GetObjectField(env, obj, fidValue); 12 13 const unsigned char *data = (*env)-\u0026gt;GetStringUTFChars(env, value, NULL); 14 MD5_CTX ctx; 15 unsigned char md[16]; 16 char buf[33]= {\u0026#39;\\0\u0026#39;}; 17 char tmp[3]= {\u0026#39;\\0\u0026#39;}; 18 int i; 19 MD5_Init(\u0026amp;ctx); 20 MD5_Update(\u0026amp;ctx,data,strlen((char *)data)); 21 MD5_Final(md,\u0026amp;ctx); 22 23 for( i=0; i\u0026lt;16; i++ ) { 24 sprintf(tmp,\u0026#34;%02X\u0026#34;,md[i]); 25 strcat(buf,tmp); 26 } 27 28 value = (*env)-\u0026gt;NewStringUTF(env, buf); 29 return value; 30} 至此代码平淡无奇，也没什么好解释的，不过需要注意的是编译成动态链接库的部分，由于这里依赖到了其他的动态链接库，所以编译参数需要使用-L{path} -l{libname}来显示的指明依赖库的路径和库名\n1gcc -fPIC -shared -I /opt/app/java/include/ -I /opt/app/java/include/linux/ -I /usr/include/openssl/ -L/usr/lib/x86_64-linux-gnu/ MyString.c -lcrypto -o libmymd5.so 这样就编译好了，然后我们写一个测试类\n1public class Test { 2 public static void main(String[] args) { 3 MyString s = new MyString(\u0026#34;liubang\u0026#34;); 4 System.out.println(s.md5()); 5 } 6} 编译并运行：\n1ubuntu@vm-911:~/workspace/java/jni/demo4$ java -Djava.library.path=. Test 2D67DF7EAE3E651E9DA077E9423C7A9B6 enjoy!\n","date":"March 20, 2017","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/java/2017-03-20-java_native_interface%E4%B8%89/","series":[],"smallImg":"","tags":[{"title":"Java","url":"/blog/tags/java/"},{"title":"JNI","url":"/blog/tags/jni/"}],"timestamp":1489968000,"title":"Java Native Interface（三）"},{"authors":[],"categories":[{"title":"Programming","url":"/blog/categories/programming/"}],"content":"最近在整理学习笔记的时候发现了去年年中记录的 JNI 学习笔记，由于存放在了为知笔记中，而如今为知笔记已经不再免费，于是想到了将其重新整理一遍，一来可以巩固所学，二来能将其迁移到本地\n1 简介 有时候，使用 native code(c/c++)来克服 Java 中的内存管理和性能的局限性是很有必要的。Java 支持 native codes，被称作 Java Native Interface(JNI)。\nJNI 非常难，毕竟它牵涉到了两种编程语言。假设聪明的你对 Java 和 C/C++以及 GCC 编译器已经有所了解。那么下面就一起来一步步学习 JNI 吧。\n2 开始 2.1 用 c 语言实现第一个 JNI 程序 Step1: 创建一个名字为 JNITest.java 的文件\n1public class JNITest { 2 static { 3 System.load(\u0026#34;/home/ubuntu/workspace/java/jni/mynativelib.so\u0026#34;); 4 } 5 6 //申明一个无参的native方法，而且返回空 7 public native void greet(); 8 9 //测试 10 public static void main(String[] args) { 11 JNITest test = new JNITest(); 12 test.greet(); 13 } 14} 首先用静态代码块加载本地动态链接库\u0026quot;mynativelib.so\u0026quot;。对于静态代码块，我相信写过 Java 的你应该非常清楚，它只会在类被加载的时候执行一次。这个动态链接库会被添加到 Java 的 library path（保存在 Java 系统变量 java.library.path）中，如果加载失败，就会抛出UnsatisfiedLinkError异常。也可以使用 JVM 启动参数来加载该动态链接库到 Java 的 library path 当中：\n1-Djava.library.path=path_to_lib 说明：JNI 中有两种常见的加载动态链接库的写法，一个是System.load(filename)，另一个是System.loadLibrary(libname)，二者的区别在于，第一种需要的是文件的全名称，而第二种只需要动态链接库的库名(windows 下省略.dll 后缀，linux 下省略 lib 前缀和.so 后缀)。\n然后我们使用native关键字申明一个名为greet的 native instance method。被 native 修饰的方法不能有方法体。\n接下来编译 JNITest.java 文件\n1javac JNITest.java Step2: 生成 C/C++头文件 JNITest.h\n1javah JNITest 执行上述命令后自动生成一个名为 JNITest.h 的文件\n1/* DO NOT EDIT THIS FILE - it is machine generated */ 2#include \u0026lt;jni.h\u0026gt; 3/* Header for class JNITest */ 4 5#ifndef _Included_JNITest 6#define _Included_JNITest 7#ifdef __cplusplus 8extern \u0026#34;C\u0026#34; { 9#endif 10/* 11 * Class: JNITest 12 * Method: greet 13 * Signature: ()V 14 */ 15JNIEXPORT void JNICALL Java_JNITest_greet 16 (JNIEnv *, jobject); 17 18#ifdef __cplusplus 19} 20#endif 21#endif 该头文件声明了Java_JNITest_greet的函数原型，Java 中的函数对应到 C 中的命名规则为：Java_{package_and_classname}_{method_name}(JNI arguments)\n其中 JNI arguments:\nJNIEnv *: 指向 JNI 执行环境的指针，通过它可以访问到所有的 JNI 方法 jobject: 指向 Java 中的\u0026quot;this\u0026quot; **Step3:**用 c 语言实现头文件中的函数 - jnitest.c\n1#include \u0026lt;stdio.h\u0026gt; 2#include \u0026lt;jni.h\u0026gt; 3#include \u0026#34;JNITest.h\u0026#34; 4 5JNIEXPORT void JNICALL Java_JNITest_greet(JNIEnv *env, jobject obj) { 6\tprintf(\u0026#34;hello liubang...\\n\u0026#34;); 7\tprintf(\u0026#34;this is implemented by c and called by java!\\n\u0026#34;); 8\treturn; 9} **Step4:**编译动态链接库\n1gcc -fPIC -shared -I /opt/app/java/include/ -I /opt/app/java/include/linux/ jnitest.c -o mynativelib.so **Step5:**运行 Java 程序\n1java JNITest 2 3====output=== 4ubuntu@vm-911:~/workspace/java/jni$ java JNITest 5hello liubang... 6this is implemented by c and called by java! 于是第一个 c 语言实现的 JNI 程序就跑起来了，是不是很简单。别着急，这只是个开始！\n2 JNI in Package 通常情况下，几乎所有的 Java 类都有自己的 package 而不是直接使用默认的无名的 package。那么对于使用了 package 的 Java 类如何来创建 JNI 程序呢，其实跟开始的例子几乎是一样的。\n首先实现一个 test.HelloJNI 类\n1package test; 2 3public class HelloJNI { 4 5 static { 6 System.loadLibrary(\u0026#34;hello\u0026#34;); 7 } 8 9 private native void sayHello(); 10 11 public static void main(String[] args) { 12 new HelloJNI().sayHello(); 13 } 14 15} 然后编译 Java 程序\n1javac test/HelloJNI.java 接着生成 C/C++头文件\n1//将生成的头文件存放在include文件夹 2javah -d include test.HelloJNI 实现头文件中定义的函数\n1#include \u0026lt;stdio.h\u0026gt; 2#include \u0026lt;jni.h\u0026gt; 3#include \u0026#34;include/test_HelloJNI.h\u0026#34; 4 5JNIEXPORT void JNICALL Java_test_HelloJNI_sayHello(JNIEnv *env, jobject this) { 6 printf(\u0026#34;hello liubang\\n\u0026#34;); 7 return; 8} 编译成动态链接库\n1gcc -fPIC -shared -I /opt/app/java/include/ -I /opt/app/java/include/linux/ HelloJNI.c -o libhello.so 然后运行 Java 程序\n1java -Djava.library.path=. test.HelloJNI 2 3====output==== 4ubuntu@vm-911:~/workspace/java/jni/demo1$ java -Djava.library.path=. test.HelloJNI 5hello liubang ","date":"March 17, 2017","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/java/2017-03-17-java_native_interface%E4%B8%80/","series":[],"smallImg":"","tags":[{"title":"Java","url":"/blog/tags/java/"},{"title":"JNI","url":"/blog/tags/jni/"}],"timestamp":1489708800,"title":"Java Native Interface（一）"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"Programming","url":"/blog/categories/programming/"}],"content":"说明：参考文献地址 A Malloc Tutorial\n1 简介 malloc是干什么的？如果你连这个名字都没听过，那么你应该先去了解 Unix 环境下的 c 语言开发，然后再来阅读。对一个程序员而言，malloc是一个在 c 语言中用来分配内存的函数，但是大多数人并不知道它背后真正的原理，甚至有些人认为malloc是 c 语言的关键字或者认为它是系统调用。事实上，malloc是一个再简单不过的函数而已，而且只需要很少的操作系统相关知识就可以让我们彻底理解它的原理。\n下面来一步步的实现一个简单的malloc函数，从而帮助我们理解其背后运作的原理。因为仅仅作为说明原理之用，所以这里实现的malloc不会太高效，但是足以说明原理。\n什么是 malloc\nmalloc(3)是一个用来分配内存块的标准的 c 语言库函数。它遵循以下规则：\nmalloc至少分配所需字节数的内存； malloc返回其所分配内存空间(程序可以成功读写的空间)的指针； 一块内存一旦被malloc分配，其他malloc调用不能再分配该内存块的任何部分，除非指向该内存块的指针被释放掉； malloc应该是可控的：他必须能够很快完成分配并返回； malloc同时应该提供重新分配内存块大小和释放内存的功能 malloc函数必须遵循以下原型：\n1void *malloc(size_t size); 其中size是所需要的内存大小。如果失败（没有足够的内存空间可以分配），应该返回NULL。\n2 堆，brk 和 sbrk 系统调用 在开始实现第一个malloc函数之前，需要了解内存在大多数多任务操作系统中是如何管理的。这里我们只是做出一个抽象的解释，从大体上去帮助理解，至于很多细节，它们都依赖操作系统原理和硬件相关的知识。\n2.1 进程的内存 每个进程都有自己的虚拟地址空间被 MMU（Memory Management Unit, 内存管理单元）(和内核)动态的转换到物理内存地址空间。这部分空间被划分成了几个部分，我们需要了解的是至少有一部分空间存放代码，一个用来存放局部变量的栈，一部分用来存放常量和全局变量的空间，以及程序的无组织空间我们称之为堆。\n堆是一个连续的（依据虚拟地址而言）内存空间，它有三个边界：一个起始点，一个最大限度边界（通过 sys/ressource.h 中的 getrlimit(2)函数和 setrlimit(2)函数来管理）和一个被称为break的结束点。break标记了隐射内存空间的结束，也就是说，虚拟地址空间部分对应着真实的内存空间。下图表示内存组织结构\n要想实现一个malloc函数，我们需要知道堆的起始点和 break 的位置，然后我们来移动 break。要做到这些，就需要用到两个系统调用，brk和sbrk。\n2.2 brk(2)和 sbrk(2) 我们可以在这些系统调用的文档中看到相关描述：\n1int brk(const void *addr); 2void *sbrk(intptr_t incr); 在 linux 系统中使用man 2 brk命令查看文档\nbrk() and sbrk() change the location of the program break, which defines the end of the process\u0026rsquo;s data segment (i.e., the program break is the first location after the end of the uninitialized data segment). Increasing the program break has the effect of allocating memory to the process; decreasing the break deallocates memory. brk() sets the end of the data segment to the value specified by addr, when that value is reasonable, the system has enough memory, and the process does not exceed its maximum data size (see setrlimit(2)). sbrk() increments the program\u0026rsquo;s data space by increment bytes. Calling sbrk() with an increment of 0 can be used to find the current location of the program break. On success, brk() returns zero. On error, -1 is returned, and errno is set to ENOMEM. On success, sbrk() returns the previous program break. (If the break was increased, then this value is a pointer to the start of the newly allo‐cated memory). On error, (void *) -1 is returned, and errno is set to ENOMEM.\n我们将使用sbrk作为主要工具来实现一个malloc函数。所要做的事情就是获取更多的空间(如果需要的话)去满足调用者的需求。\n2.3 Unmapped Region and No-Man’s Land 正如前面讲到的 break 标记了映射虚拟地址空间的结束：越过 break 来访问地址会造成总线错误。maximum limit 和 break 之间的剩余地址没有被系统的虚拟内存管理器关联到物理内存。 但是，如果你了解一点关于虚拟内存的知识，那么你会知道内存是通过 page 来映射的：物理内存和虚拟内存是组织在具有固定大小的 page 中(大多数情况下)。page 的大小圆圆超过 1byte(在大多数操作系统中，page size 是 4096bytes)。也就是说，break 有可能没有恰好落在 pages 的边界上。\n上图展示了带有 page 边界的内存组织结构。我们可以看到 break 没有对齐到 page 的边界。那么处于 break 和下一个 page 边界之间的内存是一种什么样的状态呢？事实上，这段空间是可以访问的！你可以在这段空间里读写字节。问题是，你对下一个 page 边界的位置没有任何线索，你可以依赖操作系统来找到它，但是这是一个不好的建议。\n这些 no-man\u0026rsquo;s land 通常是 bug 的根源：一些对堆外指针的错误操作大多数只有小测试的情况下都能成功，只有当操作很大量的数据的时候会失败。\n2.4 mmap(2) 尽管我们在本文中不会用到mmap(2)系统调用，但是我们仍然需要花时间去了解它。它有一个匿名模式(mmap(2)通常被用来直接的在内存中映射文件)可以用来(完整地或者在某些特殊情况下)实现malloc函数。\nmmap(2)在匿名模式下可以分配特定的记忆体空间，而munmap可以将其释放。这通常比传统的基于sbrk的 malloc 要更简单和高效。一些 malloc 实现使用mmp来分配较大的空间(超过一个 page)。OpenBSD 的 malloc 函数只使用mmap，加上一些方法以提高安全性。\n3 实现一个简陋的 malloc 首先，我们将要使用sbrk(2)来实现一个简陋的 malloc。这个 malloc 可能是最烂的一个，但是也是最简单，实现起来最快的一个。\n3.1 原理 原理非常的简单，每当malloc被调用的时候，我们将 break 移动所需字节的空间，然后返回异动前 break 的地址。看起来是不是很简单，这样只需要 3 行代码就可以实现，但是这样的话我们无法实现释放和重新分配的功能。\n3.2 实现 1#include \u0026lt;sys/types.h\u0026gt; 2#include \u0026lt;unistd.h\u0026gt; 3 4void *malloc(size_t size) 5{ 6 void *p; 7 p = sbrk(0); 8 if (sbrk(size) == (void *)-1) 9 return NULL; 10 return p; 11} 4 堆 在上一节中，我们花了点时间实现了一个简单的 malloc 函数，但是并不能满足所有的需求。因此本节我们将尝试着去了解堆从而实现一个更加高效的 malloc 函数，进而实现 free 和 realloc。\n4.1 我们需要什么 如果我们考虑编程环境之外的问题，我们可以推断出什么样的信息能解决我们的问题。让我们来做个比喻：你拥有一块区域，然后划分它其中的一部分租出去。客户要求不同的尺寸(你划分的时候都是按照同一个的标准)而且还要是连续的。当他们使用完了退回给你，然后你又可以接着租出去。\n在这片领域的一边有一条路，路上有一辆可以编程的车：你可以输入区域和目的地之间的距离。我们需要知道每一块是从哪里开始的（这就相当于 malloc 返回的指针）。\n一个解决方案是我们标记每一个下一部分开始的地址（和当前部分的大小以避免不必要的计算）。我们也将空闲的部分打上标记（当客户使用完返还的时候做上标记）。此时，当有客户想要一个确定大小的区域的时候我们坐车遍历一个个标记。当我们发现一个区域被标记为空闲状态而且能够满足客户的需求的时候，我们去掉空闲的标记然后租给客户。如果我们到了最后一个区域（这个区域的标记没有指向下一个区域的地址）我们只需要到这个区域的末尾添加一个新的标记。\n我们可以把上述的思想转换到内存中：在每一个内存块的开始部分需要有额外的信息，其中包括内存区块的大小，下一个区块的地址和当前区块是否为空闲状态。\n4.2 如何表示块信息 我们需要的仅仅是在每一个 chunk 的开始需要有一个很小的 block 来保存额外的信息，这个信息被称为 meta-data。这个 block 至少需要包含一个指向下一 chunk 的指针，一个标记当前 chunk 是否为 free 的标记以及当前 chunk 的可存放的 data size。当然，这个 block 在 malloc 函数返回的指针前面。\nHeap's Chunks Structure 上图展示了一种分配的 block 前带有 meta-data 信息的堆的组织结构。每一个 chunk 都包含一个存放 meta-data 的 block 和一个存放数据的 block。malloc 函数返回的指针指向的是存放数据的 block，而不是整个 chunk。\n那么，我们该如何把它转换成 c 代码呢？上述思想看起来很像一个传统的链表，于是我们写了一个链表：\n1typedef struct s_block *t_block; 2 3struct s_block { 4 size_t size; 5 t_block next; 6 int free; 7}; 说明：使用typedef可以简化自定义类型的使用。考虑到我们使用该类型的时候都是基于指针的形式，所以在typedef中将s_block定义为t_block类型的指针，这对链表来说会是一个很好的体验，因为链表是一个指针，而不是一个 block（一个空链表就是一个空指针）。\n将 flag 设置成 int 类型看起来很浪费空间，但是由于结构体是默认对齐的，所以改变 flag 的类型对结构体占用空间没有任何影响。待会我们会看到我们将如何来压缩 meta-data 的 size。此外还需要注意的一点就是 malloc 必须返回对齐的地址。\n一个被问的很频繁的问题是：在没有 malloc 的情况下我们如何创建一个结构体？The answer is simple.你只需要知道一个结构体到底是什么就好了。在内存中，一个 struct 仅仅是其字段的串联，所以在上述例子中，struct s_block只是 12bytes(32 bit integer)，第一个 4bytes 指的是size这个字段，第二个 4bytes 指的是next这个字段，最后一个指的是free这个字段。当编译器遇到访问 struct 字段(例如 s.free 或 p-\u0026gt;free)的情况时，它会将其转换成 struct 的基地址加上它前面字段的长度(p-\u0026gt;free ==\u0026gt; _((char _)p+8), s.free ==\u0026gt; _((char _)\u0026amp;s + 8))。你需要做的就是用sbrk分配足够的空间。\n1/* Example of using t_block without malloc */ 2t_block b; 3/* save ths old break in b */ 4b = sbrk(0); 5/* add the needed space */ 6/* size is the parameter of malloc */ 7sbrk(sizeof(struct s_block) + size); 8b-\u0026gt;size = size; 5 malloc 的第一个优化版 在这一节当中我们将实现第一个传统 mallc 的优化版。第一个优化算法非常简单：我们遍历 chunks 列表直到我们发现一个 free 的 block 而且有足够的空间来满足需求。\n5.1 指针对齐 指针常常需要按照整型来对齐。这里我们只考虑 32bit 的情况，64bit 原理相同。因此，指针必须能被 4(32 bits = 4 bytes)整除。meta-data block 已经对齐了，那么我们唯一需要做的事情就是使得 data 的 size 对齐。\n首先，我们来玩玩数字游戏：任取一个正整数，先整除 4，然后再乘以 4，这样就得到了最近的一个能被 4 整除的且比 4 小的数字，如果要得到最近的一个能被 4 整除且大于 4 的数字就再加上一个 4。\n任取一个正整数$x$，\n\\[ x = 4 \\times p + q, q \\in \\left[0, 3\\right] \\]\n如果$x$是 4 的倍数，那么\n\\[ q = 0, x - 1 = 4 \\times \\left(p - 1\\right) + 3, \\left(\\left(x - 1\\right) / 4 \\right) \\times 4 + 4 = 4 \\times p = x \\]\n如果$x$不是 4 的倍数，那么\n\\[ q \\not= 0, x - 1 = 4 \\times p + \\left(q - 1\\right), q - 1 \\in \\left[0, 2\\right]; \\]\n所以：\n\\[ \\left(x - 1\\right)/4\\times4+4 = 4 \\times p + p = x/4\\times4+4 \\]\n于是我们得到了一个公式:\n\\[ \\left(x - 1\\right) / 4 \\times4 + 4 \\]\n那么，我们怎样用 c 语言来表示呢？首先，跟 4 做乘法和除法可以被表示成左位移和右位移运算(\u0026laquo;和\u0026raquo;)，它比普通的运算要高效很多。因此我们的公式在 c 语言中可以写成：\n1((x-1)\u0026gt;\u0026gt;2)\u0026lt;\u0026lt;2 + 4 要想得到一个正确的宏，我们需要添加一些额外的括号：\n1#define align4(x) (((((x)-1)\u0026gt;\u0026gt;2)\u0026lt;\u0026lt;2)+4) 5.2 查找 chunk:第一个优化算法 查找一个标记为 free 的且又空间富裕的 chunk 是如此的简单：我们开始在堆的基址(程序中会保存，待会我们会看到)检验当前的 chunk，如果它能满足需求，我们只需要返回它的地址即可，否则我们继续下一个 chunk 直到我们找到了满足需求的 chunk，或者到了堆末尾也没找到。唯一的技巧就是保存最后一次访问的 chunck，因此如果我们没有找到满足需求的 chunk 的话，malloc 函数可以很容易到达堆的末尾。代码是如此的明了，base 是一个指向堆的起始位置的指针：\n1t_block find_block(t_block *last, sizt_t size) 2{ 3 t_block b = base; 4 while (b \u0026amp;\u0026amp; !(b-\u0026gt;free \u0026amp;\u0026amp; b-\u0026gt;size \u0026gt;= size)) { 5 *last = b; 6 b = b-\u0026gt;next; 7 } 8 9 return (b); 10} 这个函数返回一个满足需求的 chunk，或者没有合适的就返回 NULL。每一次循环之后，last 变量就会指向上一次访问的 chunk。\n5.3 扩展堆 假如我们总是找不到合适的 chunk，有时候(尤其是在程序刚开始的时候使用 malloc)我们需要扩展堆。这也是相当简单的一件事：我们移动 break，然后初始化一个新的 block，当然我们需要更新最后一个 block 的 next 字段(实际上就是给链表中添加一个结点)。\n在接下来的开发中，我们需要在s_block结构体的 size 上做一些小技巧，于是定义了一个宏来获取 meta-data block 的 size，现在这个宏的定义如下：\n1#define BLOCK_SIZE sizeof(struct s_block) 这些代码平淡无奇，我们只是在sbrk调用失败的使用返回 NULL(我们并没有尝试着去理解为什么)。我们同样不能确定sbrk返回的是上一次的 break，我们仅仅是先保存它然后再移动它。我们可以用last和last-\u0026gt;size来计算。\n1t_block extend_heap(t_block last, size_t s) { 2 t_block b; 3 b = sbrk(0); 4 if (sbrk(BLOCK_SIZE + s) == (void *)-1) 5 return NULL; 6 b-\u0026gt;size = s; 7 b-\u0026gt;next = NULL; 8 if (last) 9 last-\u0026gt;next = b; 10 b-\u0026gt;free = 0; 11 return b; 12} 5.4 blocks 分裂 你可能已经意识到我们使用的是第一个满足需求的 block 而没有考虑它的 size(假如空间非常富裕呢)。如果我们这样做的话，那么我们会浪费掉很多空间(想象一下，你需要 2bytes，然后找到了一个 256bytes 的 block)。第一个解决方案就是分裂 blocks：当一个 chunk 比需要的空间大很多的时候，我们在链表中插入一个新的 chunk。\n下面的函数只有在空间可以被访问的情况下才会被调用。使用的 size 也必须是对齐的。在这个函数里，我们将做一些指针的算术操作，为了防止错误发生，我们将使用一些小技巧来确保我们的操作在 1byte 的误差范围内（内存 p+1 依赖于 p 指向的类型）。\n我们仅仅在结构体 s_block 中增加了一个字符数组类型的成员。结构体的末尾存在一个简单的数组：数组被放在结构体的末尾，对于我们而言，数组的指针就是 meta-data 的结束。c 语言禁止使用长度为 0 的数组(在 c99 之前)，所以我们定义了一个长度位 1 的字符数组，这也是我们为什么定义了一个代表 s_block 结构体 size 的红的原因。\n**说明：**此处使用到了Flexible array member技巧，该技巧在 c 语言开发中应用非常广泛，例如在 php 内核的 hash table 实现中也用到了，具体可参考鸟哥的博客：深入理解 PHP 之数组(遍历顺序) 1struct s_block { 2 size_t size; 3 t_block next; 4 int free; 5 char data[1]; 6}; 7 8#define BLOCK_SIZE 12 // 3 * 4 这个扩展并不需要对 extend_heap 做任何修改，因为新的字段并没有被直接使用。\n至此我们来实现split_block函数：该函数通过参数来把 block 切割成一个所需要的 size。\n1void split_block(t_block b, sizt_t s) { 2 t_block new; 3 new = b-\u0026gt;data + s; 4 new-\u0026gt;size = b-\u0026gt;size - s - BLOCK_SIZE; 5 new-\u0026gt;next = b-\u0026gt;next; 6 new-\u0026gt;free = 1; 7 b-\u0026gt;size = s; 8 b-\u0026gt;next = new; 9} 在上述的第三行代码中使用b-\u0026gt;data来做指针运算。因为 data 是字符数组类型，我们可以肯定的是误差精确到一个字节范围内。\n5.5 malloc 函数 好了，至此我们可以实现我们的 malloc 函数了。其实就是对前面所实现的函数的包装。我们需要将传入的 size 对齐，然后如前面所描述的那样检测我们是不是第一次调用 malloc 函数。\n首先别忘了 5.2 节中的函数find_block使用到了一个全局变量base。该变量的定义如下：\n1void *base = NULL; 这是一个void类型的指针，而且被初始化为NULL。malloc 函数首先需要做的事情就是检验base，如果为NULL则说明这是第一次调用，否则开始前面描述的算法：\n查找一个 free 状态的且有足够空间的 chunk; 如果我们找到了： 尝试着分割这个 block(需要的空间 size 和找到的 block 的 size 的差值足够存放 meta-data 和一个最小的 block(4bytes)) 将该 chunk 标记为使用状态(b-\u0026gt;free = 0) 否则：我们扩展堆 关于last变量的使用说明：find_block函数将最后一次访问的 chunk 的指针存放到last中，所以我们可以在扩展堆的时候使用它，从而避免遍历整个 list。\n否则：我们扩展堆（此时堆为空） 1void *malloc(size_t size) { 2 t_block b, last; 3 size_t s; 4 s = align4(size); 5 if (base) { 6 last = base; 7 b = find_block(\u0026amp;last, s); 8 if (b) { 9 /* can we split */ 10 if ((b-\u0026gt;size - s) \u0026gt;= (BLOCK_SIZE + 4)) 11 split_block(b, s); 12 b-\u0026gt;free = 0; 13 } else { 14 /* No fitting block, extend the heap */ 15 b = extend_heap(last, s); 16 if (!b) 17 return NULL; 18 } 19 } else { 20 /* first time */ 21 b = texted_heap(NULL, s); 22 if (!b) 23 return NULL; 24 base = b; 25 } 26 27 return b-\u0026gt;data; 28} 6 calloc, free 和 realloc 函数 6.1 calloc 说明：malloc(2),calloc(3)这种函数括号中带有数字表示的是函数在系统的 man page 中章节数，通常 Linux 系统章节数遵循以下约定：\n1、Standard commands (标准命令) 2、System calls (系统调用) 3、Library functions (库函数) 4、Special devices (设备说明) 5、File formats (文件格式) 6、Games and toys (游戏和娱乐) 7、Miscellaneous (杂项) 8、Administrative Commands (管理员命令)\ncalloc(3)也非常的简单：\n首先用正确的 size(两个操作数的产物)来调用 malloc; 将 block 中的每个 byte 都设置为 0. 这里我们又使用到了一些小小的技巧：data block 的 size 通常是 4 的倍数，因此将迭代的步长设置为 4bytes。为此，我们使用一个新的指针作为一个 unsigned integer 类型的数组。下面是实现的代码：\n1void *calloc(size_t number, size_t size) { 2 size_t *new; 3 size_t s4, i; 4 new = malloc(number * size); 5 if (new) { 6 s4 = align4(number * size) \u0026lt;\u0026lt; 2; 7 for (i = 0; i \u0026lt; s4; i++) 8 new[i] = 0; 9 } 10 11 return new; 12} 说明：\n此处 unsigned integer 类型长度为 4bytes 是针对 32 位操作系统，在 64 位系统中已经不适用； 因为 new 经过 4bytes 对齐后是 4 的倍数，所以其等于长度为number * size / 4的 unsigned integer 类型的数组，数组的每一个元素都有 4bytes，也就是说遍历数组的时候步长实际为 4bytes. 6.2 free 快速实现一个free(3)函数是很容易的，但是却不那么实用。我们有两个问题需要解决：一个是查找到要被释放的 chunk，另一个是避免空间碎片。\n6.2.1 碎片：malloc 函数的诟病 malloc 函数存在一个主要的问题就是碎片：经过几次 malloc 和 free 调用之后，我们把堆划分成了很多很小的 chunks，每一个 chunk 都很小不足以满足较大的 malloc 分配，但是所有的 chunks 加起来却能满足。这个问题被称作空间碎片问题。虽然不对算法进行修改我们无法阻止由于算法造成的额外碎片，但是我们可以避免其他碎片的来源。\n当我们选择了一个空间比所需空间大很多的空闲 chunk 的时候，我们分隔它。虽然这样做能够更有效的利用内存(新的 chunk 能够被接下来的分配所使用)，但是却产生了更多的碎片。\n一个限制碎片的解决方案是合并被释放的 chunks。当我们释放一个 chunk 的时候，如果与它相邻的 chunk 也是释放状态，那么我们将他们合并成一个较大的 chunk。我们需要做的仅仅是检查当前 chunk 的上一个 chunk 和下一个 chunk。但是如何找到上一个 chunk 呢？下面列举了一些解决方案：\n从起始位置开始查找，会特别慢(尤其是我们已经做了一次查找被释放 chunk 的操作) 如果我们已经做了查找当前 chunk 的操作，我们可以将上次访问的 chunk 的指针保存起来(就像 find_block 函数中那样) 将链表改为双向链表 我们选择了最后一个方案，因为它很简单，而且可以让我们使用一些技巧来查找目标 chunk。因此我们再次修改我们的 struct s_block，但是由于我们还有其他的修改(见下一节)，所以我们将会在后边的修改中呈现其代码。\n于是，我们现在要做的就是合并操作。我们首先实现一个简单的合并函数来合并 chunk 和它的后继(注：前驱，后继，都是链表中的术语)结点。合并前驱结点同理。在下面的代码中我们使用新的字段prev来表示前驱结点。\n1t_block fusion(t_block b) { 2 if (b-\u0026gt;next \u0026amp;\u0026amp; b-\u0026gt;next-\u0026gt;free) { 3 b-\u0026gt;size += BLOCK_SIZE + b-\u0026gt;next-\u0026gt;size; 4 b-\u0026gt;next = b-\u0026gt;next-\u0026gt;next; 5 if (b-\u0026gt;next) 6 b-\u0026gt;next-\u0026gt;prev = b; 7 } 8 return b; 9} 合并的原理很清晰：如果下一个 chunk 为 free，我们将两个 chunk 的 size 相加，然后再加上 meta-data 的 size 并赋值给当前 chunk 的 size。接着我们将当前 chunk 的后继指向当前结点后继的后继结点，如果这个结点存在的话，将其前驱结点设置为当前结点。\n6.2.2 查找正确的 chunk 另一个释放操作的问题是如何高效，正确的查找被 malloc 分配的 chunk。要实现就需要解决下面的问题：\n校验传入的指针是否真的是 malloc 返回的指针； 查找 meta-data 指针 我们可以通过范围检测快速排出掉大多数无效指针：如果指针超出了堆的范围，那么就是无效指针。对于没有被排出的指针，我们如何来确保他就一定是被 malloc 返回的呢？\n一个方法是在 block 结构体中加入一些特殊的数字。一个很好的特殊数字就是使用它自身的指针：我们加入一个ptr字段指向该结构体的 data 字段，如果b-\u0026gt;ptr == b-\u0026gt;data，那么 b 很可能就是能够被 free 操作释放的 block。下面是扩展后的结构体：\n1struct s_block { 2 size_t size; 3 struct s_block *next; 4 struct s_block *prev; 5 int free; 6 void *ptr; 7 char data[1]; 8}; 9 10typedef struct s_block *t_block; 11 12/* Get the block from an addr */ 13t_block get_block(void *p) { 14 char *tmp; 15 tmp = p; 16 return (p = tmp -= BLOCK_SIZE); 17} 18 19/* valid addr for free */ 20int valid_addr(void *p) { 21 if (base) { 22 if (p \u0026gt; base \u0026amp;\u0026amp; p \u0026lt; sbrk(0) { 23 return (p == (get_block(p))-\u0026gt;ptr); 24 } 25 } 26 return 0; 27} 6.2.3 free 函数 free 函数的流程为：首先校验指针然后的到相应的 chunk，将其标记为 free，如果可以的话，进行合并。如果在堆的末尾，我们还要对内存进行释放。\n释放内存的操作也是非常简单的：如果在堆的末尾，我们只需要通过简单的调用brk(2)将 break 移动到 chunk 的起始位置。\n如果指针通过校验： 获取 block 的地址 如果前驱结点存在而且 free，移动到前一个 block 并将这两个 blocks 合并 同样的操作来合并后继结点 如果是最后一个 block，那么释放内存 如果已经没有 block 了，那么回到最开始的状态(将 base 设置为 NULL) 如果指针没有通过校验，不需要做任何操作 1void free(void *p) { 2 t_block b; 3 if (valid_addr(p)) { 4 b = get_block(p); 5 b-\u0026gt;free = 1; 6 if (b-\u0026gt;prev \u0026amp;\u0026amp; b-\u0026gt;prev-\u0026gt;free) 7 b = fusion(b-\u0026gt;prev); 8 if (b-\u0026gt;next) 9 fusion(b); //此处之所以这么写请看fusion函数的实现就会明白 10 else { 11 if (b-\u0026gt;prev) 12 b-\u0026gt;prev-\u0026gt;next = NULL; 13 else 14 base = NULL; 15 brk(b); 16 } 17 } 18} 6.3 通过 realloc 函数调整 chunk 的大小 realloc(3)函数和calloc(3)一样很简单。基本上我们只需要多做一个内存拷贝的操作而已。这里我不想用系统提供的memcyp函数，因为我们可以做一个更好的。\n1void copy_block(t_block src, t_block dst) { 2 int *sdata, *ddata; 3 size_t i; 4 sdata = src-\u0026gt;ptr; 5 ddata = dst-\u0026gt;ptr; 6 //用到了前面的技巧，用整型数组，使得移动的步长为4bytes(32位系统) 7 for (i = 0; i * 4 \u0026lt; src-\u0026gt;size \u0026amp;\u0026amp; i * 4 \u0026lt; dst-\u0026gt;size; i++) { 8 ddata[i] = sdata[i]; 9 } 10} 一个很天真却有用的 relloc 只需要遵循以下算法规则：\n使用 malloc 分配一个新的大小为给定 size 的 block 拷贝 data 释放之前的 block 返回一个新的指针 当然，我们想更高效一些：如果我们有足够的空间的话，就不希望再做一个新的分配操作。不同之处在于：\n如果 size 没有改变，或者额外的空间满足需要，即使有少量多余的空间也不足以分割，那么不做任何操作 如果缩小 block，那么做分割操作 如果后继 block 是 free 状态，而且能够提供足够的空间，那么合并他们，如果可能的话尝试做分割操作 下面就是具体的代码实现。不过需要注意的是，realloc(NULL, s)这样的调用是合法的，而且会被替换成malloc(s)调用。\n1void *realloc(void *p, size_t size) { 2 size_t s; 3 t_block b, new; 4 void *newp; 5 if (!p) { 6 return malloc(size); 7 } 8 9 if (valid_addr(p)) { 10 s = align4(size); 11 b = get_block(p); 12 if (b-\u0026gt;size \u0026gt;= s) { 13 if (b-\u0026gt;size - s \u0026gt;= BLOCK_SIZE + 4) 14 split_block(b, s); 15 } else { 16 if (b-\u0026gt;next \u0026amp;\u0026amp; b-\u0026gt;next-\u0026gt;free \u0026amp;\u0026amp; (b-\u0026gt;size + BLOCK_SIZE + b-\u0026gt;next-\u0026gt;size) \u0026gt;= s) { 17 fusion(b); 18 if (b-\u0026gt;size - s \u0026gt;= BLOCK_SIZE + 4) 19 split_block(b, s); 20 } else { 21 newp = malloc(s); 22 if (!newp) 23 return NULL; 24 new = get_block(newp); 25 copy_block(b, new); 26 free(p); 27 return newp; 28 } 29 } 30 31 return p; 32 } 33 34 return NULL; 35} 6.3.1 FreeBSD 的 reallocf 函数 FreeBSD 提供了另一个 realloc 函数：realloc(3)函数会在重新分配失败的情况下释放掉原来的指针。\n1void *reallocf(void *p, size_t size) { 2 void *newp; 3 newp = realloc(p, size); 4 if (!newp) 5 free(p); 6 return newp; 7} 6.4 总结 现在已经修改好了 block 结构体，我们只需要重写split_block函数和extend_heap函数，并重新定义BLOCK_SIZE。\n1struct s_block { 2 size_t size; 3 struct s_block *next; 4 struct s_block *prev; 5 int free; 6 void *ptr; 7 char data[1]; 8}; 9 10typedef struct s_block *t_block; 11//定义block的size，因为使用sizeof调用的话会将最后一个data[1]也计算进来， 12//实际上这个字段没有占用空间 13//注意：在c99之后，直接使用char data[]，就不需要此定义，直接使用sizeof即可 14#define BLOCK_SIZE 20; 15 16//仅仅是简单的双向链表操作而已 17void split_block(t_block b, size_t s) { 18 t_block new; 19 new = (t_block)(b-\u0026gt;data + s); 20 new-\u0026gt;size = b-\u0026gt;size - s - BLOCK_SIZE; 21 new-\u0026gt;next = b-\u0026gt;next; 22 new-\u0026gt;prev = b; 23 new-\u0026gt;free = 1; 24 new-\u0026gt;ptr = new-\u0026gt;data; 25 b-\u0026gt;size = s; 26 b-\u0026gt;next = new; 27 if (new-\u0026gt;next) 28 new-\u0026gt;next-\u0026gt;prev = new; 29} 30 31//在堆尾添加一个结点，如果操作失败返回NULL 32t_block extend_heap(t_block last, size_t s) { 33 int sb; 34 t_block b; 35 b = sbrk(0); 36 sb = (int)sbrk(BLOCK_SIZE + s); 37 if (sb \u0026lt; 0) 38 return NULL; 39 b-\u0026gt;size = s; 40 b-\u0026gt;next = NULL; 41 b-\u0026gt;prev = last; 42 b-\u0026gt;ptr = b-\u0026gt;data; 43 if (last) 44 last-\u0026gt;next = b; 45 b-\u0026gt;free = 0; 46 return b; 47} 7 问题和优化 通过从无到有实作一个 malloc 让我们对计算机程序的的内存分配和管理有了更深的理解，知道了产生内存碎片的原因以及如何去优化。然而此实作存在很多不足，主要表现为以下几点：\n原文是基于 32 位系统实现的，所以后期可以将其优化为同时兼容 32 位和 64 位系统 原文中使用的 Flexible array member 是基于 c99 之前的写法，可以优化为 c99 支持的写法 原文中使用的brk和sbrk已经过时 ","date":"March 17, 2017","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/sp/2017-03-17-%E5%BD%BB%E5%BA%95%E6%8E%8C%E6%8F%A1malloc/","series":[],"smallImg":"","tags":[{"title":"C","url":"/blog/tags/c/"},{"title":"Sp","url":"/blog/tags/sp/"}],"timestamp":1489708800,"title":"彻底掌握malloc"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"Programming","url":"/blog/categories/programming/"}],"content":" Preface 当今世道，各种高级语言百花齐放。然而会有人发出这样的疑问\u0026ndash;计算机真的能够识别这么多语言吗？稍微有点常识的人都知道，这显然是不可能滴！在计算机的世界里，他们能够直接识别的只有机器语言。然而，由于机器语言对人类不够友好，所以人们才发明了汇编，c，Java\u0026hellip;许许多多的人类易读的编程语言，所以我个人对编程语言的理解一直是其实他们就是机器语言的语法糖，而编程语言的创造过程，就是定义一种合理的，没有二义性的语法规则，然后就是通过直接或间接的方式实现该语法到机器语言的转换过程。既然是这样的话，那么我们就很容易想到，计算机语言是一个自我完善的过程：首先我们定了一种非常简单的 x1(这里只是用来举例说明，有没有 x 语言有待考证)语言，然后用机器语言实现了这个非常简单的 x1 语言的编译器，创造了 x1 语言，实现了非常简单的新特性，然后我们再用 x1 语言(相对于机器语言较高级)实现了另一些新的特性的 x2 语言的编译器，创造了 x2 语言，\u0026hellip;，如此下去，人们创造了汇编语言，从而创造了 c 语言，接着创造了世界上最好的语言 PHP(不知道是不是真的，反正大家都习惯这么说)。 在各种高级语言越来越强大的今天，我们可能很难再会去接触最原始的东西，高度封装确实提高了生产力，降低了学习成本，但是也使得现代程序员将太多精力花在了各种说明书上，而不清楚其本质。 毕业一年多，工作了一年多，对于计算机编程有了自己的看法，不再像在大学的时候认识的那样肤浅，反而觉得大学中学习的知识才是真正的干货，不禁感叹曾经浪费掉了大好光阴。好在陶渊明有词云：“悟已往之不谏，知来者之可追”。 闲暇之余，扒开 PHP(这里之所以是 PHP 并不因为他是世界上最好的语言，只是因为我目前从事的是 PHP 开发的工作而已)源码，了解了其内部构造和实现原理，百看不一练。今天就初步学习 yacc/lex 了，记录在我的博客中，以便以后翻阅巩固。\n过程简述 一般来说编程语言的解释执行过程如下：\nONE. 词法分析 将源代码拆分成若干 Token 的过程\nTWO.语法分析 将 Token 构建成 Syntax Tree 的过程\nTHREE.生成执行码 生成可执行文件\nyacc（Yet Another Compiler Compiler） 下面是 wikipedia 中对 yacc 的描述\nYacc is a computer program for the Unix operating system. It is a Look Ahead Left-to-Right (LALR) parser generator, generating a parser, the part of a compiler that tries to make syntactic sense of the source code, specifically a LALR parser, based on an analytic grammar written in a notation similar to Backus–Naur Form (BNF). Yacc itself used to be available as the default parser generator on most Unix systems, though it has since been supplanted as the default by more recent, largely compatible, programs.\n其安装非常简单\n1sudo apt-get install bison lex/flex lex 是一个生成词法分析器的工具。Lex 读进一个代表词法分析器规则的输入字符串流，然后输出以 C 语言实做的词法分析器源代码。传统上，lex 属于商业软件，但是有些根据原本 AT\u0026amp;T 代码这些版本的 Lex 可以以公开源代码的形式获得，并被视为某些系统的一部分，例如说 OpenSolaris 和贝尔实验室九号项目。另一个有名的 Lex 公开源代码版本是 flex，代表\u0026quot;快速的词法分析器\u0026quot;（fast lexical analyzer）\n在 linux 下安装\n1sudo apt-get install flex practice 实现一个简单的计算程序 首先定义 lex 规则，其扩展名为.l，在 lex 中可以很容易读懂其定义的规则，因为他用到的是正则表达式。\n1%{ 2/* 3 |------------------------------------------------------------------ 4 | linger test 5 |------------------------------------------------------------------ 6 | @author : liubang 7 | @date : 16/10/27 下午8:28 8 | @copyright : (c) liubang.github.io/blog 9 | @license : MIT (http://opensource.org/licenses/MIT) 10 |------------------------------------------------------------------ 11 */ 12 13#include \u0026lt;stdio.h\u0026gt; 14#include \u0026#34;y.tab.h\u0026#34; 15 16int yywrap(void) 17{ 18\treturn 1; 19} 20%} 21 22%% 23 24\u0026#34;+\u0026#34;\treturn ADD; 25\u0026#34;-\u0026#34;\treturn SUB; 26\u0026#34;*\u0026#34;\treturn MUL; 27\u0026#34;/\u0026#34;\treturn DIV; 28\u0026#34;\\n\u0026#34;\treturn CR; 29 30([1-9][0-9]*)|0|([0-9]+\\.[0-9]+) { 31\tdouble d; 32\tsscanf(yytext, \u0026#34;%lf\u0026#34;, \u0026amp;d); 33\tyylval.double_value = d; 34\treturn DOUBLE_LITERAL; 35} 36 37[ \\t] ; 38. { 39\tfprintf(stderr, \u0026#34;lexical error.\\n\u0026#34;); 40\texit(1); 41} 42%% 可以看到以上的代码主要包含两部分，%{ %}包含的部分和\\%\\% \\%\\%包含的部分。前一部分叫定义区块, 后者是规则区块，定义区块内的代码将会被原样输出，在定义区块中#include \u0026quot;y.tab.h\u0026quot;将会在 yacc 编译其规则文件后自动生成，ADD SUB MUL DIV CR DOUBLE_LITERAL等都是在 y.tab.h 中定义的 macro。 在定义区块中，有一个名为yywrap的 function，其作用是自动 link lex 的库文件。 至于规则区块，学过正则表达式的人一看就会明白，其作用就是使用正则表达式来描述 Token。规则区块的定义为：正则表达式，后边跟上 C 代码，这些代码用{}括起来，读入的字符流满足了正则，则执行其后的代码，匹配到的原字符被保存在yytext这个全局变量中。\n接着来编写 yacc 的规则，其扩展名为.y。\n1%{ 2/* 3 |------------------------------------------------------------------ 4 | linger test 5 |------------------------------------------------------------------ 6 | @author : liubang 7 | @date : 16/10/27 下午8:43 8 | @copyright : (c) liubang.github.io/blog 9 | @license : MIT (http://opensource.org/licenses/MIT) 10 |------------------------------------------------------------------ 11 */ 12 13#include \u0026lt;stdio.h\u0026gt; 14#include \u0026lt;stdlib.h\u0026gt; 15#define YYDEBUG 1 16 17%} 18 19%union { 20\tint\tint_value; 21\tdouble\tdouble_value; 22} 23 24%token \u0026lt;double_value\u0026gt;\tDOUBLE_LITERAL 25%token ADD SUB MUL DIV CR 26%type \u0026lt;double_value\u0026gt; expression term primary_expression 27 28%% 29 30line_list 31\t: line 32\t| line_list line 33; 34line 35\t: expression CR 36\t{ 37\tprintf(\u0026#34;\u0026gt;\u0026gt;%lf\\n\u0026#34;, $1); 38\t} 39; 40expression 41\t: term 42\t| expression ADD term 43\t{ 44\t$$ = $1 + $3; 45\t} 46\t| expression SUB term 47\t{ 48\t$$ = $1 - $3; 49\t} 50; 51term 52\t: primary_expression 53\t| term MUL primary_expression 54\t{ 55\t$$ = $1 * $3; 56\t} 57\t| term DIV primary_expression 58\t{ 59\t$$ = $1 / $3; 60\t} 61; 62primary_expression 63\t: DOUBLE_LITERAL 64; 65 66%% 67 68int yyerror(char const *str) 69{ 70\textern char *yytext; 71\tfprintf(stderr, \u0026#34;syntax error near %s\\n\u0026#34;, yytext); 72\treturn 0; 73} 74 75int main(void) 76{ 77\textern int yyparse(void); 78\textern FILE *yyin; 79 80\tyyin = stdin; 81\tif (yyparse()) { 82\tfprintf(stderr, \u0026#34;Core Dump!\\n\u0026#34;); 83\texit(1); 84\t} 85} yacc 规则定义跟 lex 相似，都用到了\\%{\\%} \\%\\%来包含代码块。 同样的是\\%{\\%}包裹的代码将被原样输出。 在\\%union定义中，声明了记号和非终结符的类型，其最终会被编译成一个 c 语言的 union。这里定义了一个 int 类型的 int_value 和 double 类型的 double_value。 \\%token开头的行是 Token 的声明，所有用到的 Token 类型都在这里定义。对于ADD SUB MUL DIV CR等记号只需要包含其类型即可，而对于值为DOUBLE_LITERAL的 Token，其类型被指定为\u0026lt;double_value\u0026gt;，这里的 double_value 正是来自于前面声明的 union 中的成员之一。 %%包裹的部分叫做规则区块，由语法规则和 C 语言编写的相应的行为两部分构成。在 yacc 中使用了类似于 BNF 范式来编写语法规则。由于使用了自然语言作为标记，理解上还是很容易的。下面举个简单的例子：\n1line_list /* 多行规则 */ 2\t: line /* 单行 */ 3\t| line_list line /* 或者多行后跟单行 */ 4; 5line /* 单行 */ 6\t: expression CR /* 表达式后跟换��符 */ 7; 8expression /* 表达式 */ 9\t: term /* 和项 */ 10\t| expression ADD term /* 或者表达式加上和项 */ 11\t{ /* 匹配后执行的action */ 12\t$$ = $1 + $3; 13\t} 14\t| expression SUB term /* 或者表达式减去和项 */ 15\t{ /* 匹配后执行的action */ 16\t$$ = $1 - $3; 17\t} 18; 19term /* 和项 */ 20\t: primary_expression /* 一元表达式 */ 21\t| term MUL primary_expression /* 或者和项乘以一元表达式 */ 22\t{ /* 匹配后执行的action */ 23\t$$ = $1 * $3; 24\t} 25\t| term DIV primary_expression /* 或者和项除以一元表达式 */ 26\t{ /* 匹配后执行的action */ 27\t$$ = $1 / $3; 28\t} 29; 30primary_expression /* 一元表达式 */ 31\t: DOUBLE_LITERAL /* 实数字面量 */ 32; 写好了规则，那么就来编译运行\n1yacc -dv foo.y 2flex foo.l 3gcc -std=c99 -Wall -g -o foo y.tab.c lex.yy.c 这样就生成了foo这个可执行文件 运行 foo\n1liubang@venux:~/workspace/c/my_lang/lex$ make run 21 + 3 3\u0026gt;\u0026gt;4.000000 41/2 5\u0026gt;\u0026gt;0.500000 64 * 5 7\u0026gt;\u0026gt;20.000000 当然我个人在开发 c 程序的时候偏向于使用 make 工具来编译代码，这样会很方便。下面是我的 Makefile 文件:\n1CFLAGS = -O2 -g -Wall -std=c99 2EXEC = foo 3OBJS =\ty.tab.o \\ 4\tlex.yy.o 5 6 7%.c: 8\tyacc -dv foo.y 9\tlex foo.l 10 11%.o: %.c 12\t$(CC) $(CFLAGS) -o $@ -c $\u0026lt; 13 14$(EXEC): $(OBJS) 15\t$(CC) $(OBJS) -o $@ 16 17all: $(EXEC) 18 19run: $(EXEC) 20\t@./$(EXEC) 21 22clean: 23\t$(RM) $(OBJS) $(EXEC) 只需要执行make run命令即可运行！\n附加 可能有人会疑惑，这玩意学着有什么用，那么有兴趣的你可以下载一份 PHP 的源代码，在 Zend(Zend 引擎核心文件)目录中你不难找到zend_language_scanner.l,zend_ini_scanner.l,zend_ini_parser.y,zend_language_parser.y这几个文件，打开其内容，是不是不再那么恐惧和陌生了呢。\nSummary 本文只是初步介绍 yacc/lex 工具生成词法解析器和语法解析器的最基本用法，没有太多的阐述词法解析的原理和过程，所以更偏实践，再由于本人毕业一年多实在很久没写文章了，常常会提笔不知从何说起，所以写起来很慢，加之白天要工作，时间较紧，所以今天就到这里了，至于理论的阐述，需要时间来慢慢酝酿 😂！\n","date":"March 15, 2017","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/compiler/2017-03-15-%E5%9F%BA%E4%BA%8Ec%E8%AF%AD%E8%A8%80%E7%9A%84%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91/","series":[],"smallImg":"","tags":[{"title":"C","url":"/blog/tags/c/"},{"title":"Compiler","url":"/blog/tags/compiler/"}],"timestamp":1489536000,"title":"基于c语言的编程语言开发"},{"authors":[{"title":"Liu Bang","url":"/blog/authors/liubang/"}],"categories":[{"title":"Programming","url":"/blog/categories/programming/"}],"content":" 函数调用 很多时候，我们需要通过函数名来调用函数，并传递参数，或者把匿名函数作为函数的参数传递，实现回调。当我们在遇到这样的需求的时候，用 php 代码实现起来肯定是非常容易和简单的。但是，当我们在用 c 语言编写 php 扩展的时候，如何来实现这样的功能呢？下面就一起来深入了解 php 内核，看看如何实现。\n在 Zend 引擎中，给我们提供了zend_call_function,call_user_function以及call_user_function_ex函数来帮助我们实现函数调用。在zend_API.h文件中，我们可以看到如下函数原型的声明：\n1ZEND_API int zend_call_function(zend_fcall_info *fci, zend_fcall_info_cache *fci_cache TSRMLS_DC); 2ZEND_API int call_user_function(HashTable *function_table, zval **object_pp, zval *function_name, zval *retval_ptr, zend_uint param_count, zval *params[] TSRMLS_DC); 3ZEND_API int call_user_function_ex(HashTable *function_table, zval **object_pp, zval *function_name, zval **retval_ptr_ptr, zend_uint param_count, zval **params[], int no_separation, HashTable *symbol_table TSRMLS_DC); 从函数的参数上来看，显然zend_call_function需要的参数很少，而其他两个都需要一堆参数，所以，我们可能会想，达到相同的效果为什么参数上有如此大的区别，于是带着这个疑问我们来解刨zend_fcall_info结构体。同样在zend_API.h中会看到如下结构体的定义：\n1typedef struct _zend_fcall_info { 2 size_t size; 3 HashTable *function_table; //函数表 4 zval *function_name;\t//函数，可以是函数名，也可以直接是匿名函数本身 5 HashTable *symbol_table; //符号表 6 zval **retval_ptr_ptr;\t//返回值 7 zend_uint param_count; //参数个数 8 zval ***params; //参数，数组 9 zval *object_ptr;\t//调用对象方法时候需要传调用的对象 10 zend_bool no_separation; 11} zend_fcall_info; 不难发现，原来是把相关字段封装到了结构体中了，所以显得参数数量少，实际上该有的都有。\n对于call_user_function中相关参数含义的解释，这里就不强行翻译了，引用官方的一段话，虽然是英文，但是我相信聪明的你也肯定能看懂的！\nUser functions can be called with the function call_user_function_ex(). It requires a hash value for the function table you want to access, a pointer to an object (if you want to call a method), the function name, return value, number of arguments, argument array, and a flag indicating whether you want to perform zval separation. Note that you don\u0026rsquo;t have to specify both function_table and object; either will do. If you want to call a method, you have to supply the object that contains this method, in which case call_user_function()automatically sets the function table to this object\u0026rsquo;s function table. Otherwise, you only need to specify function_table and can set object to NULL. Next is the parameter count as integer and an array containing all necessary parameters. The last argument specifies whether the function should perform zval separation - this should always be set to 0. If set to 1, the function consumes less memory but fails if any of the parameters need separation.\n实现自己的 call_user_func 函数 废话不多说，下面就来动手实现一个自己的call_user_func函数; 这个函数是一个比较特殊的函数，因为他除了第一个参数是一个字符串之外，剩余的参数都是可变参数，而且没有固定的个数，所以想到这里是不是发现又遇到了一些小小的困难。不过没关系，遇到一切问题首先要想到查阅官方文档，于是在php 官方文档中找到了答案，在该文档页中，向我们列举了所有的 Type Specifiers:\nSpec Type Locals a array zval* A array or object zval* b boolean zend_bool C class zend_class_entry* d double double f function zend_fcall_info*, zend_fcall_info_cache* h array HashTable* H array or object HashTable* l long long L long(limits out-of-range LONG_MAX/LONG_MIN) long o object zval* O object(of specified zend_class_entry) zval*, zend_class_entry * p string(a valid path) char*, int r resource zval* s string char*, int z mixed zval* Z mixed zval** 当我们看到这张表的时候只是了解到了在 php 扩展中参数传递对应关系，以及如何切当使用类型标记符，但是并没有解决我们需要传递不定长参数的问题。别着急，往下看会看到 Advanced Type Specifiers 这样的文字，是的，你没有看错，这玩意还有高级用法：\nSpec Description * a variable number of argument of the preceeding type, 0 or more + a variable number of argument of the preceeding type, 1 or more $\\mid$ indicates that the remaining parameters are optional ! the preceeding parameter can be of the specified type or null For \u0026lsquo;b\u0026rsquo;, \u0026rsquo;l\u0026rsquo; and \u0026rsquo;d\u0026rsquo;, an extra argument of type zend_bool* must be passed after the corresponding bool*, long* or double* addresses which will be set true if null is recieved. *，这不正是我们需要的吗！万事俱备，只欠东风，接下来，实现自己的call_user_func就是顺水推舟的事情了。\n1PHP_FUNCTION(demo_call_user_func) 2{ 3\tzend_fcall_info fci; 4\tzend_fcall_info_cache fci_cache; 5\tzval *retval_ptr = NULL; 6\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \u0026#34;f*\u0026#34;, \u0026amp;fci, \u0026amp;fci_cache, \u0026amp;fci.params, \u0026amp;fci.param_count) != SUCCESS) { 7\treturn; 8\t} 9\tfci.retval_ptr_ptr = \u0026amp;retval_ptr; 10\tif (zend_call_function(\u0026amp;fci, \u0026amp;fci_cache TSRMLS_CC) == SUCCESS \u0026amp;\u0026amp; fci.retval_ptr_ptr \u0026amp;\u0026amp; *fci.retval_ptr_ptr) { 11\treturn_value = *fci.retval_ptr_ptr; 12\tzval_copy_ctor(return_value); 13\tzval_ptr_dtor(\u0026amp;fci.retval_ptr_ptr); 14\t} 15\tif (fci.params) { 16\tefree(fci.params); 17\t} 18} 看到这里的代码，可能有些人还是一头雾水，不太明白为什么要这么写，至此我需要声明一下，我在写这篇博客的时候假想读者都是对 php 扩展开发有过一定了解的人，至少知道如何用 c 语言写一个输出\u0026quot;hello world\u0026quot;的扩展，知道如何返回值，以及如何创建 php 中的基本数据类型，如何赋值甚至了解 php 扩展中如何开发一个类。所以呢，假如你还没有这些基础怎么办，那也没办法，建议先回去补充知识咯。\n写好扩展，编译安装后我们来测试一下：\n1\u0026lt;?php 2 3function say($msg) { 4\techo $msg, PHP_EOL; 5} 6 7demo_call_user_func(\u0026#39;say\u0026#39;, \u0026#34;hello world\u0026#34;); 8 9demo_call_user_func(function($msg) { 10\techo $msg, PHP_EOL; 11}, \u0026#34;hello liubang\u0026#34;); 测试结果很自然的如我们所期待：\n1ubuntu@vm-911:~/workspace/c/php-5.6.30/ext/demo$ php test.php 2hello world 3hello liubang 回调函数 有了上面的铺垫，我想到这里写一个回调函数已经是一件非常简单的事情了，只不过在call_user_func之前或者之后来做一些其他的操作。废话不多说，直接上代码：\n1PHP_FUNCTION(demo_callback) 2{ 3\tzend_fcall_info fci; 4\tzend_fcall_info_cache fci_cache; 5\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \u0026#34;f\u0026#34;, \u0026amp;fci, \u0026amp;fci_cache) == FAILURE) { 6\treturn; 7\t} 8 9\tphp_printf(\u0026#34;this is callback demo...\\n\u0026#34;); 10\tphp_printf(\u0026#34;start call callback function\\n\u0026#34;); 11\tzval *retval_ptr = NULL; 12\tfci.retval_ptr_ptr = \u0026amp;retval_ptr; 13\tzval **arg[1]; 14\tzval *param; 15\tMAKE_STD_ZVAL(param); 16\tZVAL_STRING(param, \u0026#34;hello world\u0026#34;, 0); 17\targ[0] = \u0026amp;param; 18\tfci.param_count = 1; 19\tfci.params = arg; 20\tif (zend_call_function(\u0026amp;fci, \u0026amp;fci_cache TSRMLS_CC) == SUCCESS \u0026amp;\u0026amp; fci.retval_ptr_ptr \u0026amp;\u0026amp; *fci.retval_ptr_ptr) { 21\tCOPY_PZVAL_TO_ZVAL(*return_value, *fci.retval_ptr_ptr); 22\t} 23} 以上代码所对应的 php 代码为：\n1\u0026lt;?php 2 3function demo_callback(callable $callback) { 4\techo \u0026#34;this is callback demo...\\n\u0026#34;; 5\treturn $callback(\u0026#34;hello world\u0026#34;); 6} 下面我们编译安装后测试一下：\n1\u0026lt;?php 2 3demo_callback(function($msg) { 4\techo $msg, PHP_EOL; 5\techo \u0026#34;this is in callback function\\n\u0026#34;; 6}); 执行结果如下：\n1ubuntu@vm-911:~/workspace/c/php-5.6.30/ext/demo$ php test.php 2this is callback demo... 3start call callback function 4hello world 5this is in callback function 下面我再来用call_user_function_ex把回调重新实现一遍，写法基本一样：\n1PHP_FUNCTION(demo_callback_o) 2{ 3\tzval *func; 4\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \u0026#34;z\u0026#34;, \u0026amp;func) == FAILURE) { 5\treturn; 6\t} 7\tphp_printf(\u0026#34;before callback...\\n\u0026#34;); 8\tchar *func_name; 9\tif (!zend_is_callable(func, 0, \u0026amp;func_name TSRMLS_CC)) { 10\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \u0026#34;Function: \u0026#39;%s\u0026#39; is not callable\u0026#34;, func_name); 11\tRETURN_FALSE; 12\t} 13\tzval *retval; 14\tzval **arg[1]; 15\tzval *param; 16\tMAKE_STD_ZVAL(param); 17\tZVAL_STRING(param, \u0026#34;hello liubang\u0026#34;, 0); 18\targ[0] = \u0026amp;param; 19\tif (call_user_function_ex(EG(function_table), NULL, func, \u0026amp;retval, 1, arg, 0, NULL TSRMLS_CC) != SUCCESS) { 20\tphp_printf(\u0026#34;callback complated!\\n\u0026#34;); 21\t} 22\tCOPY_PZVAL_TO_ZVAL(*return_value, retval); 23} 效果和上边是一样的，所以这里就不再测试了。\n总结 看到这里，也许你会觉得，这东西到底有什么用呢，是的，单纯地这么来看确实没有用，可是如果你也是一个对开源代码感兴趣的人，也许你也发现了在 php 著名的开源框架swoole中，就有很多地方使用到了类似的技巧，不同的是，swoole中是把所有的回调函数注册到一张表(也就是一个 zval 的数组)中，在请求的恰当阶段再来调用，于是就有了我们看到的类似于事件驱动的效果。所以，有了这些知识，假设你已经掌握了 linux 系统下的 TCP/IP 网络编程，那么你创造一个类似于swoole的产品又有何难。\n","date":"March 9, 2017","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/posts/php/2017-03-09-php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8Bcall-user-func%E5%8E%9F%E7%90%86%E5%92%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/","series":[],"smallImg":"","tags":[{"title":"C","url":"/blog/tags/c/"},{"title":"Php","url":"/blog/tags/php/"}],"timestamp":1489017600,"title":"PHP扩展开发之call_user_func原理和回调函数的实现"},{"authors":[],"categories":[],"content":" 项目 ","date":"January 1, 2017","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/about/","series":[],"smallImg":"","tags":[],"timestamp":1483228800,"title":"关于"},{"authors":[],"categories":[],"content":"","date":"January 1, 1","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/blog/en/offline/","series":[],"smallImg":"","tags":[],"timestamp":-62135596800,"title":"Offline"},{"authors":[],"categories":[],"content":"","date":"January 1, 1","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/blog/offline/","series":[],"smallImg":"","tags":[],"timestamp":-62135596800,"title":"Offline"}]
